{
    "task": "task_149.json",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\n// planetsInOrder stores the planets from closest to the Sun to farthest.\nvar planetsInOrder = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\n// planetIndexMap provides a quick lookup for a planet's index.\nvar planetIndexMap = make(map[string]int)\n\nfunc init() {\n\t// Initialize the map once when the package is loaded.\n\tfor i, planet := range planetsInOrder {\n\t\tplanetIndexMap[planet] = i\n\t}\n}\n\n// Bf takes two planet names as strings and returns a slice of strings\n// containing all planets whose orbits are located between the orbit\n// of planet1 and the orbit of planet2, sorted by proximity to the sun.\n//\n// The function returns an empty slice if planet1 or planet2 are not\n// correct planet names, or if there are no planets between them (e.g.,\n// the planets are adjacent or the same).\nfunc Bf(planet1, planet2 string) []string {\n\t// Get indices of planet1 and planet2 from the lookup map.\n\tidx1, ok1 := planetIndexMap[planet1]\n\tidx2, ok2 := planetIndexMap[planet2]\n\n\t// Handle invalid input: return an empty slice if either planet name is not recognized.\n\tif !ok1 || !ok2 {\n\t\treturn []string{}\n\t}\n\n\t// Determine the smaller and larger index to define the range.\n\t// This ensures that we always slice from the \"closer\" planet's next neighbor\n\t// to the \"farther\" planet's previous neighbor, regardless of the order\n\t// of planet1 and planet2 in the function call.\n\tminIdx := min(idx1, idx2)\n\tmaxIdx := max(idx1, idx2)\n\n\t// Slice the planetsInOrder array to get the planets between minIdx and maxIdx.\n\t// The range for slicing is exclusive of the element at the high index,\n\t// so planetsInOrder[minIdx+1 : maxIdx] correctly selects elements\n\t// from (minIdx + 1) up to (maxIdx - 1).\n\t//\n\t// If minIdx + 1 >= maxIdx (e.g., the planets are adjacent or the same),\n\t// the slice operation will naturally result in an empty slice, which is the\n\t// correct behavior as there are no planets \"between\" them.\n\treturn planetsInOrder[minIdx+1 : maxIdx]\n}\n\n// min returns the smaller of two integers.\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// max returns the larger of two integers.\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go test",
                    "error": "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range [3:2] [recovered, repanicked]\n\ngoroutine 8 [running]:\ntesting.tRunner.func1.2({0x633e20, 0xc00001c318})\n\t/usr/local/go/src/testing/testing.go:1872 +0x237\ntesting.tRunner.func1()\n\t/usr/local/go/src/testing/testing.go:1875 +0x35b\npanic({0x633e20?, 0xc00001c318?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\nsynthesis.Bf(...)\n\t/tmp/go_synthesis_hfb3j3gg/main.go:48\nsynthesis.TestBf(0xc0000be8c0?)\n\t/tmp/go_synthesis_hfb3j3gg/main_test.go:14 +0xa1f\ntesting.tRunner(0xc0000be8c0, 0x661990)\n\t/usr/local/go/src/testing/testing.go:1934 +0xea\ncreated by testing.(*T).Run in goroutine 1\n\t/usr/local/go/src/testing/testing.go:1997 +0x465\nFAIL\tsynthesis\t0.004s\nFAIL"
                }
            ]
        },
        {
            "code": "package main\n\n// planetsInOrder stores the planets from closest to the Sun to farthest.\nvar planetsInOrder = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\n// planetIndexMap provides a quick lookup for a planet's index.\nvar planetIndexMap = make(map[string]int)\n\nfunc init() {\n\t// Initialize the map once when the package is loaded.\n\tfor i, planet := range planetsInOrder {\n\t\tplanetIndexMap[planet] = i\n\t}\n}\n\n// Bf takes two planet names as strings and returns a slice of strings\n// containing all planets whose orbits are located between the orbit\n// of planet1 and the orbit of planet2, sorted by proximity to the sun.\n//\n// The function returns an empty slice if planet1 or planet2 are not\n// correct planet names, or if there are no planets between them (e.g.,\n// the planets are adjacent or the same).\nfunc Bf(planet1, planet2 string) []string {\n\t// Get indices of planet1 and planet2 from the lookup map.\n\tidx1, ok1 := planetIndexMap[planet1]\n\tidx2, ok2 := planetIndexMap[planet2]\n\n\t// Handle invalid input: return an empty slice if either planet name is not recognized.\n\tif !ok1 || !ok2 {\n\t\treturn []string{}\n\t}\n\n\t// Determine the smaller and larger index to define the range.\n\t// This ensures that we always slice from the \"closer\" planet's next neighbor\n\t// to the \"farther\" planet's previous neighbor, regardless of the order\n\t// of planet1 and planet2 in the function call.\n\tminIdx := min(idx1, idx2)\n\tmaxIdx := max(idx1, idx2)\n\n\t// If minIdx+1 is greater than or equal to maxIdx, it means there are no planets\n\t// between the two given planets (they might be the same, adjacent, or the indices\n\t// define an invalid range for slicing). In such cases, return an empty slice\n\t// to prevent a \"slice bounds out of range\" panic and to correctly implement\n\t// the \"no planets between\" requirement.\n\tif minIdx+1 >= maxIdx {\n\t\treturn []string{}\n\t}\n\n\t// Slice the planetsInOrder array to get the planets between minIdx and maxIdx.\n\t// The range for slicing is exclusive of the element at the high index,\n\t// so planetsInOrder[minIdx+1 : maxIdx] correctly selects elements\n\t// from (minIdx + 1) up to (maxIdx - 1).\n\treturn planetsInOrder[minIdx+1 : maxIdx]\n}\n\n// min returns the smaller of two integers.\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// max returns the larger of two integers.\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}