{
    "task": "task_148.json",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\n// You are given a positive integer n. You have to create an integer array a of length n.\n// For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n// Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n// and a[i] + a[j] + a[k] is a multiple of 3.\n// \n// Example :\n// Input: n = 5\n// Output: 1\n// Explanation:\n// a = [1, 3, 7, 13, 21]\n// The only valid triple is (1, 7, 13).\nfunc GetMaxTriples(n int) int {\n\t// First, let's analyze the values of a[i] modulo 3.\n\t// a[i] = i*i - i + 1 = i*(i-1) + 1.\n\n\t// We check the remainder of a[i] when divided by 3 based on i % 3:\n\t// Case 1: i % 3 == 0 (e.g., i = 3, 6, ...)\n\t//   a[i] % 3 = (0 * (0-1) + 1) % 3 = (0 + 1) % 3 = 1\n\t//   Example: a[3] = 3*3 - 3 + 1 = 7. 7 % 3 = 1.\n\t//\n\t// Case 2: i % 3 == 1 (e.g., i = 1, 4, ...)\n\t//   a[i] % 3 = (1 * (1-1) + 1) % 3 = (1 * 0 + 1) % 3 = 1\n\t//   Example: a[1] = 1*1 - 1 + 1 = 1. 1 % 3 = 1.\n\t//\n\t// Case 3: i % 3 == 2 (e.g., i = 2, 5, ...)\n\t//   a[i] % 3 = (2 * (2-1) + 1) % 3 = (2 * 1 + 1) % 3 = 3 % 3 = 0\n\t//   Example: a[2] = 2*2 - 2 + 1 = 3. 3 % 3 = 0.\n\n\t// Conclusion:\n\t// - a[i] % 3 is 0 if i % 3 == 2.\n\t// - a[i] % 3 is 1 if i % 3 == 0 or i % 3 == 1.\n\t// - No a[i] will have a remainder of 2 when divided by 3.\n\n\t// Let's count the number of elements in array 'a' (from index 1 to n)\n\t// that have a remainder of 0 when divided by 3 (let's call this count `c0`).\n\t// And the number of elements that have a remainder of 1 when divided by 3 (let's call this count `c1`).\n\n\t// `c0` is the count of `i` in the range `[1, n]` such that `i % 3 == 2`.\n\t// These `i` values are 2, 5, 8, ...\n\t// This count can be calculated efficiently using integer division:\n\t// For n=1: (1+1)/3 = 0.\n\t// For n=2: (2+1)/3 = 1 (i=2).\n\t// For n=3: (3+1)/3 = 1 (i=2).\n\t// For n=4: (4+1)/3 = 1 (i=2).\n\t// For n=5: (5+1)/3 = 2 (i=2, 5).\n\t// This formula `(n + 1) / 3` correctly yields `c0`.\n\tc0 := (n + 1) / 3\n\n\t// `c1` is the count of `i` in the range `[1, n]` such that `i % 3 == 0` or `i % 3 == 1`.\n\t// This is simply the total number of elements `n` minus `c0`.\n\tc1 := n - c0\n\n\t// We need to find triples (a[i], a[j], a[k]) such that i < j < k and (a[i] + a[j] + a[k]) % 3 == 0.\n\t// This is equivalent to (a[i]%3 + a[j]%3 + a[k]%3) % 3 == 0.\n\t// Since a[x]%3 can only be 0 or 1, the only combinations of remainders that sum to a multiple of 3 are:\n\t// 1. (0, 0, 0): All three elements have a remainder of 0. Sum = 0.\n\t// 2. (1, 1, 1): All three elements have a remainder of 1. Sum = 3.\n\n\t// So, we need to count:\n\t// A. The number of ways to choose 3 elements from the `c0` group. This is C(c0, 3).\n\t// B. The number of ways to choose 3 elements from the `c1` group. This is C(c1, 3).\n\n\t// The combination function C(x, k) = x! / (k! * (x-k)!).\n\t// For k=3, C(x, 3) = x * (x-1) * (x-2) / (3 * 2 * 1) = x * (x-1) * (x-2) / 6.\n\t// If x < 3, C(x, 3) is 0 because we cannot choose 3 items from less than 3 available items.\n\n\tnumTriplesC0 := 0\n\tif c0 >= 3 {\n\t\tnumTriplesC0 = c0 * (c0 - 1) * (c0 - 2) / 6\n\t}\n\n\tnumTriplesC1 := 0\n\tif c1 >= 3 {\n\t\tnumTriplesC1 = c1 * (c1 - 1) * (c1 - 2) / 6\n\t}\n\n\treturn numTriplesC0 + numTriplesC1\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}