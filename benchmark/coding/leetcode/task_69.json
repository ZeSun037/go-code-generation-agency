{
  "task_id": "Go/68",
  "prompt": "import (\n    \"math\"\n)\n\n// Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to Pluck one of the nodes and return it.\n// The Plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// \n// The Plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// \n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 3:\n// Input: []\n// Output: []\n// \n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// \n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc Pluck(arr []int) []int {\n",
  "import": "import (\n    \"math\"\n)",
  "docstring": "// Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to Pluck one of the nodes and return it.\n// The Plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// \n// The Plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// \n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// \n// Example 3:\n// Input: []\n// Output: []\n// \n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// \n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n",
  "declaration": "\nfunc Pluck(arr []int) []int {\n",
  "canonical_solution": "    result := make([]int, 0)\n\tif len(arr) == 0 {\n\t\treturn result\n\t}\n\tevens := make([]int, 0)\n\tmin := math.MaxInt64\n\tminIndex := 0\n\tfor i, x := range arr {\n\t\tif x%2 == 0 {\n\t\t\tevens = append(evens, x)\n\t\t\tif x < min {\n\t\t\t\tmin = x\n\t\t\t\tminIndex = i\n\t\t\t}\n\t\t}\n\t}\n\tif len(evens) == 0 {\n\t\treturn result\n\t}\n\tresult = []int{min, minIndex}\n\treturn result\n}\n\n",
  "test": "func TestPluck(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 1}, Pluck([]int{4,2,3}))\n    assert.Equal([]int{2, 1}, Pluck([]int{1,2,3}))\n    assert.Equal([]int{}, Pluck([]int{}))\n    assert.Equal([]int{0, 1}, Pluck([]int{5, 0, 3, 0, 4, 2}))\n    assert.Equal([]int{0, 3}, Pluck([]int{1, 2, 3, 0, 5, 3}))\n    assert.Equal([]int{4, 1}, Pluck([]int{5, 4, 8, 4 ,8}))\n    assert.Equal([]int{6, 1}, Pluck([]int{7, 6, 7, 1}))\n    assert.Equal([]int{}, Pluck([]int{7, 9, 7, 1}))\n}\n",
  "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n",
  "example_test": "func TestPluck(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal([]int{2, 1}, Pluck([]int{4,2,3}))\n    assert.Equal([]int{2, 1}, Pluck([]int{1,2,3}))\n    assert.Equal([]int{}, Pluck([]int{}))\n    assert.Equal([]int{0, 1}, Pluck([]int{5, 0, 3, 0, 4, 2}))\n}\n"
}