{
  "task_id": "Go/132",
  "prompt": "\n// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets\n// where at least one bracket in the subsequence is nested.\n// \n// IsNested('[[]]') ➞ true\n// IsNested('[]]]]]]][[[[[]') ➞ false\n// IsNested('[][]') ➞ false\n// IsNested('[]') ➞ false\n// IsNested('[[][]]') ➞ true\n// IsNested('[[]][[') ➞ true\nfunc IsNested(s string) bool {\n",
  "import": "",
  "docstring": "// Create a function that takes a string as input which contains only square brackets.\n// The function should return true if and only if there is a valid subsequence of brackets\n// where at least one bracket in the subsequence is nested.\n// \n// IsNested('[[]]') ➞ true\n// IsNested('[]]]]]]][[[[[]') ➞ false\n// IsNested('[][]') ➞ false\n// IsNested('[]') ➞ false\n// IsNested('[[][]]') ➞ true\n// IsNested('[[]][[') ➞ true\n",
  "declaration": "\nfunc IsNested(s string) bool {\n",
  "canonical_solution": "    opening_bracket_index := make([]int, 0)\n    closing_bracket_index := make([]int, 0)\n    for i:=0;i < len(s);i++ {\n        if s[i] == '[' {\n            opening_bracket_index = append(opening_bracket_index, i)\n        } else {\n            closing_bracket_index = append(closing_bracket_index, i)\n        }\n    }\n    for i := 0;i < len(closing_bracket_index)>>1;i++ {\n        closing_bracket_index[i], closing_bracket_index[len(closing_bracket_index)-i-1] = closing_bracket_index[len(closing_bracket_index)-i-1], closing_bracket_index[i]\n    }\n    cnt := 0\n    i := 0\n    l := len(closing_bracket_index)\n    for _, idx := range opening_bracket_index {\n        if i < l && idx < closing_bracket_index[i] {\n            cnt++\n            i++\n        }\n    }\n    return cnt >= 2\n}\n\n    \n\n",
  "test": "func TestIsNested(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsNested(\"[[]]\"))\n    assert.Equal(false, IsNested(\"[]]]]]]][[[[[]\"))\n    assert.Equal(false, IsNested(\"[][]\"))\n    assert.Equal(false, IsNested(\"'[]'\"))\n    assert.Equal(true, IsNested(\"[[[[]]]]\"))\n    assert.Equal(false, IsNested(\"[]]]]]]]]]]\"))\n    assert.Equal(true, IsNested(\"[][][[]]\"))\n    assert.Equal(false, IsNested(\"[[]\"))\n    assert.Equal(false, IsNested(\"[]]\"))\n    assert.Equal(true, IsNested(\"[[]][[\"))\n    assert.Equal(true, IsNested(\"[[][]]\"))\n    assert.Equal(false, IsNested(\"\"))\n    assert.Equal(false, IsNested(\"[[[[[[[[\"))\n    assert.Equal(false, IsNested(\"]]]]]]]]\"))\n}\n",
  "test_setup": "package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n)\n",
  "example_test": "func TestIsNested(t *testing.T) {\n    assert := assert.New(t)\n    assert.Equal(true, IsNested(\"[[]]\"))\n    assert.Equal(false, IsNested(\"[]]]]]]][[[[[]\"))\n    assert.Equal(false, IsNested(\"[][]\"))\n    assert.Equal(false, IsNested(\"'[]'\"))\n    assert.Equal(true, IsNested(\"[[]][[\"))\n    assert.Equal(true, IsNested(\"[[][]]\"))\n}\n"
}