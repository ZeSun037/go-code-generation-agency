# Command Output Streamer

Implement a Go program that provides a function to execute external commands and stream their output. The function should:

1. Execute a given command using `os/exec`
2. Return an `io.Reader` that streams the command's stdout
3. If the command fails, the error returned when reading from the stream should include both the command's exit error and any stderr output

## Requirements

Implement a function with the following signature:

```go
func StreamCommand(cmd *exec.Cmd) (io.Reader, error)
```

The function should:
- Start the given command
- Return an `io.Reader` that provides access to the command's stdout
- Capture all stderr output from the command
- If the command exits with an error, close the reader with an error that includes both the exit error message and the stderr content
- If the command succeeds, close the reader normally after all stdout has been consumed

## Test Cases

Your implementation should handle:

1. **Successful command**: A command that exits successfully with stdout output
   ```
   echo "hello world"
   ```

2. **Failed command with stderr**: A command that fails and writes to stderr
   ```
   sh -c "echo error message >&2; exit 1"
   ```

3. **Large stderr output**: A command that writes a large amount of data to stderr (e.g., 1MB or more) while also producing stdout
   ```
   sh -c "dd if=/dev/zero bs=1k count=1000 of=/dev/stderr 2>/dev/null; echo success"
   ```

4. **Mixed output**: A command that writes to both stdout and stderr

## Example Usage

```go
cmd := exec.Command("echo", "hello")
reader, err := StreamCommand(cmd)
if err != nil {
    log.Fatal(err)
}
output, err := io.ReadAll(reader)
if err != nil {
    log.Printf("Command failed: %v", err)
}
fmt.Println(string(output))
```

Write a complete, runnable Go program that implements this functionality and includes tests for the scenarios above.