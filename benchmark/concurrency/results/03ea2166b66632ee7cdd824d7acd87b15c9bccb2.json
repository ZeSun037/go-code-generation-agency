{
    "task": "03ea2166b66632ee7cdd824d7acd87b15c9bccb2.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Container struct {\n\tID       string\n\tName     string\n\tRunning  bool\n\tExitCode int\n}\n\ntype ContainerManager struct {\n\tmu         sync.RWMutex\n\tcontainers map[string]*Container\n\tcounter    int64\n}\n\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t\tcounter:    0,\n\t}\n}\n\nfunc (cm *ContainerManager) StartContainer(name string) string {\n\tid := fmt.Sprintf(\"container_%d\", atomic.AddInt64(&cm.counter, 1))\n\n\tcm.mu.Lock()\n\tcm.containers[id] = &Container{\n\t\tID:      id,\n\t\tName:    name,\n\t\tRunning: true,\n\t}\n\tcm.mu.Unlock()\n\n\treturn id\n}\n\nfunc (cm *ContainerManager) StopContainer(id string, exitCode int) error {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tcontainer, exists := cm.containers[id]\n\tif !exists {\n\t\treturn fmt.Errorf(\"container %s not found\", id)\n\t}\n\n\tif !container.Running {\n\t\treturn fmt.Errorf(\"container %s is not running\", id)\n\t}\n\n\tcontainer.Running = false\n\tcontainer.ExitCode = exitCode\n\n\treturn nil\n}\n\nfunc (cm *ContainerManager) ListContainers(filterExitCode *int) []Container {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tvar result []Container\n\n\tfor _, container := range cm.containers {\n\t\tif filterExitCode == nil {\n\t\t\tresult = append(result, *container)\n\t\t} else if !container.Running && container.ExitCode == *filterExitCode {\n\t\t\tresult = append(result, *container)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc main() {\n\tmanager := NewContainerManager()\n\tvar wg sync.WaitGroup\n\n\tstartTime := time.Now()\n\n\tcontainerIDs := make([]string, 10)\n\tstartMutex := sync.Mutex{}\n\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\tid := manager.StartContainer(fmt.Sprintf(\"app_%d\", index))\n\t\t\tstartMutex.Lock()\n\t\t\tcontainerIDs[index] = id\n\t\t\tstartMutex.Unlock()\n\t\t\tfmt.Printf(\"Started container: %s app_%d\\n\", id, index)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\terr := manager.StopContainer(containerIDs[index], 0)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error stopping container: %v\\n\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Printf(\"Stopped container: %s with exit code: 0\\n\", containerIDs[index])\n\t\t}(i)\n\t}\n\n\tfor i := 5; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\terr := manager.StopContainer(containerIDs[index], 1)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error stopping container: %v\\n\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Printf(\"Stopped container: %s with exit code: 1\\n\", containerIDs[index])\n\t\t}(i)\n\t}\n\n\tlistingDone := make(chan bool)\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(goroutineNum int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-listingDone:\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t\texitCodeZero := 0\n\t\t\t\t\tcontainers := manager.ListContainers(&exitCodeZero)\n\t\t\t\t\tvar ids []string\n\t\t\t\t\tfor _, c := range containers {\n\t\t\t\t\t\tids = append(ids, c.ID)\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Printf(\"Goroutine %d - Listing containers with exit code 0: %v\\n\", goroutineNum, ids)\n\n\t\t\t\t\texitCodeOne := 1\n\t\t\t\t\tcontainers = manager.ListContainers(&exitCodeOne)\n\t\t\t\t\tids = nil\n\t\t\t\t\tfor _, c := range containers {\n\t\t\t\t\t\tids = append(ids, c.ID)\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Printf(\"Goroutine %d - Listing containers with exit code 1: %v\\n\", goroutineNum, ids)\n\n\t\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\tclose(listingDone)\n\n\texitCodeZero := 0\n\tcontainersZero := manager.ListContainers(&exitCodeZero)\n\tvar idsZero []string\n\tfor _, c := range containersZero {\n\t\tidsZero = append(idsZero, c.ID)\n\t}\n\n\texitCodeOne := 1\n\tcontainersOne := manager.ListContainers(&exitCodeOne)\n\tvar idsOne []string\n\tfor _, c := range containersOne {\n\t\tidsOne = append(idsOne, c.ID)\n\t}\n\n\tallContainers := manager.ListContainers(nil)\n\n\tfmt.Println(\"\\n=== Final Results ===\")\n\tfmt.Printf(\"Total containers: %d\\n\", len(allContainers))\n\tfmt.Printf(\"Containers with exit code 0: %v\\n\", idsZero)\n\tfmt.Printf(\"Containers with exit code 1: %v\\n\", idsOne)\n\tfmt.Printf(\"Total execution time: %v\\n\", time.Since(startTime))\n\tfmt.Println(\"All operations completed successfully!\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}