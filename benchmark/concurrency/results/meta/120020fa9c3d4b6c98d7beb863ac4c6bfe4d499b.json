{
    "task": "120020fa9c3d4b6c98d7beb863ac4c6bfe4d499b.txt",
    "provider": "meta",
    "model": "meta/Llama-4-Scout-17B-16E-Instruct",
    "rounds": [
        {
            "code": "package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"math/rand\"\n    \"sync\"\n    \"time\"\n)\n\ntype Session struct {\n    leaseID string\n    mu      sync.RWMutex\n    valid   bool\n}\n\nfunc NewSession() *Session {\n    return &Session{\n        leaseID: fmt.Sprintf(\"%x\", rand.Int31()),\n        valid:   true,\n    }\n}\n\nfunc (s *Session) IsValid() bool {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    return s.valid\n}\n\nfunc (s *Session) Invalidate() {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.valid = false\n}\n\ntype Store interface {\n    Put(ctx context.Context, key string, value string, leaseID string) error\n    Get(ctx context.Context, key string) (string, error)\n    Delete(ctx context.Context, key string) error\n    Watch(ctx context.Context, prefix string) <-chan string\n    CompareAndSet(ctx context.Context, key string, oldValue string, newValue string, leaseID string) bool\n}\n\ntype inMemoryStore struct {\n    data map[string]string\n    mu   sync.RWMutex\n    ch   map[string]chan string\n}\n\nfunc newInMemoryStore() *inMemoryStore {\n    return &inMemoryStore{\n        data: make(map[string]string),\n        ch:   make(map[string]chan string),\n    }\n}\n\nfunc (s *inMemoryStore) Put(ctx context.Context, key string, value string, leaseID string) error {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.data[key] = value\n    if ch, ok := s.ch[key]; ok {\n        close(ch)\n        delete(s.ch, key)\n    }\n    return nil\n}\n\nfunc (s *inMemoryStore) Get(ctx context.Context, key string) (string, error) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    value, ok := s.data[key]\n    if !ok {\n        return \"\", fmt.Errorf(\"key not found\")\n    }\n    return value, nil\n}\n\nfunc (s *inMemoryStore) Delete(ctx context.Context, key string) error {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    delete(s.data, key)\n    return nil\n}\n\nfunc (s *inMemoryStore) Watch(ctx context.Context, prefix string) <-chan string {\n    ch := make(chan string)\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    if _, ok := s.ch[prefix]; ok {\n        close(s.ch[prefix])\n    }\n    s.ch[prefix] = ch\n    go func() {\n        <-ctx.Done()\n        close(ch)\n    }()\n    return ch\n}\n\nfunc (s *inMemoryStore) CompareAndSet(ctx context.Context, key string, oldValue string, newValue string, leaseID string) bool {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    value, ok := s.data[key]\n    if ok && value != oldValue {\n        return false\n    }\n    s.data[key] = newValue\n    return true\n}\n\ntype Election struct {\n    session *Session\n    prefix  string\n    store   *inMemoryStore\n}\n\nfunc NewElection(session *Session, prefix string) *Election {\n    return &Election{\n        session: session,\n        prefix:  prefix,\n        store:   newInMemoryStore(),\n    }\n}\n\nfunc (e *Election) Campaign(ctx context.Context, value string) error {\n    key := e.prefix + \"/leader\"\n    for {\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        default:\n            if e.store.CompareAndSet(ctx, key, \"\", value, e.session.leaseID) {\n                return nil\n            }\n            time.Sleep(50 * time.Millisecond)\n        }\n    }\n}\n\nfunc (e *Election) Resign(ctx context.Context) error {\n    key := e.prefix + \"/leader\"\n    return e.store.Delete(ctx, key)\n}\n\nfunc (e *Election) Leader(ctx context.Context) (string, error) {\n    key := e.prefix + \"/leader\"\n    value, err := e.store.Get(ctx, key)\n    if err != nil {\n        return \"\", err\n    }\n    return value, nil\n}\n\nfunc (e *Election) Observe(ctx context.Context) <-chan string {\n    return e.store.Watch(ctx, e.prefix+\"/leader\")\n}\n\nfunc main() {\n    session1 := NewSession()\n    session2 := NewSession()\n    session3 := NewSession()\n\n    election1 := NewElection(session1, \"my-election\")\n    election2 := NewElection(session2, \"my-election\")\n    election3 := NewElection(session3, \"my-election\")\n\n    ctx := context.Background()\n\n    go func() {\n        err := election1.Campaign(ctx, \"value1\")\n        if err != nil {\n            fmt.Println(err)\n        }\n    }()\n\n    time.Sleep(100 * time.Millisecond)\n\n    go func() {\n        err := election2.Campaign(ctx, \"value2\")\n        if err != nil {\n            fmt.Println(err)\n        }\n    }()\n\n    go func() {\n        err := election3.Campaign(ctx, \"value3\")\n        if err != nil {\n            fmt.Println(err)\n        }\n    }()\n\n    ch := election1.Observe(ctx)\n    for value := range ch {\n        fmt.Println(\"Leader changed to:\", value)\n    }\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_1ylub7ud/main.go:19\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    18:     return &Session{\n  > 19:         leaseID: fmt.Sprintf(\"%x\", rand.Int31()),\n    20:         valid:   true,\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 196\n  Nosec  : 0\n  Issues : \u001b[1;31m1\u001b[0m\n\n[gosec] 2025/12/02 11:12:57 Including rules: default\n[gosec] 2025/12/02 11:12:57 Excluding rules: default\n[gosec] 2025/12/02 11:12:57 Including analyzers: default\n[gosec] 2025/12/02 11:12:57 Excluding analyzers: default\n[gosec] 2025/12/02 11:12:57 Import directory: /tmp/go_synthesis_1ylub7ud\n[gosec] 2025/12/02 11:12:57 Checking package: main\n[gosec] 2025/12/02 11:12:57 Checking file: /tmp/go_synthesis_1ylub7ud/main.go"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n    \"context\"\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\ntype Session struct {\n    leaseID string\n    mu      sync.RWMutex\n    valid   bool\n}\n\nfunc NewSession() *Session {\n    leaseID := make([]byte, 16)\n    _, err := rand.Read(leaseID)\n    if err != nil {\n        panic(err)\n    }\n    return &Session{\n        leaseID: hex.EncodeToString(leaseID),\n        valid:   true,\n    }\n}\n\nfunc (s *Session) IsValid() bool {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    return s.valid\n}\n\nfunc (s *Session) Invalidate() {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.valid = false\n}\n\ntype Store interface {\n    Put(ctx context.Context, key string, value string, leaseID string) error\n    Get(ctx context.Context, key string) (string, error)\n    Delete(ctx context.Context, key string) error\n    Watch(ctx context.Context, prefix string) <-chan string\n    CompareAndSet(ctx context.Context, key string, oldValue string, newValue string, leaseID string) bool\n}\n\ntype inMemoryStore struct {\n    data map[string]string\n    mu   sync.RWMutex\n    ch   map[string]chan string\n}\n\nfunc newInMemoryStore() *inMemoryStore {\n    return &inMemoryStore{\n        data: make(map[string]string),\n        ch:   make(map[string]chan string),\n    }\n}\n\nfunc (s *inMemoryStore) Put(ctx context.Context, key string, value string, leaseID string) error {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.data[key] = value\n    if ch, ok := s.ch[key]; ok {\n        close(ch)\n        delete(s.ch, key)\n    }\n    return nil\n}\n\nfunc (s *inMemoryStore) Get(ctx context.Context, key string) (string, error) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    value, ok := s.data[key]\n    if !ok {\n        return \"\", fmt.Errorf(\"key not found\")\n    }\n    return value, nil\n}\n\nfunc (s *inMemoryStore) Delete(ctx context.Context, key string) error {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    delete(s.data, key)\n    return nil\n}\n\nfunc (s *inMemoryStore) Watch(ctx context.Context, prefix string) <-chan string {\n    ch := make(chan string)\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    if _, ok := s.ch[prefix]; ok {\n        close(s.ch[prefix])\n    }\n    s.ch[prefix] = ch\n    go func() {\n        <-ctx.Done()\n        close(ch)\n    }()\n    return ch\n}\n\nfunc (s *inMemoryStore) CompareAndSet(ctx context.Context, key string, oldValue string, newValue string, leaseID string) bool {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    value, ok := s.data[key]\n    if ok && value != oldValue {\n        return false\n    }\n    s.data[key] = newValue\n    return true\n}\n\ntype Election struct {\n    session *Session\n    prefix  string\n    store   *inMemoryStore\n}\n\nfunc NewElection(session *Session, prefix string) *Election {\n    return &Election{\n        session: session,\n        prefix:  prefix,\n        store:   newInMemoryStore(),\n    }\n}\n\nfunc (e *Election) Campaign(ctx context.Context, value string) error {\n    key := e.prefix + \"/leader\"\n    for {\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        default:\n            if e.store.CompareAndSet(ctx, key, \"\", value, e.session.leaseID) {\n                return nil\n            }\n            time.Sleep(50 * time.Millisecond)\n        }\n    }\n}\n\nfunc (e *Election) Resign(ctx context.Context) error {\n    key := e.prefix + \"/leader\"\n    return e.store.Delete(ctx, key)\n}\n\nfunc (e *Election) Leader(ctx context.Context) (string, error) {\n    key := e.prefix + \"/leader\"\n    value, err := e.store.Get(ctx, key)\n    if err != nil {\n        return \"\", err\n    }\n    return value, nil\n}\n\nfunc (e *Election) Observe(ctx context.Context) <-chan string {\n    return e.store.Watch(ctx, e.prefix+\"/leader\")\n}\n\nfunc main() {\n    session1 := NewSession()\n    session2 := NewSession()\n    session3 := NewSession()\n\n    election1 := NewElection(session1, \"my-election\")\n    election2 := NewElection(session2, \"my-election\")\n    election3 := NewElection(session3, \"my-election\")\n\n    ctx := context.Background()\n\n    go func() {\n        err := election1.Campaign(ctx, \"value1\")\n        if err != nil {\n            fmt.Println(err)\n        }\n    }()\n\n    time.Sleep(100 * time.Millisecond)\n\n    go func() {\n        err := election2.Campaign(ctx, \"value2\")\n        if err != nil {\n            fmt.Println(err)\n        }\n    }()\n\n    go func() {\n        err := election3.Campaign(ctx, \"value3\")\n        if err != nil {\n            fmt.Println(err)\n        }\n    }()\n\n    ch := election1.Observe(ctx)\n    for value := range ch {\n        fmt.Println(\"Leader changed to:\", value)\n    }\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}