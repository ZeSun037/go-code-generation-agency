{
    "task": "010a127314a935d8d038f8dd4559fc5b249813e4.txt",
    "provider": "meta",
    "model": "meta/Llama-4-Scout-17B-16E-Instruct",
    "rounds": [
        {
            "code": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// ResourceUpdate represents a resource usage update\ntype ResourceUpdate struct {\n    ResourceType string\n    ResourceID   string\n    Usage        float64\n}\n\n// ResourceMonitorConfig represents the configuration for the resource monitor\ntype ResourceMonitorConfig struct {\n    MonitoredResourceTypes []string\n}\n\n// ResourceMonitor represents the resource monitoring system\ntype ResourceMonitor struct {\n    highPriorityQueue chan ResourceUpdate\n    lowPriorityQueue  chan ResourceUpdate\n    config            ResourceMonitorConfig\n    workers           []*worker\n    mu                sync.RWMutex\n    shutdown         chan struct{}\n}\n\n// NewResourceMonitor returns a new ResourceMonitor instance\nfunc NewResourceMonitor(initialConfig ResourceMonitorConfig) *ResourceMonitor {\n    rm := &ResourceMonitor{\n        highPriorityQueue: make(chan ResourceUpdate, 100),\n        lowPriorityQueue:  make(chan ResourceUpdate, 100),\n        config:            initialConfig,\n        shutdown:         make(chan struct{}),\n    }\n    rm.startWorkers(5, rm.highPriorityQueue)\n    rm.startWorkers(5, rm.lowPriorityQueue)\n    return rm\n}\n\n// startWorkers starts the specified number of workers for the given queue\nfunc (rm *ResourceMonitor) startWorkers(numWorkers int, queue chan ResourceUpdate) {\n    for i := 0; i < numWorkers; i++ {\n        w := &worker{\n            queue:    queue,\n            shutdown: rm.shutdown,\n            config:   &rm.config,\n            mu:       &rm.mu,\n        }\n        rm.workers = append(rm.workers, w)\n        go w.run()\n    }\n}\n\n// Reconfigure updates the list of monitored resource types\nfunc (rm *ResourceMonitor) Reconfigure(newConfig ResourceMonitorConfig) {\n    rm.mu.Lock()\n    defer rm.mu.Unlock()\n    close(rm.shutdown)\n    rm.shutdown = make(chan struct{})\n    rm.config = newConfig\n    rm.startWorkers(5, rm.highPriorityQueue)\n    rm.startWorkers(5, rm.lowPriorityQueue)\n}\n\n// Shutdown cleanly stops all workers\nfunc (rm *ResourceMonitor) Shutdown() {\n    close(rm.shutdown)\n    for _, w := range rm.workers {\n        w.stop()\n    }\n}\n\n// worker represents a single worker goroutine\ntype worker struct {\n    queue    chan ResourceUpdate\n    shutdown chan struct{}\n    config   *ResourceMonitorConfig\n    mu       *sync.RWMutex\n    stopped  bool\n}\n\n// run starts the worker goroutine\nfunc (w *worker) run() {\n    for {\n        select {\n        case update, ok := <-w.queue:\n            if !ok {\n                return\n            }\n            w.mu.RLock()\n            if !w.contains(w.config.MonitoredResourceTypes, update.ResourceType) {\n                w.mu.RUnlock()\n                continue\n            }\n            w.mu.RUnlock()\n            // Process the update (e.g., record it in a shared data structure)\n            fmt.Printf(\"Processed update: %+v\\n\", update)\n        case <-w.shutdown:\n            w.stop()\n            return\n        }\n    }\n}\n\n// stop marks the worker as stopped\nfunc (w *worker) stop() {\n    w.stopped = true\n}\n\n// contains checks if a slice contains a specific string\nfunc (w *worker) contains(s []string, str string) bool {\n    for _, v := range s {\n        if v == str {\n            return true\n        }\n    }\n    return false\n}\n\nfunc main() {\n    initialConfig := ResourceMonitorConfig{\n        MonitoredResourceTypes: []string{\"CPU\", \"Memory\"},\n    }\n    rm := NewResourceMonitor(initialConfig)\n\n    // Submit some resource updates\n    go func() {\n        for i := 0; i < 10; i++ {\n            update := ResourceUpdate{\n                ResourceType: \"CPU\",\n                ResourceID:   \"cpu-1\",\n                Usage:        float64(i),\n            }\n            rm.highPriorityQueue <- update\n            time.Sleep(100 * time.Millisecond)\n        }\n    }()\n\n    go func() {\n        for i := 0; i < 10; i++ {\n            update := ResourceUpdate{\n                ResourceType: \"Memory\",\n                ResourceID:   \"mem-1\",\n                Usage:        float64(i),\n            }\n            rm.lowPriorityQueue <- update\n            time.Sleep(150 * time.Millisecond)\n        }\n    }()\n\n    // Reconfigure after 2 seconds\n    time.Sleep(2 * time.Second)\n    newConfig := ResourceMonitorConfig{\n        MonitoredResourceTypes: []string{\"CPU\", \"Disk\"},\n    }\n    rm.Reconfigure(newConfig)\n\n    // Continue submitting updates\n    go func() {\n        for i := 0; i < 10; i++ {\n            update := ResourceUpdate{\n                ResourceType: \"CPU\",\n                ResourceID:   \"cpu-1\",\n                Usage:        float64(i),\n            }\n            rm.highPriorityQueue <- update\n            time.Sleep(100 * time.Millisecond)\n        }\n    }()\n\n    // Shutdown after 5 seconds\n    time.Sleep(5 * time.Second)\n    rm.Shutdown()\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}