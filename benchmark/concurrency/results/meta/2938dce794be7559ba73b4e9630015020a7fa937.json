{
    "task": "2938dce794be7559ba73b4e9630015020a7fa937.txt",
    "provider": "meta",
    "model": "meta/Llama-4-Scout-17B-16E-Instruct",
    "rounds": [
        {
            "code": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\n// Plugin represents a plugin with a name and types it implements\ntype Plugin struct {\n    name       string\n    types      []string\n    active     bool\n    activateMu sync.Mutex\n}\n\n// PluginManager manages plugins and their handlers\ntype PluginManager struct {\n    plugins    map[string]*Plugin\n    handlers   map[string][]func(pluginName string)\n    typeMu     sync.RWMutex\n    pluginMu   sync.RWMutex\n}\n\n// NewPluginManager returns a new plugin manager\nfunc NewPluginManager() *PluginManager {\n    return &PluginManager{\n        plugins:  make(map[string]*Plugin),\n        handlers: make(map[string][]func(pluginName string)),\n    }\n}\n\n// RegisterPlugin registers a new plugin\nfunc (pm *PluginManager) RegisterPlugin(name string, implements []string) {\n    pm.pluginMu.Lock()\n    defer pm.pluginMu.Unlock()\n    if _, ok := pm.plugins[name]; ok {\n        panic(fmt.Sprintf(\"Plugin %s already registered\", name))\n    }\n    pm.plugins[name] = &Plugin{name: name, types: implements}\n}\n\n// GetPlugin gets and activates a plugin\nfunc (pm *PluginManager) GetPlugin(name, requiredType string) (*Plugin, error) {\n    pm.pluginMu.RLock()\n    plugin, ok := pm.plugins[name]\n    pm.pluginMu.RUnlock()\n    if !ok {\n        return nil, fmt.Errorf(\"plugin %s not found\", name)\n    }\n\n    plugin.activateMu.Lock()\n    defer plugin.activateMu.Unlock()\n    if !plugin.active {\n        // Simulate activation delay\n        time.Sleep(50 * time.Millisecond)\n        plugin.active = true\n        // Call handlers for the plugin's types\n        for _, t := range plugin.types {\n            pm.typeMu.RLock()\n            handlers, ok := pm.handlers[t]\n            pm.typeMu.RUnlock()\n            if ok {\n                for _, h := range handlers {\n                    h(plugin.name)\n                }\n            }\n        }\n    }\n    if !contains(plugin.types, requiredType) {\n        return nil, fmt.Errorf(\"plugin %s does not implement %s\", name, requiredType)\n    }\n    return plugin, nil\n}\n\n// GetAllPlugins gets all plugins implementing a type\nfunc (pm *PluginManager) GetAllPlugins(requiredType string) []*Plugin {\n    pm.pluginMu.RLock()\n    defer pm.pluginMu.RUnlock()\n    var plugins []*Plugin\n    for _, plugin := range pm.plugins {\n        if contains(plugin.types, requiredType) {\n            plugins = append(plugins, plugin)\n        }\n    }\n    return plugins\n}\n\n// RegisterHandler registers a callback handler for a plugin type\nfunc (pm *PluginManager) RegisterHandler(pluginType string, handler func(pluginName string)) {\n    pm.typeMu.Lock()\n    defer pm.typeMu.Unlock()\n    handlers, ok := pm.handlers[pluginType]\n    if !ok {\n        pm.handlers[pluginType] = []func(pluginName string){handler}\n    } else {\n        pm.handlers[pluginType] = append(handlers, handler)\n    }\n    // Call the handler for all already-activated plugins of the type\n    pm.pluginMu.RLock()\n    defer pm.pluginMu.RUnlock()\n    for _, plugin := range pm.plugins {\n        if contains(plugin.types, pluginType) && plugin.active {\n            handler(plugin.name)\n        }\n    }\n}\n\nfunc contains(s []string, e string) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n\nfunc main() {\n    manager := NewPluginManager()\n\n    // Register plugins\n    manager.RegisterPlugin(\"plugin1\", []string{\"storage\", \"cache\"})\n    manager.RegisterPlugin(\"plugin2\", []string{\"network\"})\n\n    // Register a handler\n    manager.RegisterHandler(\"storage\", func(name string) {\n        fmt.Printf(\"Storage plugin activated: %s\\n\", name)\n    })\n\n    // Concurrent access\n    var wg sync.WaitGroup\n    for i := 0; i < 5; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            plugin, _ := manager.GetPlugin(\"plugin1\", \"storage\")\n            fmt.Printf(\"Accessed plugin: %s\\n\", plugin.name)\n        }()\n    }\n    wg.Wait()\n\n    // Register another handler after some plugins are active\n    manager.RegisterHandler(\"storage\", func(name string) {\n        fmt.Printf(\"Another handler for: %s\\n\", name)\n    })\n\n    // Get all plugins of a type\n    plugins := manager.GetAllPlugins(\"storage\")\n    for _, plugin := range plugins {\n        fmt.Printf(\"Plugin: %s\\n\", plugin.name)\n    }\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}