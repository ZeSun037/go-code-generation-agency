{
    "task": "5cc841a337fe2a8bcfe29450a6bc4650d9e348c2.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Task represents a unit of work.\ntype Task struct {\n\tName         string\n\tRequiredSize int\n\tRequiredSkills []string\n\tRequiredLocation string\n}\n\n// Worker represents an entity that can perform tasks.\ntype Worker struct {\n\tName        string\n\tCapacity    int\n\tSkills      []string\n\tLocation    string\n\tmu          sync.RWMutex // Protects worker state changes\n\tlastUpdate  time.Time    // Timestamp of last state change, used for cache invalidation\n}\n\n// GetCapacity returns the worker's current capacity.\nfunc (w *Worker) GetCapacity() int {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.Capacity\n}\n\n// UpdateCapacity changes the worker's capacity and updates the lastUpdate timestamp.\nfunc (w *Worker) UpdateCapacity(newCapacity int) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.Capacity = newCapacity\n\tw.lastUpdate = time.Now()\n\tlog.Printf(\"Worker %s capacity updated to %d. Invalidating cache for this worker.\", w.Name, newCapacity)\n}\n\n// GetSkills returns the worker's current skills.\nfunc (w *Worker) GetSkills() []string {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\tskillsCopy := make([]string, len(w.Skills))\n\tcopy(skillsCopy, w.Skills)\n\treturn skillsCopy\n}\n\n// UpdateSkills changes the worker's skills and updates the lastUpdate timestamp.\nfunc (w *Worker) UpdateSkills(newSkills []string) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.Skills = newSkills\n\tw.lastUpdate = time.Now()\n\tlog.Printf(\"Worker %s skills updated. Invalidating cache for this worker.\", w.Name)\n}\n\n// GetLocation returns the worker's current location.\nfunc (w *Worker) GetLocation() string {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.Location\n}\n\n// GetLastUpdate returns the timestamp of the worker's last state update.\nfunc (w *Worker) GetLastUpdate() time.Time {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.lastUpdate\n}\n\n// Predicate is a function that checks if a task can be assigned to a worker.\n// It returns true if the task fits, a slice of reasons for failure, and an error if an internal issue occurs.\ntype Predicate func(task Task, worker *Worker) (bool, []string, error)\n\n// CacheEntry stores the result of a predicate evaluation.\ntype CacheEntry struct {\n\tFit        bool\n\tReasons    []string\n\tTimestamp  time.Time // Timestamp when this entry was created\n\tWorkerLastUpdate time.Time // Worker's last update time when this entry was created\n}\n\n// EquivalenceCache stores predicate evaluation results.\ntype EquivalenceCache struct {\n\tmu     sync.RWMutex\n\tstore  map[string]map[string]map[string]CacheEntry // taskName -> workerName -> predicateName -> CacheEntry\n\tworkers map[string]*Worker // Reference to workers to check their lastUpdate time\n}\n\n// NewEquivalenceCache creates a new thread-safe cache.\nfunc NewEquivalenceCache(workers []*Worker) *EquivalenceCache {\n\tworkerMap := make(map[string]*Worker)\n\tfor _, w := range workers {\n\t\tworkerMap[w.Name] = w\n\t}\n\treturn &EquivalenceCache{\n\t\tstore:  make(map[string]map[string]map[string]CacheEntry),\n\t\tworkers: workerMap,\n\t}\n}\n\n// GetCachedResult retrieves a result from the cache.\n// It returns (fit, reasons, true) if a valid cached result is found,\n// otherwise (false, nil, false).\nfunc (c *EquivalenceCache) GetCachedResult(taskName, workerName, predicateName string) (fit bool, reasons []string, valid bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tif _, ok := c.store[taskName]; !ok {\n\t\treturn false, nil, false\n\t}\n\tif _, ok := c.store[taskName][workerName]; !ok {\n\t\treturn false, nil, false\n\t}\n\tif entry, ok := c.store[taskName][workerName][predicateName]; ok {\n\t\t// Check if the cached entry is still valid against the worker's last update time\n\t\tif worker, found := c.workers[workerName]; found {\n\t\t\tif worker.GetLastUpdate().After(entry.WorkerLastUpdate) {\n\t\t\t\tlog.Printf(\"Cache invalid: Worker %s state changed since cached entry for task %s, predicate %s.\", workerName, taskName, predicateName)\n\t\t\t\treturn false, nil, false // Worker state changed, cache is invalid\n\t\t\t}\n\t\t}\n\t\t// log.Printf(\"Cache hit for Task: %s, Worker: %s, Predicate: %s\", taskName, workerName, predicateName)\n\t\treturn entry.Fit, entry.Reasons, true\n\t}\n\treturn false, nil, false\n}\n\n// UpdateCache stores a new result in the cache.\nfunc (c *EquivalenceCache) UpdateCache(taskName, workerName, predicateName string, fit bool, reasons []string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif _, ok := c.store[taskName]; !ok {\n\t\tc.store[taskName] = make(map[string]map[string]CacheEntry)\n\t}\n\tif _, ok := c.store[taskName][workerName]; !ok {\n\t\tc.store[taskName][workerName] = make(map[string]CacheEntry)\n\t}\n\n\tworkerLastUpdate := time.Time{}\n\tif worker, found := c.workers[workerName]; found {\n\t\tworkerLastUpdate = worker.GetLastUpdate()\n\t}\n\n\tc.store[taskName][workerName][predicateName] = CacheEntry{\n\t\tFit:        fit,\n\t\tReasons:    reasons,\n\t\tTimestamp:  time.Now(),\n\t\tWorkerLastUpdate: workerLastUpdate,\n\t}\n\t// log.Printf(\"Cache updated for Task: %s, Worker: %s, Predicate: %s. Fit: %t\", taskName, workerName, predicateName, fit)\n}\n\n// InvalidateWorkerCache removes all cache entries for a specific worker.\nfunc (c *EquivalenceCache) InvalidateWorkerCache(workerName string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tfor taskName := range c.store {\n\t\tif _, ok := c.store[taskName][workerName]; ok {\n\t\t\tdelete(c.store[taskName], workerName)\n\t\t\t// If no more worker entries for this task, clean up task entry\n\t\t\tif len(c.store[taskName]) == 0 {\n\t\t\t\tdelete(c.store, taskName)\n\t\t\t}\n\t\t}\n\t}\n\tlog.Printf(\"Cache fully invalidated for worker %s due to external event.\", workerName)\n}\n\n// Predicate Functions\n\n// HasSufficientCapacity checks if the worker has enough capacity for the task.\nfunc HasSufficientCapacity(task Task, worker *Worker) (bool, []string, error) {\n\tworkerCapacity := worker.GetCapacity()\n\tif workerCapacity >= task.RequiredSize {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker capacity %d is less than task required size %d\", workerCapacity, task.RequiredSize)}, nil\n}\n\n// HasRequiredSkills checks if the worker has all required skills for the task.\nfunc HasRequiredSkills(task Task, worker *Worker) (bool, []string, error) {\n\tworkerSkills := worker.GetSkills()\n\tworkerHasSkill := make(map[string]bool)\n\tfor _, skill := range workerSkills {\n\t\tworkerHasSkill[skill] = true\n\t}\n\n\tvar missingSkills []string\n\tfor _, skill := range task.RequiredSkills {\n\t\tif !workerHasSkill[skill] {\n\t\t\tmissingSkills = append(missingSkills, skill)\n\t\t}\n\t}\n\n\tif len(missingSkills) == 0 {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker missing skills: %v\", missingSkills)}, nil\n}\n\n// IsInCorrectLocation checks if the worker is in the correct location for the task.\nfunc IsInCorrectLocation(task Task, worker *Worker) (bool, []string, error) {\n\tworkerLocation := worker.GetLocation()\n\tif task.RequiredLocation == \"\" || workerLocation == task.RequiredLocation {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker location '%s' does not match task required location '%s'\", workerLocation, task.RequiredLocation)}, nil\n}\n\n// PredicateRegistry holds all predicates to be evaluated.\ntype PredicateRegistry struct {\n\tPredicates map[string]Predicate\n\tOrder      []string\n}\n\n// NewPredicateRegistry creates a new registry with predefined predicates.\nfunc NewPredicateRegistry() *PredicateRegistry {\n\tregistry := &PredicateRegistry{\n\t\tPredicates: make(map[string]Predicate),\n\t\tOrder:      []string{},\n\t}\n\tregistry.AddPredicate(\"HasSufficientCapacity\", HasSufficientCapacity)\n\tregistry.AddPredicate(\"HasRequiredSkills\", HasRequiredSkills)\n\tregistry.AddPredicate(\"IsInCorrectLocation\", IsInCorrectLocation)\n\treturn registry\n}\n\n// AddPredicate adds a new predicate to the registry.\nfunc (pr *PredicateRegistry) AddPredicate(name string, p Predicate) {\n\tpr.Predicates[name] = p\n\tpr.Order = append(pr.Order, name)\n}\n\n// Scheduler evaluates tasks against workers.\ntype Scheduler struct {\n\tCache         *EquivalenceCache\n\tPredicateReg  *PredicateRegistry\n\tworkerMap     map[string]*Worker\n}\n\n// NewScheduler creates a new scheduler instance.\nfunc NewScheduler(cache *EquivalenceCache, workers []*Worker) *Scheduler {\n\tworkerMap := make(map[string]*Worker)\n\tfor _, w := range workers {\n\t\tworkerMap[w.Name] = w\n\t}\n\treturn &Scheduler{\n\t\tCache:        cache,\n\t\tPredicateReg: NewPredicateRegistry(),\n\t\tworkerMap:    workerMap,\n\t}\n}\n\n// ScheduleTask evaluates if a task can be assigned to a worker using predicates and cache.\nfunc (s *Scheduler) ScheduleTask(task Task, workerName string) (fit bool, reasons []string) {\n\tworker, ok := s.workerMap[workerName]\n\tif !ok {\n\t\treturn false, []string{fmt.Sprintf(\"worker %s not found\", workerName)}\n\t}\n\n\tallFit := true\n\tvar allReasons []string\n\n\tfor _, predName := range s.PredicateReg.Order {\n\t\tpredFunc := s.PredicateReg.Predicates[predName]\n\n\t\t// Try to get from cache\n\t\tcachedFit, cachedReasons, validCache := s.Cache.GetCachedResult(task.Name, worker.Name, predName)\n\n\t\tif validCache {\n\t\t\tfit = cachedFit\n\t\t\treasons = cachedReasons\n\t\t} else {\n\t\t\t// Cache miss or invalid, execute predicate\n\t\t\tvar err error\n\t\t\tfit, reasons, err = predFunc(task, worker)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error evaluating predicate %s for task %s, worker %s: %v\", predName, task.Name, worker.Name, err)\n\t\t\t\tallFit = false\n\t\t\t\tallReasons = append(allReasons, fmt.Sprintf(\"internal error for predicate %s: %v\", predName, err))\n\t\t\t\tbreak // Stop evaluating if there's an internal error\n\t\t\t}\n\t\t\t// Update cache with new result\n\t\t\ts.Cache.UpdateCache(task.Name, worker.Name, predName, fit, reasons)\n\t\t}\n\n\t\tif !fit {\n\t\t\tallFit = false\n\t\t\tallReasons = append(allReasons, reasons...)\n\t\t\tbreak // Stop at the first predicate that fails\n\t\t}\n\t}\n\n\treturn allFit, allReasons\n}\n\nfunc main() {\n\tlog.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)\n\trand.Seed(time.Now().UnixNano())\n\n\t// 1. Create Workers\n\tworkers := []*Worker{\n\t\t{Name: \"Alice\", Capacity: 10, Skills: []string{\"coding\", \"testing\"}, Location: \"NY\"},\n\t\t{Name: \"Bob\", Capacity: 5, Skills: []string{\"testing\", \"design\"}, Location: \"LA\"},\n\t\t{Name: \"Charlie\", Capacity: 15, Skills: []string{\"coding\", \"devops\"}, Location: \"NY\"},\n\t\t{Name: \"David\", Capacity: 8, Skills: []string{\"design\", \"management\"}, Location: \"SF\"},\n\t\t{Name: \"Eve\", Capacity: 12, Skills: []string{\"coding\", \"testing\", \"devops\"}, Location: \"LA\"},\n\t}\n\n\t// 2. Create Tasks\n\ttasks := []Task{\n\t\t{Name: \"TaskA\", RequiredSize: 3, RequiredSkills: []string{\"coding\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskB\", RequiredSize: 7, RequiredSkills: []string{\"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskC\", RequiredSize: 10, RequiredSkills: []string{\"devops\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskD\", RequiredSize: 2, RequiredSkills: []string{\"design\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"TaskE\", RequiredSize: 6, RequiredSkills: []string{\"coding\", \"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskF\", RequiredSize: 11, RequiredSkills: []string{\"management\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskG\", RequiredSize: 4, RequiredSkills: []string{\"coding\", \"devops\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"TaskH\", RequiredSize: 9, RequiredSkills: []string{\"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskI\", RequiredSize: 1, RequiredSkills: []string{\"design\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskJ\", RequiredSize: 13, RequiredSkills: []string{\"coding\"}, RequiredLocation: \"LA\"},\n\t}\n\n\t// Initialize Cache and Scheduler\n\tcache := NewEquivalenceCache(workers)\n\tscheduler := NewScheduler(cache, workers)\n\n\tvar wg sync.WaitGroup\n\tassignedTasks := make(chan string, len(tasks)*len(workers))\n\tschedulingResults := make(chan struct {\n\t\tTask   Task\n\t\tWorker string\n\t\tFit    bool\n\t\tReason []string\n\t}, len(tasks)*len(workers))\n\n\t// Simulate background worker state changes and cache invalidation\n\tstopInvalidation := make(chan struct{})\n\tgo func() {\n\t\tticker := time.NewTicker(2 * time.Second) // Invalidate every 2 seconds\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tworkerToUpdate := workers[rand.Intn(len(workers))]\n\t\t\t\taction := rand.Intn(2) // 0 for capacity, 1 for skills\n\t\t\t\tif action == 0 {\n\t\t\t\t\tnewCapacity := rand.Intn(10) + 5 // Capacity between 5 and 14\n\t\t\t\t\tworkerToUpdate.UpdateCapacity(newCapacity)\n\t\t\t\t} else {\n\t\t\t\t\t// Add a random skill or remove one\n\t\t\t\t\tallSkills := []string{\"coding\", \"testing\", \"design\", \"devops\", \"management\", \"documentation\"}\n\t\t\t\t\tnumSkills := rand.Intn(3) + 1 // 1 to 3 skills\n\t\t\t\t\tnewSkills := make([]string, numSkills)\n\t\t\t\t\tseen := make(map[string]bool)\n\t\t\t\t\tfor i := 0; i < numSkills; i++ {\n\t\t\t\t\t\tskill := allSkills[rand.Intn(len(allSkills))]\n\t\t\t\t\t\tif !seen[skill] {\n\t\t\t\t\t\t\tnewSkills[i] = skill\n\t\t\t\t\t\t\tseen[skill] = true\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ti-- // Try again if skill already added\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tworkerToUpdate.UpdateSkills(newSkills)\n\t\t\t\t}\n\t\t\t\t// Invalidate cache for this worker after its state changes\n\t\t\t\tcache.InvalidateWorkerCache(workerToUpdate.Name)\n\n\t\t\tcase <-stopInvalidation:\n\t\t\t\tlog.Println(\"Stopping worker state change simulation.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfmt.Println(\"Starting concurrent task scheduling...\")\n\trunDuration := 10 * time.Second\n\tstartTime := time.Now()\n\toperationCounter := 0\n\n\tfor time.Since(startTime) < runDuration {\n\t\t// Launch goroutines for concurrent scheduling decisions\n\t\tnumConcurrentChecks := 5 // Number of task-worker pairs to check concurrently\n\t\tcurrentChecks := 0\n\t\tfor currentChecks < numConcurrentChecks && time.Since(startTime) < runDuration {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\ttask := tasks[rand.Intn(len(tasks))]\n\t\t\t\tworker := workers[rand.Intn(len(workers))]\n\n\t\t\t\tfit, reasons := scheduler.ScheduleTask(task, worker.Name)\n\t\t\t\tschedulingResults <- struct {\n\t\t\t\t\tTask   Task\n\t\t\t\t\tWorker string\n\t\t\t\t\tFit    bool\n\t\t\t\t\tReason []string\n\t\t\t\t}{task, worker.Name, fit, reasons}\n\t\t\t}()\n\t\t\tcurrentChecks++\n\t\t\toperationCounter++\n\t\t\ttime.Sleep(time.Duration(rand.Intn(50)+10) * time.Millisecond) // Simulate varied request arrival\n\t\t}\n\t\ttime.Sleep(50 * time.Millisecond) // Small delay before next batch of checks\n\t}\n\n\tfmt.Println(\"Finished launching scheduling tasks. Waiting for goroutines to complete...\")\n\twg.Wait()\n\tclose(schedulingResults)\n\tclose(assignedTasks)\n\tclose(stopInvalidation) // Signal to stop background invalidation goroutine\n\n\tfmt.Printf(\"\\nTotal scheduling operations performed: %d\\n\", operationCounter)\n\tfmt.Println(\"\\n--- Scheduling Results Summary ---\")\n\tfinalAssigned := make(map[string]string)\n\tfor res := range schedulingResults {\n\t\tif res.Fit {\n\t\t\tif _, ok := finalAssigned[res.Task.Name]; !ok { // Assign only if not already assigned\n\t\t\t\tfinalAssigned[res.Task.Name] = res.Worker\n\t\t\t\tfmt.Printf(\"\u2705 Task %s assigned to Worker %s.\\n\", res.Task.Name, res.Worker)\n\t\t\t}\n\t\t} else {\n\t\t\t// fmt.Printf(\"\u274c Task %s cannot be assigned to Worker %s. Reasons: %v\\n\", res.Task.Name, res.Worker, res.Reason)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\nFinal Task Assignments:\")\n\tif len(finalAssigned) == 0 {\n\t\tfmt.Println(\"No tasks were assigned.\")\n\t} else {\n\t\tfor taskName, workerName := range finalAssigned {\n\t\t\tfmt.Printf(\"- %s -> %s\\n\", taskName, workerName)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\nProgram finished.\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:412\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    411: \t\t\toperationCounter++\n  > 412: \t\t\ttime.Sleep(time.Duration(rand.Intn(50)+10) * time.Millisecond) // Simulate varied request arrival\n    413: \t\t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:400\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    399: \t\t\t\ttask := tasks[rand.Intn(len(tasks))]\n  > 400: \t\t\t\tworker := workers[rand.Intn(len(workers))]\n    401: \n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:399\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    398: \t\t\t\tdefer wg.Done()\n  > 399: \t\t\t\ttask := tasks[rand.Intn(len(tasks))]\n    400: \t\t\t\tworker := workers[rand.Intn(len(workers))]\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:366\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    365: \t\t\t\t\tfor i := 0; i < numSkills; i++ {\n  > 366: \t\t\t\t\t\tskill := allSkills[rand.Intn(len(allSkills))]\n    367: \t\t\t\t\t\tif !seen[skill] {\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:362\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    361: \t\t\t\t\tallSkills := []string{\"coding\", \"testing\", \"design\", \"devops\", \"management\", \"documentation\"}\n  > 362: \t\t\t\t\tnumSkills := rand.Intn(3) + 1 // 1 to 3 skills\n    363: \t\t\t\t\tnewSkills := make([]string, numSkills)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:357\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    356: \t\t\t\tif action == 0 {\n  > 357: \t\t\t\t\tnewCapacity := rand.Intn(10) + 5 // Capacity between 5 and 14\n    358: \t\t\t\t\tworkerToUpdate.UpdateCapacity(newCapacity)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:355\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    354: \t\t\t\tworkerToUpdate := workers[rand.Intn(len(workers))]\n  > 355: \t\t\t\taction := rand.Intn(2) // 0 for capacity, 1 for skills\n    356: \t\t\t\tif action == 0 {\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:354\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    353: \t\t\tcase <-ticker.C:\n  > 354: \t\t\t\tworkerToUpdate := workers[rand.Intn(len(workers))]\n    355: \t\t\t\taction := rand.Intn(2) // 0 for capacity, 1 for skills\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 447\n  Nosec  : 0\n  Issues : \u001b[1;31m8\u001b[0m\n\n[gosec] 2025/12/01 13:01:10 Including rules: default\n[gosec] 2025/12/01 13:01:10 Excluding rules: default\n[gosec] 2025/12/01 13:01:10 Including analyzers: default\n[gosec] 2025/12/01 13:01:10 Excluding analyzers: default\n[gosec] 2025/12/01 13:01:10 Import directory: /tmp/go_synthesis_w3yy10nh\n[gosec] 2025/12/01 13:01:10 Checking package: main\n[gosec] 2025/12/01 13:01:10 Checking file: /tmp/go_synthesis_w3yy10nh/main.go"
                },
                {
                    "verifier": "staticcheck",
                    "error": "main.go:308:2: rand.Seed has been deprecated since Go 1.20 and an alternative has been available since Go 1.0: As of Go 1.20 there is no reason to call Seed with a random value. Programs that call Seed with a known value to get a specific sequence of results should use New(NewSource(seed)) to obtain a local random generator. (SA1019)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Task represents a unit of work.\ntype Task struct {\n\tName             string\n\tRequiredSize     int\n\tRequiredSkills   []string\n\tRequiredLocation string\n}\n\n// Worker represents an entity that can perform tasks.\ntype Worker struct {\n\tName       string\n\tCapacity   int\n\tSkills     []string\n\tLocation   string\n\tmu         sync.RWMutex // Protects worker state changes\n\tlastUpdate time.Time    // Timestamp of last state change, used for cache invalidation\n}\n\n// GetCapacity returns the worker's current capacity.\nfunc (w *Worker) GetCapacity() int {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.Capacity\n}\n\n// UpdateCapacity changes the worker's capacity and updates the lastUpdate timestamp.\nfunc (w *Worker) UpdateCapacity(newCapacity int) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.Capacity = newCapacity\n\tw.lastUpdate = time.Now()\n\tlog.Printf(\"Worker %s capacity updated to %d. Invalidating cache for this worker.\", w.Name, newCapacity)\n}\n\n// GetSkills returns the worker's current skills.\nfunc (w *Worker) GetSkills() []string {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\tskillsCopy := make([]string, len(w.Skills))\n\tcopy(skillsCopy, w.Skills)\n\treturn skillsCopy\n}\n\n// UpdateSkills changes the worker's skills and updates the lastUpdate timestamp.\nfunc (w *Worker) UpdateSkills(newSkills []string) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.Skills = newSkills\n\tw.lastUpdate = time.Now()\n\tlog.Printf(\"Worker %s skills updated. Invalidating cache for this worker.\", w.Name)\n}\n\n// GetLocation returns the worker's current location.\nfunc (w *Worker) GetLocation() string {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.Location\n}\n\n// GetLastUpdate returns the timestamp of the worker's last state update.\nfunc (w *Worker) GetLastUpdate() time.Time {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.lastUpdate\n}\n\n// Predicate is a function that checks if a task can be assigned to a worker.\n// It returns true if the task fits, a slice of reasons for failure, and an error if an internal issue occurs.\ntype Predicate func(task Task, worker *Worker) (bool, []string, error)\n\n// CacheEntry stores the result of a predicate evaluation.\ntype CacheEntry struct {\n\tFit              bool\n\tReasons          []string\n\tTimestamp        time.Time // Timestamp when this entry was created\n\tWorkerLastUpdate time.Time // Worker's last update time when this entry was created\n}\n\n// EquivalenceCache stores predicate evaluation results.\ntype EquivalenceCache struct {\n\tmu      sync.RWMutex\n\tstore   map[string]map[string]map[string]CacheEntry // taskName -> workerName -> predicateName -> CacheEntry\n\tworkers map[string]*Worker                          // Reference to workers to check their lastUpdate time\n}\n\n// NewEquivalenceCache creates a new thread-safe cache.\nfunc NewEquivalenceCache(workers []*Worker) *EquivalenceCache {\n\tworkerMap := make(map[string]*Worker)\n\tfor _, w := range workers {\n\t\tworkerMap[w.Name] = w\n\t}\n\treturn &EquivalenceCache{\n\t\tstore:   make(map[string]map[string]map[string]CacheEntry),\n\t\tworkers: workerMap,\n\t}\n}\n\n// GetCachedResult retrieves a result from the cache.\n// It returns (fit, reasons, true) if a valid cached result is found,\n// otherwise (false, nil, false).\nfunc (c *EquivalenceCache) GetCachedResult(taskName, workerName, predicateName string) (fit bool, reasons []string, valid bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tif _, ok := c.store[taskName]; !ok {\n\t\treturn false, nil, false\n\t}\n\tif _, ok := c.store[taskName][workerName]; !ok {\n\t\treturn false, nil, false\n\t}\n\tif entry, ok := c.store[taskName][workerName][predicateName]; ok {\n\t\t// Check if the cached entry is still valid against the worker's last update time\n\t\tif worker, found := c.workers[workerName]; found {\n\t\t\tif worker.GetLastUpdate().After(entry.WorkerLastUpdate) {\n\t\t\t\tlog.Printf(\"Cache invalid: Worker %s state changed since cached entry for task %s, predicate %s.\", workerName, taskName, predicateName)\n\t\t\t\treturn false, nil, false // Worker state changed, cache is invalid\n\t\t\t}\n\t\t}\n\t\t// log.Printf(\"Cache hit for Task: %s, Worker: %s, Predicate: %s\", taskName, workerName, predicateName)\n\t\treturn entry.Fit, entry.Reasons, true\n\t}\n\treturn false, nil, false\n}\n\n// UpdateCache stores a new result in the cache.\nfunc (c *EquivalenceCache) UpdateCache(taskName, workerName, predicateName string, fit bool, reasons []string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif _, ok := c.store[taskName]; !ok {\n\t\tc.store[taskName] = make(map[string]map[string]CacheEntry)\n\t}\n\tif _, ok := c.store[taskName][workerName]; !ok {\n\t\tc.store[taskName][workerName] = make(map[string]CacheEntry)\n\t}\n\n\tworkerLastUpdate := time.Time{}\n\tif worker, found := c.workers[workerName]; found {\n\t\tworkerLastUpdate = worker.GetLastUpdate()\n\t}\n\n\tc.store[taskName][workerName][predicateName] = CacheEntry{\n\t\tFit:              fit,\n\t\tReasons:          reasons,\n\t\tTimestamp:        time.Now(),\n\t\tWorkerLastUpdate: workerLastUpdate,\n\t}\n\t// log.Printf(\"Cache updated for Task: %s, Worker: %s, Predicate: %s. Fit: %t\", taskName, workerName, predicateName, fit)\n}\n\n// InvalidateWorkerCache removes all cache entries for a specific worker.\nfunc (c *EquivalenceCache) InvalidateWorkerCache(workerName string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tfor taskName := range c.store {\n\t\tif _, ok := c.store[taskName][workerName]; ok {\n\t\t\tdelete(c.store[taskName], workerName)\n\t\t\t// If no more worker entries for this task, clean up task entry\n\t\t\tif len(c.store[taskName]) == 0 {\n\t\t\t\tdelete(c.store, taskName)\n\t\t\t}\n\t\t}\n\t}\n\tlog.Printf(\"Cache fully invalidated for worker %s due to external event.\", workerName)\n}\n\n// Predicate Functions\n\n// HasSufficientCapacity checks if the worker has enough capacity for the task.\nfunc HasSufficientCapacity(task Task, worker *Worker) (bool, []string, error) {\n\tworkerCapacity := worker.GetCapacity()\n\tif workerCapacity >= task.RequiredSize {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker capacity %d is less than task required size %d\", workerCapacity, task.RequiredSize)}, nil\n}\n\n// HasRequiredSkills checks if the worker has all required skills for the task.\nfunc HasRequiredSkills(task Task, worker *Worker) (bool, []string, error) {\n\tworkerSkills := worker.GetSkills()\n\tworkerHasSkill := make(map[string]bool)\n\tfor _, skill := range workerSkills {\n\t\tworkerHasSkill[skill] = true\n\t}\n\n\tvar missingSkills []string\n\tfor _, skill := range task.RequiredSkills {\n\t\tif !workerHasSkill[skill] {\n\t\t\tmissingSkills = append(missingSkills, skill)\n\t\t}\n\t}\n\n\tif len(missingSkills) == 0 {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker missing skills: %v\", missingSkills)}, nil\n}\n\n// IsInCorrectLocation checks if the worker is in the correct location for the task.\nfunc IsInCorrectLocation(task Task, worker *Worker) (bool, []string, error) {\n\tworkerLocation := worker.GetLocation()\n\tif task.RequiredLocation == \"\" || workerLocation == task.RequiredLocation {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker location '%s' does not match task required location '%s'\", workerLocation, task.RequiredLocation)}, nil\n}\n\n// PredicateRegistry holds all predicates to be evaluated.\ntype PredicateRegistry struct {\n\tPredicates map[string]Predicate\n\tOrder      []string\n}\n\n// NewPredicateRegistry creates a new registry with predefined predicates.\nfunc NewPredicateRegistry() *PredicateRegistry {\n\tregistry := &PredicateRegistry{\n\t\tPredicates: make(map[string]Predicate),\n\t\tOrder:      []string{},\n\t}\n\tregistry.AddPredicate(\"HasSufficientCapacity\", HasSufficientCapacity)\n\tregistry.AddPredicate(\"HasRequiredSkills\", HasRequiredSkills)\n\tregistry.AddPredicate(\"IsInCorrectLocation\", IsInCorrectLocation)\n\treturn registry\n}\n\n// AddPredicate adds a new predicate to the registry.\nfunc (pr *PredicateRegistry) AddPredicate(name string, p Predicate) {\n\tpr.Predicates[name] = p\n\tpr.Order = append(pr.Order, name)\n}\n\n// Scheduler evaluates tasks against workers.\ntype Scheduler struct {\n\tCache        *EquivalenceCache\n\tPredicateReg *PredicateRegistry\n\tworkerMap    map[string]*Worker\n}\n\n// NewScheduler creates a new scheduler instance.\nfunc NewScheduler(cache *EquivalenceCache, workers []*Worker) *Scheduler {\n\tworkerMap := make(map[string]*Worker)\n\tfor _, w := range workers {\n\t\tworkerMap[w.Name] = w\n\t}\n\treturn &Scheduler{\n\t\tCache:        cache,\n\t\tPredicateReg: NewPredicateRegistry(),\n\t\tworkerMap:    workerMap,\n\t}\n}\n\n// ScheduleTask evaluates if a task can be assigned to a worker using predicates and cache.\nfunc (s *Scheduler) ScheduleTask(task Task, workerName string) (fit bool, reasons []string) {\n\tworker, ok := s.workerMap[workerName]\n\tif !ok {\n\t\treturn false, []string{fmt.Sprintf(\"worker %s not found\", workerName)}\n\t}\n\n\tallFit := true\n\tvar allReasons []string\n\n\tfor _, predName := range s.PredicateReg.Order {\n\t\tpredFunc := s.PredicateReg.Predicates[predName]\n\n\t\t// Try to get from cache\n\t\tcachedFit, cachedReasons, validCache := s.Cache.GetCachedResult(task.Name, worker.Name, predName)\n\n\t\tif validCache {\n\t\t\tfit = cachedFit\n\t\t\treasons = cachedReasons\n\t\t} else {\n\t\t\t// Cache miss or invalid, execute predicate\n\t\t\tvar err error\n\t\t\tfit, reasons, err = predFunc(task, worker)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error evaluating predicate %s for task %s, worker %s: %v\", predName, task.Name, worker.Name, err)\n\t\t\t\tallFit = false\n\t\t\t\tallReasons = append(allReasons, fmt.Sprintf(\"internal error for predicate %s: %v\", predName, err))\n\t\t\t\tbreak // Stop evaluating if there's an internal error\n\t\t\t}\n\t\t\t// Update cache with new result\n\t\t\ts.Cache.UpdateCache(task.Name, worker.Name, predName, fit, reasons)\n\t\t}\n\n\t\tif !fit {\n\t\t\tallFit = false\n\t\t\tallReasons = append(allReasons, reasons...)\n\t\t\tbreak // Stop at the first predicate that fails\n\t\t}\n\t}\n\n\treturn allFit, allReasons\n}\n\nfunc main() {\n\tlog.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)\n\t// Use a new rand.Rand instance for thread-safe and modern random number generation\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\t// 1. Create Workers\n\tworkers := []*Worker{\n\t\t{Name: \"Alice\", Capacity: 10, Skills: []string{\"coding\", \"testing\"}, Location: \"NY\"},\n\t\t{Name: \"Bob\", Capacity: 5, Skills: []string{\"testing\", \"design\"}, Location: \"LA\"},\n\t\t{Name: \"Charlie\", Capacity: 15, Skills: []string{\"coding\", \"devops\"}, Location: \"NY\"},\n\t\t{Name: \"David\", Capacity: 8, Skills: []string{\"design\", \"management\"}, Location: \"SF\"},\n\t\t{Name: \"Eve\", Capacity: 12, Skills: []string{\"coding\", \"testing\", \"devops\"}, Location: \"LA\"},\n\t}\n\n\t// 2. Create Tasks\n\ttasks := []Task{\n\t\t{Name: \"TaskA\", RequiredSize: 3, RequiredSkills: []string{\"coding\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskB\", RequiredSize: 7, RequiredSkills: []string{\"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskC\", RequiredSize: 10, RequiredSkills: []string{\"devops\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskD\", RequiredSize: 2, RequiredSkills: []string{\"design\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"TaskE\", RequiredSize: 6, RequiredSkills: []string{\"coding\", \"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskF\", RequiredSize: 11, RequiredSkills: []string{\"management\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskG\", RequiredSize: 4, RequiredSkills: []string{\"coding\", \"devops\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"TaskH\", RequiredSize: 9, RequiredSkills: []string{\"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskI\", RequiredSize: 1, RequiredSkills: []string{\"design\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskJ\", RequiredSize: 13, RequiredSkills: []string{\"coding\"}, RequiredLocation: \"LA\"},\n\t}\n\n\t// Initialize Cache and Scheduler\n\tcache := NewEquivalenceCache(workers)\n\tscheduler := NewScheduler(cache, workers)\n\n\tvar wg sync.WaitGroup\n\tassignedTasks := make(chan string, len(tasks)*len(workers))\n\tschedulingResults := make(chan struct {\n\t\tTask   Task\n\t\tWorker string\n\t\tFit    bool\n\t\tReason []string\n\t}, len(tasks)*len(workers))\n\n\t// Simulate background worker state changes and cache invalidation\n\tstopInvalidation := make(chan struct{})\n\tgo func() {\n\t\tticker := time.NewTicker(2 * time.Second) // Invalidate every 2 seconds\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tworkerToUpdate := workers[r.Intn(len(workers))]\n\t\t\t\taction := r.Intn(2) // 0 for capacity, 1 for skills\n\t\t\t\tif action == 0 {\n\t\t\t\t\tnewCapacity := r.Intn(10) + 5 // Capacity between 5 and 14\n\t\t\t\t\tworkerToUpdate.UpdateCapacity(newCapacity)\n\t\t\t\t} else {\n\t\t\t\t\t// Add a random skill or remove one\n\t\t\t\t\tallSkills := []string{\"coding\", \"testing\", \"design\", \"devops\", \"management\", \"documentation\"}\n\t\t\t\t\tnumSkills := r.Intn(3) + 1 // 1 to 3 skills\n\t\t\t\t\tnewSkills := make([]string, numSkills)\n\t\t\t\t\tseen := make(map[string]bool)\n\t\t\t\t\tfor i := 0; i < numSkills; i++ {\n\t\t\t\t\t\tskill := allSkills[r.Intn(len(allSkills))]\n\t\t\t\t\t\tif !seen[skill] {\n\t\t\t\t\t\t\tnewSkills[i] = skill\n\t\t\t\t\t\t\tseen[skill] = true\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ti-- // Try again if skill already added\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tworkerToUpdate.UpdateSkills(newSkills)\n\t\t\t\t}\n\t\t\t\t// Invalidate cache for this worker after its state changes\n\t\t\t\tcache.InvalidateWorkerCache(workerToUpdate.Name)\n\n\t\t\tcase <-stopInvalidation:\n\t\t\t\tlog.Println(\"Stopping worker state change simulation.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfmt.Println(\"Starting concurrent task scheduling...\")\n\trunDuration := 10 * time.Second\n\tstartTime := time.Now()\n\toperationCounter := 0\n\n\tfor time.Since(startTime) < runDuration {\n\t\t// Launch goroutines for concurrent scheduling decisions\n\t\tnumConcurrentChecks := 5 // Number of task-worker pairs to check concurrently\n\t\tcurrentChecks := 0\n\t\tfor currentChecks < numConcurrentChecks && time.Since(startTime) < runDuration {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\ttask := tasks[r.Intn(len(tasks))]\n\t\t\t\tworker := workers[r.Intn(len(workers))]\n\n\t\t\t\tfit, reasons := scheduler.ScheduleTask(task, worker.Name)\n\t\t\t\tschedulingResults <- struct {\n\t\t\t\t\tTask   Task\n\t\t\t\t\tWorker string\n\t\t\t\t\tFit    bool\n\t\t\t\t\tReason []string\n\t\t\t\t}{task, worker.Name, fit, reasons}\n\t\t\t}()\n\t\t\tcurrentChecks++\n\t\t\toperationCounter++\n\t\t\ttime.Sleep(time.Duration(r.Intn(50)+10) * time.Millisecond) // Simulate varied request arrival\n\t\t}\n\t\ttime.Sleep(50 * time.Millisecond) // Small delay before next batch of checks\n\t}\n\n\tfmt.Println(\"Finished launching scheduling tasks. Waiting for goroutines to complete...\")\n\twg.Wait()\n\tclose(schedulingResults)\n\tclose(assignedTasks) // This channel is not being written to currently, but good practice to close\n\tclose(stopInvalidation) // Signal to stop background invalidation goroutine\n\n\tfmt.Printf(\"\\nTotal scheduling operations performed: %d\\n\", operationCounter)\n\tfmt.Println(\"\\n--- Scheduling Results Summary ---\")\n\tfinalAssigned := make(map[string]string)\n\tfor res := range schedulingResults {\n\t\tif res.Fit {\n\t\t\tif _, ok := finalAssigned[res.Task.Name]; !ok { // Assign only if not already assigned\n\t\t\t\tfinalAssigned[res.Task.Name] = res.Worker\n\t\t\t\tfmt.Printf(\"\u2705 Task %s assigned to Worker %s.\\n\", res.Task.Name, res.Worker)\n\t\t\t}\n\t\t} else {\n\t\t\t// fmt.Printf(\"\u274c Task %s cannot be assigned to Worker %s. Reasons: %v\\n\", res.Task.Name, res.Worker, res.Reason)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\nFinal Task Assignments:\")\n\tif len(finalAssigned) == 0 {\n\t\tfmt.Println(\"No tasks were assigned.\")\n\t} else {\n\t\tfor taskName, workerName := range finalAssigned {\n\t\t\tfmt.Printf(\"- %s -> %s\\n\", taskName, workerName)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\nProgram finished.\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_w3yy10nh/main.go:309\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    308: \t// Use a new rand.Rand instance for thread-safe and modern random number generation\n  > 309: \tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n    310: \n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 448\n  Nosec  : 0\n  Issues : \u001b[1;31m1\u001b[0m\n\n[gosec] 2025/12/01 13:01:33 Including rules: default\n[gosec] 2025/12/01 13:01:33 Excluding rules: default\n[gosec] 2025/12/01 13:01:33 Including analyzers: default\n[gosec] 2025/12/01 13:01:33 Excluding analyzers: default\n[gosec] 2025/12/01 13:01:33 Import directory: /tmp/go_synthesis_w3yy10nh\n[gosec] 2025/12/01 13:01:33 Checking package: main\n[gosec] 2025/12/01 13:01:33 Checking file: /tmp/go_synthesis_w3yy10nh/main.go"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\" // #nosec G404 - math/rand is acceptable for simulation purposes, not security-sensitive.\n\t\"sync\"\n\t\"time\"\n)\n\n// Task represents a unit of work.\ntype Task struct {\n\tName             string\n\tRequiredSize     int\n\tRequiredSkills   []string\n\tRequiredLocation string\n}\n\n// Worker represents an entity that can perform tasks.\ntype Worker struct {\n\tName       string\n\tCapacity   int\n\tSkills     []string\n\tLocation   string\n\tmu         sync.RWMutex // Protects worker state changes\n\tlastUpdate time.Time    // Timestamp of last state change, used for cache invalidation\n}\n\n// GetCapacity returns the worker's current capacity.\nfunc (w *Worker) GetCapacity() int {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.Capacity\n}\n\n// UpdateCapacity changes the worker's capacity and updates the lastUpdate timestamp.\nfunc (w *Worker) UpdateCapacity(newCapacity int) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.Capacity = newCapacity\n\tw.lastUpdate = time.Now()\n\tlog.Printf(\"Worker %s capacity updated to %d. Invalidating cache for this worker.\", w.Name, newCapacity)\n}\n\n// GetSkills returns the worker's current skills.\nfunc (w *Worker) GetSkills() []string {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\tskillsCopy := make([]string, len(w.Skills))\n\tcopy(skillsCopy, w.Skills)\n\treturn skillsCopy\n}\n\n// UpdateSkills changes the worker's skills and updates the lastUpdate timestamp.\nfunc (w *Worker) UpdateSkills(newSkills []string) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tw.Skills = newSkills\n\tw.lastUpdate = time.Now()\n\tlog.Printf(\"Worker %s skills updated. Invalidating cache for this worker.\", w.Name)\n}\n\n// GetLocation returns the worker's current location.\nfunc (w *Worker) GetLocation() string {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.Location\n}\n\n// GetLastUpdate returns the timestamp of the worker's last state update.\nfunc (w *Worker) GetLastUpdate() time.Time {\n\tw.mu.RLock()\n\tdefer w.mu.RUnlock()\n\treturn w.lastUpdate\n}\n\n// Predicate is a function that checks if a task can be assigned to a worker.\n// It returns true if the task fits, a slice of reasons for failure, and an error if an internal issue occurs.\ntype Predicate func(task Task, worker *Worker) (bool, []string, error)\n\n// CacheEntry stores the result of a predicate evaluation.\ntype CacheEntry struct {\n\tFit              bool\n\tReasons          []string\n\tTimestamp        time.Time // Timestamp when this entry was created\n\tWorkerLastUpdate time.Time // Worker's last update time when this entry was created\n}\n\n// EquivalenceCache stores predicate evaluation results.\ntype EquivalenceCache struct {\n\tmu      sync.RWMutex\n\tstore   map[string]map[string]map[string]CacheEntry // taskName -> workerName -> predicateName -> CacheEntry\n\tworkers map[string]*Worker                          // Reference to workers to check their lastUpdate time\n}\n\n// NewEquivalenceCache creates a new thread-safe cache.\nfunc NewEquivalenceCache(workers []*Worker) *EquivalenceCache {\n\tworkerMap := make(map[string]*Worker)\n\tfor _, w := range workers {\n\t\tworkerMap[w.Name] = w\n\t}\n\treturn &EquivalenceCache{\n\t\tstore:   make(map[string]map[string]map[string]CacheEntry),\n\t\tworkers: workerMap,\n\t}\n}\n\n// GetCachedResult retrieves a result from the cache.\n// It returns (fit, reasons, true) if a valid cached result is found,\n// otherwise (false, nil, false).\nfunc (c *EquivalenceCache) GetCachedResult(taskName, workerName, predicateName string) (fit bool, reasons []string, valid bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tif _, ok := c.store[taskName]; !ok {\n\t\treturn false, nil, false\n\t}\n\tif _, ok := c.store[taskName][workerName]; !ok {\n\t\treturn false, nil, false\n\t}\n\tif entry, ok := c.store[taskName][workerName][predicateName]; ok {\n\t\t// Check if the cached entry is still valid against the worker's last update time\n\t\tif worker, found := c.workers[workerName]; found {\n\t\t\tif worker.GetLastUpdate().After(entry.WorkerLastUpdate) {\n\t\t\t\tlog.Printf(\"Cache invalid: Worker %s state changed since cached entry for task %s, predicate %s.\", workerName, taskName, predicateName)\n\t\t\t\treturn false, nil, false // Worker state changed, cache is invalid\n\t\t\t}\n\t\t}\n\t\t// log.Printf(\"Cache hit for Task: %s, Worker: %s, Predicate: %s\", taskName, workerName, predicateName)\n\t\treturn entry.Fit, entry.Reasons, true\n\t}\n\treturn false, nil, false\n}\n\n// UpdateCache stores a new result in the cache.\nfunc (c *EquivalenceCache) UpdateCache(taskName, workerName, predicateName string, fit bool, reasons []string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif _, ok := c.store[taskName]; !ok {\n\t\tc.store[taskName] = make(map[string]map[string]CacheEntry)\n\t}\n\tif _, ok := c.store[taskName][workerName]; !ok {\n\t\tc.store[taskName][workerName] = make(map[string]CacheEntry)\n\t}\n\n\tworkerLastUpdate := time.Time{}\n\tif worker, found := c.workers[workerName]; found {\n\t\tworkerLastUpdate = worker.GetLastUpdate()\n\t}\n\n\tc.store[taskName][workerName][predicateName] = CacheEntry{\n\t\tFit:              fit,\n\t\tReasons:          reasons,\n\t\tTimestamp:        time.Now(),\n\t\tWorkerLastUpdate: workerLastUpdate,\n\t}\n\t// log.Printf(\"Cache updated for Task: %s, Worker: %s, Predicate: %s. Fit: %t\", taskName, workerName, predicateName, fit)\n}\n\n// InvalidateWorkerCache removes all cache entries for a specific worker.\nfunc (c *EquivalenceCache) InvalidateWorkerCache(workerName string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tfor taskName := range c.store {\n\t\tif _, ok := c.store[taskName][workerName]; ok {\n\t\t\tdelete(c.store[taskName], workerName)\n\t\t\t// If no more worker entries for this task, clean up task entry\n\t\t\tif len(c.store[taskName]) == 0 {\n\t\t\t\tdelete(c.store, taskName)\n\t\t\t}\n\t\t}\n\t}\n\tlog.Printf(\"Cache fully invalidated for worker %s due to external event.\", workerName)\n}\n\n// Predicate Functions\n\n// HasSufficientCapacity checks if the worker has enough capacity for the task.\nfunc HasSufficientCapacity(task Task, worker *Worker) (bool, []string, error) {\n\tworkerCapacity := worker.GetCapacity()\n\tif workerCapacity >= task.RequiredSize {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker capacity %d is less than task required size %d\", workerCapacity, task.RequiredSize)}, nil\n}\n\n// HasRequiredSkills checks if the worker has all required skills for the task.\nfunc HasRequiredSkills(task Task, worker *Worker) (bool, []string, error) {\n\tworkerSkills := worker.GetSkills()\n\tworkerHasSkill := make(map[string]bool)\n\tfor _, skill := range workerSkills {\n\t\tworkerHasSkill[skill] = true\n\t}\n\n\tvar missingSkills []string\n\tfor _, skill := range task.RequiredSkills {\n\t\tif !workerHasSkill[skill] {\n\t\t\tmissingSkills = append(missingSkills, skill)\n\t\t}\n\t}\n\n\tif len(missingSkills) == 0 {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker missing skills: %v\", missingSkills)}, nil\n}\n\n// IsInCorrectLocation checks if the worker is in the correct location for the task.\nfunc IsInCorrectLocation(task Task, worker *Worker) (bool, []string, error) {\n\tworkerLocation := worker.GetLocation()\n\tif task.RequiredLocation == \"\" || workerLocation == task.RequiredLocation {\n\t\treturn true, nil, nil\n\t}\n\treturn false, []string{fmt.Sprintf(\"worker location '%s' does not match task required location '%s'\", workerLocation, task.RequiredLocation)}, nil\n}\n\n// PredicateRegistry holds all predicates to be evaluated.\ntype PredicateRegistry struct {\n\tPredicates map[string]Predicate\n\tOrder      []string\n}\n\n// NewPredicateRegistry creates a new registry with predefined predicates.\nfunc NewPredicateRegistry() *PredicateRegistry {\n\tregistry := &PredicateRegistry{\n\t\tPredicates: make(map[string]Predicate),\n\t\tOrder:      []string{},\n\t}\n\tregistry.AddPredicate(\"HasSufficientCapacity\", HasSufficientCapacity)\n\tregistry.AddPredicate(\"HasRequiredSkills\", HasRequiredSkills)\n\tregistry.AddPredicate(\"IsInCorrectLocation\", IsInCorrectLocation)\n\treturn registry\n}\n\n// AddPredicate adds a new predicate to the registry.\nfunc (pr *PredicateRegistry) AddPredicate(name string, p Predicate) {\n\tpr.Predicates[name] = p\n\tpr.Order = append(pr.Order, name)\n}\n\n// Scheduler evaluates tasks against workers.\ntype Scheduler struct {\n\tCache        *EquivalenceCache\n\tPredicateReg *PredicateRegistry\n\tworkerMap    map[string]*Worker\n}\n\n// NewScheduler creates a new scheduler instance.\nfunc NewScheduler(cache *EquivalenceCache, workers []*Worker) *Scheduler {\n\tworkerMap := make(map[string]*Worker)\n\tfor _, w := range workers {\n\t\tworkerMap[w.Name] = w\n\t}\n\treturn &Scheduler{\n\t\tCache:        cache,\n\t\tPredicateReg: NewPredicateRegistry(),\n\t\tworkerMap:    workerMap,\n\t}\n}\n\n// ScheduleTask evaluates if a task can be assigned to a worker using predicates and cache.\nfunc (s *Scheduler) ScheduleTask(task Task, workerName string) (fit bool, reasons []string) {\n\tworker, ok := s.workerMap[workerName]\n\tif !ok {\n\t\treturn false, []string{fmt.Sprintf(\"worker %s not found\", workerName)}\n\t}\n\n\tallFit := true\n\tvar allReasons []string\n\n\tfor _, predName := range s.PredicateReg.Order {\n\t\tpredFunc := s.PredicateReg.Predicates[predName]\n\n\t\t// Try to get from cache\n\t\tcachedFit, cachedReasons, validCache := s.Cache.GetCachedResult(task.Name, worker.Name, predName)\n\n\t\tif validCache {\n\t\t\tfit = cachedFit\n\t\t\treasons = cachedReasons\n\t\t} else {\n\t\t\t// Cache miss or invalid, execute predicate\n\t\t\tvar err error\n\t\t\tfit, reasons, err = predFunc(task, worker)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error evaluating predicate %s for task %s, worker %s: %v\", predName, task.Name, worker.Name, err)\n\t\t\t\tallFit = false\n\t\t\t\tallReasons = append(allReasons, fmt.Sprintf(\"internal error for predicate %s: %v\", predName, err))\n\t\t\t\tbreak // Stop evaluating if there's an internal error\n\t\t\t}\n\t\t\t// Update cache with new result\n\t\t\ts.Cache.UpdateCache(task.Name, worker.Name, predName, fit, reasons)\n\t\t}\n\n\t\tif !fit {\n\t\t\tallFit = false\n\t\t\tallReasons = append(allReasons, reasons...)\n\t\t\tbreak // Stop at the first predicate that fails\n\t\t}\n\t}\n\n\treturn allFit, allReasons\n}\n\nfunc main() {\n\tlog.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)\n\t// Use a new rand.Rand instance for thread-safe and modern random number generation\n\tr := rand.New(rand.NewSource(time.Now().UnixNano())) // #nosec G404 - math/rand is acceptable for simulation purposes.\n\n\t// 1. Create Workers\n\tworkers := []*Worker{\n\t\t{Name: \"Alice\", Capacity: 10, Skills: []string{\"coding\", \"testing\"}, Location: \"NY\"},\n\t\t{Name: \"Bob\", Capacity: 5, Skills: []string{\"testing\", \"design\"}, Location: \"LA\"},\n\t\t{Name: \"Charlie\", Capacity: 15, Skills: []string{\"coding\", \"devops\"}, Location: \"NY\"},\n\t\t{Name: \"David\", Capacity: 8, Skills: []string{\"design\", \"management\"}, Location: \"SF\"},\n\t\t{Name: \"Eve\", Capacity: 12, Skills: []string{\"coding\", \"testing\", \"devops\"}, Location: \"LA\"},\n\t}\n\n\t// 2. Create Tasks\n\ttasks := []Task{\n\t\t{Name: \"TaskA\", RequiredSize: 3, RequiredSkills: []string{\"coding\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskB\", RequiredSize: 7, RequiredSkills: []string{\"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskC\", RequiredSize: 10, RequiredSkills: []string{\"devops\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskD\", RequiredSize: 2, RequiredSkills: []string{\"design\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"TaskE\", RequiredSize: 6, RequiredSkills: []string{\"coding\", \"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskF\", RequiredSize: 11, RequiredSkills: []string{\"management\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskG\", RequiredSize: 4, RequiredSkills: []string{\"coding\", \"devops\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"TaskH\", RequiredSize: 9, RequiredSkills: []string{\"testing\"}, RequiredLocation: \"LA\"},\n\t\t{Name: \"TaskI\", RequiredSize: 1, RequiredSkills: []string{\"design\"}, RequiredLocation: \"NY\"},\n\t\t{Name: \"TaskJ\", RequiredSize: 13, RequiredSkills: []string{\"coding\"}, RequiredLocation: \"LA\"},\n\t}\n\n\t// Initialize Cache and Scheduler\n\tcache := NewEquivalenceCache(workers)\n\tscheduler := NewScheduler(cache, workers)\n\n\tvar wg sync.WaitGroup\n\tassignedTasks := make(chan string, len(tasks)*len(workers))\n\tschedulingResults := make(chan struct {\n\t\tTask   Task\n\t\tWorker string\n\t\tFit    bool\n\t\tReason []string\n\t}, len(tasks)*len(workers))\n\n\t// Simulate background worker state changes and cache invalidation\n\tstopInvalidation := make(chan struct{})\n\tgo func() {\n\t\tticker := time.NewTicker(2 * time.Second) // Invalidate every 2 seconds\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tworkerToUpdate := workers[r.Intn(len(workers))]\n\t\t\t\taction := r.Intn(2) // 0 for capacity, 1 for skills\n\t\t\t\tif action == 0 {\n\t\t\t\t\tnewCapacity := r.Intn(10) + 5 // Capacity between 5 and 14\n\t\t\t\t\tworkerToUpdate.UpdateCapacity(newCapacity)\n\t\t\t\t} else {\n\t\t\t\t\t// Add a random skill or remove one\n\t\t\t\t\tallSkills := []string{\"coding\", \"testing\", \"design\", \"devops\", \"management\", \"documentation\"}\n\t\t\t\t\tnumSkills := r.Intn(3) + 1 // 1 to 3 skills\n\t\t\t\t\tnewSkills := make([]string, 0, numSkills)\n\t\t\t\t\tseen := make(map[string]bool)\n\t\t\t\t\tfor len(newSkills) < numSkills {\n\t\t\t\t\t\tskill := allSkills[r.Intn(len(allSkills))]\n\t\t\t\t\t\tif !seen[skill] {\n\t\t\t\t\t\t\tnewSkills = append(newSkills, skill)\n\t\t\t\t\t\t\tseen[skill] = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tworkerToUpdate.UpdateSkills(newSkills)\n\t\t\t\t}\n\t\t\t\t// Invalidate cache for this worker after its state changes\n\t\t\t\tcache.InvalidateWorkerCache(workerToUpdate.Name)\n\n\t\t\tcase <-stopInvalidation:\n\t\t\t\tlog.Println(\"Stopping worker state change simulation.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tfmt.Println(\"Starting concurrent task scheduling...\")\n\trunDuration := 10 * time.Second\n\tstartTime := time.Now()\n\toperationCounter := 0\n\n\tfor time.Since(startTime) < runDuration {\n\t\t// Launch goroutines for concurrent scheduling decisions\n\t\tnumConcurrentChecks := 5 // Number of task-worker pairs to check concurrently\n\t\tcurrentChecks := 0\n\t\tfor currentChecks < numConcurrentChecks && time.Since(startTime) < runDuration {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\ttask := tasks[r.Intn(len(tasks))]\n\t\t\t\tworker := workers[r.Intn(len(workers))]\n\n\t\t\t\tfit, reasons := scheduler.ScheduleTask(task, worker.Name)\n\t\t\t\tschedulingResults <- struct {\n\t\t\t\t\tTask   Task\n\t\t\t\t\tWorker string\n\t\t\t\t\tFit    bool\n\t\t\t\t\tReason []string\n\t\t\t\t}{task, worker.Name, fit, reasons}\n\t\t\t}()\n\t\t\tcurrentChecks++\n\t\t\toperationCounter++\n\t\t\ttime.Sleep(time.Duration(r.Intn(50)+10) * time.Millisecond) // Simulate varied request arrival\n\t\t}\n\t\ttime.Sleep(50 * time.Millisecond) // Small delay before next batch of checks\n\t}\n\n\tfmt.Println(\"Finished launching scheduling tasks. Waiting for goroutines to complete...\")\n\twg.Wait()\n\tclose(schedulingResults)\n\tclose(assignedTasks) // This channel is not being written to currently, but good practice to close\n\tclose(stopInvalidation) // Signal to stop background invalidation goroutine\n\n\tfmt.Printf(\"\\nTotal scheduling operations performed: %d\\n\", operationCounter)\n\tfmt.Println(\"\\n--- Scheduling Results Summary ---\")\n\tfinalAssigned := make(map[string]string)\n\tfor res := range schedulingResults {\n\t\tif res.Fit {\n\t\t\tif _, ok := finalAssigned[res.Task.Name]; !ok { // Assign only if not already assigned\n\t\t\t\tfinalAssigned[res.Task.Name] = res.Worker\n\t\t\t\tfmt.Printf(\"\u2705 Task %s assigned to Worker %s.\\n\", res.Task.Name, res.Worker)\n\t\t\t}\n\t\t} else {\n\t\t\t// fmt.Printf(\"\u274c Task %s cannot be assigned to Worker %s. Reasons: %v\\n\", res.Task.Name, res.Worker, res.Reason)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\nFinal Task Assignments:\")\n\tif len(finalAssigned) == 0 {\n\t\tfmt.Println(\"No tasks were assigned.\")\n\t} else {\n\t\tfor taskName, workerName := range finalAssigned {\n\t\t\tfmt.Printf(\"- %s -> %s\\n\", taskName, workerName)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\nProgram finished.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}