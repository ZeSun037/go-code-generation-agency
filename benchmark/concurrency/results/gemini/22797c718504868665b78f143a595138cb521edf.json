{
    "task": "22797c718504868665b78f143a595138cb521edf.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n)\n\n// LockManager represents the distributed lock manager system.\ntype LockManager struct {\n\tmu    sync.Mutex // Protects the 'locks' map\n\tlocks map[string]*ResourceLock\n}\n\n// ResourceLock manages the state for a single named resource.\n// It tracks who holds the lock and a queue of sessions waiting for it.\ntype ResourceLock struct {\n\tmu      sync.Mutex // Protects 'holder' and 'waiting' slice\n\tholder  string     // Session ID of the current lock holder, \"\" if free\n\twaiting []*lockRequest\n}\n\n// lockRequest represents a pending lock acquisition request from a client.\ntype lockRequest struct {\n\tsessionID    string\n\tresponseChan chan struct{} // Channel to unblock the client when the lock is acquired\n}\n\n// NewLockManager creates and returns a new LockManager instance.\nfunc NewLockManager() *LockManager {\n\treturn &LockManager{\n\t\tlocks: make(map[string]*ResourceLock),\n\t}\n}\n\n// getOrCreateResourceLock retrieves an existing ResourceLock for a given resourceName,\n// or creates a new one if it doesn't exist.\nfunc (lm *LockManager) getOrCreateResourceLock(resourceName string) *ResourceLock {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tif rl, ok := lm.locks[resourceName]; ok {\n\t\treturn rl\n\t}\n\n\trl := &ResourceLock{\n\t\twaiting: make([]*lockRequest, 0),\n\t}\n\tlm.locks[resourceName] = rl\n\treturn rl\n}\n\n// AcquireLock attempts to acquire a lock on a named resource for a given session.\n// If the lock is already held, the requesting session will wait in a FIFO queue\n// until the lock becomes available.\nfunc (lm *LockManager) AcquireLock(sessionID string, resourceName string) {\n\trl := lm.getOrCreateResourceLock(resourceName)\n\n\tresponseChan := make(chan struct{}) // A unique channel for this specific lock request\n\treq := &lockRequest{\n\t\tsessionID:    sessionID,\n\t\tresponseChan: responseChan,\n\t}\n\n\tfmt.Printf(\"[%s] Session %s requesting lock on %s\\n\", time.Now().Format(\"15:04:05.000\"), sessionID, resourceName)\n\n\trl.mu.Lock()\n\tif rl.holder == \"\" {\n\t\t// Lock is free, acquire it immediately\n\t\trl.holder = sessionID\n\t\trl.mu.Unlock()\n\t\tfmt.Printf(\"[%s] Session %s acquired lock on %s (immediate)\\n\", time.Now().Format(\"15:04:05.000\"), sessionID, resourceName)\n\t\treturn\n\t}\n\n\t// Lock is held by another session, add this request to the waiting queue\n\trl.waiting = append(rl.waiting, req)\n\trl.mu.Unlock() // Release resource lock mutex before waiting\n\n\t// Block until this request's response channel is closed (signaling acquisition)\n\t<-responseChan\n\n\t// This code executes only after the lock has been granted to this session\n\tfmt.Printf(\"[%s] Session %s acquired lock on %s (from queue)\\n\", time.Now().Format(\"15:04:05.000\"), sessionID, resourceName)\n}\n\n// ReleaseLock releases a lock held by the specified session on the given resource.\n// If there are waiting clients, the next one in the FIFO queue will be granted the lock.\nfunc (lm *LockManager) ReleaseLock(sessionID string, resourceName string) {\n\trl := lm.getOrCreateResourceLock(resourceName)\n\n\trl.mu.Lock()\n\tdefer rl.mu.Unlock()\n\n\tif rl.holder != sessionID {\n\t\tfmt.Printf(\"[%s] ERROR: Session %s attempted to release lock on %s, but does not hold it (held by %s)\\n\",\n\t\t\ttime.Now().Format(\"15:04:05.000\"), sessionID, resourceName, rl.holder)\n\t\treturn\n\t}\n\n\trl.holder = \"\" // Release the lock\n\n\tfmt.Printf(\"[%s] Session %s released lock on %s\\n\", time.Now().Format(\"15:04:05.000\"), sessionID, resourceName)\n\n\t// If there are clients waiting, grant the lock to the next one in the queue\n\tif len(rl.waiting) > 0 {\n\t\tnextReq := rl.waiting[0]\n\t\trl.waiting = rl.waiting[1:] // Dequeue the next request\n\n\t\trl.holder = nextReq.sessionID // Assign the lock to the next waiting session\n\t\tclose(nextReq.responseChan)   // Signal the waiting client that they have acquired the lock\n\t}\n}\n\n// client simulates a single client's interaction with the distributed lock manager.\nfunc client(id int, lm *LockManager, resourceName string, wg *sync.WaitGroup, acquireMultipleTimes bool) {\n\tdefer wg.Done()\n\n\tsessionID := \"client-\" + strconv.Itoa(id)\n\n\t// First acquisition attempt\n\tlm.AcquireLock(sessionID, resourceName)\n\tfmt.Printf(\"[%s] Session %s holding lock on %s for a short period...\\n\", time.Now().Format(\"15:04:05.000\"), sessionID, resourceName)\n\ttime.Sleep(time.Duration(100+id*50) * time.Millisecond) // Simulate work being done while holding the lock\n\tlm.ReleaseLock(sessionID, resourceName)\n\n\tif acquireMultipleTimes {\n\t\t// Simulate a second acquisition attempt by the same session\n\t\t// This demonstrates that even the same session respects the queue if others are waiting.\n\t\tfmt.Printf(\"[%s] Session %s (re)requesting lock on %s for the second time...\\n\", time.Now().Format(\"15:04:05.000\"), sessionID, resourceName)\n\t\ttime.Sleep(10 * time.Millisecond) // Small delay before re-requesting\n\t\tlm.AcquireLock(sessionID, resourceName)\n\t\tfmt.Printf(\"[%s] Session %s holding lock on %s (second acquisition)...\\n\", time.Now().Format(\"15:04:05.000\"), sessionID, resourceName)\n\t\ttime.Sleep(time.Duration(50+id*20) * time.Millisecond) // Simulate more work\n\t\tlm.ReleaseLock(sessionID, resourceName)\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"Starting Distributed Lock Manager simulation...\")\n\n\tlm := NewLockManager()\n\tvar wg sync.WaitGroup\n\tnumClients := 5\n\n\t// --- Scenario 1: Multiple clients competing for the same lock ---\n\tfmt.Println(\"\\n--- Scenario 1: Multiple clients competing for 'resource-A' (Single acquisition per client) ---\")\n\tresourceA := \"resource-A\"\n\tfor i := 1; i <= numClients; i++ {\n\t\twg.Add(1)\n\t\tgo client(i, lm, resourceA, &wg, false) // Clients acquire once\n\t\ttime.Sleep(50 * time.Millisecond)       // Stagger client starts slightly to make queuing visible\n\t}\n\twg.Wait()\n\tfmt.Println(\"--- Scenario 1 complete ---\")\n\n\t// --- Scenario 2: Demonstrate a client re-acquiring the same lock (after releasing it) ---\n\t// This shows that a session can acquire the same lock multiple times, respecting the queue.\n\tfmt.Println(\"\\n--- Scenario 2: Client-6 re-acquires 'resource-A' while others potentially wait ---\")\n\twg.Add(numClients + 1) // One additional client\n\tfor i := 1; i <= numClients; i++ {\n\t\t// Client 6 will attempt to re-acquire the lock after its first release\n\t\tgo client(i, lm, resourceA, &wg, i == 6) // Only client 6 attempts multiple acquisitions\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n\twg.Wait()\n\tfmt.Println(\"--- Scenario 2 complete ---\")\n\n\t// --- Scenario 3: Multiple clients competing for 'resource-B', where client-1 attempts re-acquisition ---\n\t// This specifically highlights FIFO fairness when a client tries to re-acquire.\n\tfmt.Println(\"\\n--- Scenario 3: Multiple clients competing for 'resource-B', client-1 re-acquires ---\")\n\tresourceB := \"resource-B\"\n\tfor i := 1; i <= numClients; i++ {\n\t\twg.Add(1)\n\t\tgo client(i, lm, resourceB, &wg, i == 1) // Only client 1 attempts multiple acquisitions\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n\twg.Wait()\n\tfmt.Println(\"--- Scenario 3 complete ---\")\n\n\tfmt.Println(\"\\nSimulation finished.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}