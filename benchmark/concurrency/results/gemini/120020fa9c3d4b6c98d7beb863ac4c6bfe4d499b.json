{
    "task": "120020fa9c3d4b6c98d7beb863ac4c6bfe4d499b.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// ErrKeyNotFound indicates that the requested key was not found in the store.\nvar ErrKeyNotFound = errors.New(\"key not found\")\n\n// ErrLeaseInvalid indicates that the lease associated with an operation is invalid or expired.\nvar ErrLeaseInvalid = errors.New(\"lease invalid\")\n\n// ErrCASFailed indicates that a compare-and-set operation failed due to a mismatch.\nvar ErrCASFailed = errors.New(\"compare-and-set failed\")\n\n// ErrSessionInvalid indicates that an election session is no longer active.\nvar ErrSessionInvalid = errors.New(\"election session is invalid\")\n\n// KVEntry represents a single key-value pair in the InMemoryKV store,\n// associating it with a lease ID.\ntype KVEntry struct {\n\tValue   string\n\tLeaseID string // The lease ID associated with this entry\n}\n\n// InMemoryKV is a simple in-memory key-value store with lease management and watch capabilities.\ntype InMemoryKV struct {\n\tmu            sync.RWMutex\n\tdata          map[string]KVEntry\n\twatchers      map[string]map[int]chan string // key -> watcherID -> channel\n\tnextWatcherID int\n\n\t// Lease Management\n\tactiveLeases     map[string]time.Time // leaseID -> expirationTime\n\tleaseTTL         time.Duration\n\tregisterLeaseCh  chan struct { leaseID string; ttl time.Duration }\n\tkeepAliveLeaseCh chan string\n\trevokeLeaseCh    chan string\n\texpirationTicker *time.Ticker\n\tstopLeaseManager chan struct{}\n\twgLeaseManager   sync.WaitGroup\n}\n\n// NewInMemoryKV creates and initializes a new InMemoryKV store.\n// sessionTTL defines the default time-to-live for sessions managed by this KV store.\nfunc NewInMemoryKV(sessionTTL time.Duration) *InMemoryKV {\n\tkv := &InMemoryKV{\n\t\tdata:             make(map[string]KVEntry),\n\t\twatchers:         make(map[string]map[int]chan string),\n\t\tactiveLeases:     make(map[string]time.Time),\n\t\tleaseTTL:         sessionTTL,\n\t\tregisterLeaseCh:  make(chan struct { leaseID string; ttl time.Duration }),\n\t\tkeepAliveLeaseCh: make(chan string),\n\t\trevokeLeaseCh:    make(chan string),\n\t\texpirationTicker: time.NewTicker(sessionTTL / 5), // Check expiration more frequently than TTL\n\t\tstopLeaseManager: make(chan struct{}),\n\t}\n\tif kv.leaseTTL/5 == 0 { // Ensure ticker interval is not zero for very short TTLs\n\t\tkv.expirationTicker = time.NewTicker(50 * time.Millisecond)\n\t}\n\n\tkv.wgLeaseManager.Add(1)\n\tgo kv.runLeaseManager()\n\treturn kv\n}\n\n// Close gracefully shuts down the InMemoryKV store and its background goroutines.\nfunc (kv *InMemoryKV) Close() {\n\tclose(kv.stopLeaseManager)\n\tkv.wgLeaseManager.Wait() // Wait for lease manager to exit\n\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\t// Close all watcher channels\n\tfor _, keyWatchers := range kv.watchers {\n\t\tfor _, ch := range keyWatchers {\n\t\t\tclose(ch)\n\t\t}\n\t}\n\tkv.watchers = nil\n\tkv.data = nil\n\tkv.activeLeases = nil\n}\n\n// runLeaseManager is a background goroutine that manages lease expirations and updates.\nfunc (kv *InMemoryKV) runLeaseManager() {\n\tdefer kv.wgLeaseManager.Done()\n\tfor {\n\t\tselect {\n\t\tcase leaseIDTTL := <-kv.registerLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tkv.activeLeases[leaseIDTTL.leaseID] = time.Now().Add(leaseIDTTL.ttl)\n\t\t\tkv.mu.Unlock()\n\t\tcase leaseID := <-kv.keepAliveLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tif _, ok := kv.activeLeases[leaseID]; ok {\n\t\t\t\tkv.activeLeases[leaseID] = time.Now().Add(kv.leaseTTL)\n\t\t\t}\n\t\t\tkv.mu.Unlock()\n\t\tcase leaseID := <-kv.revokeLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tdelete(kv.activeLeases, leaseID)\n\t\t\t// Immediately delete associated KV entries and notify watchers\n\t\t\tkv.deleteEntriesByLeaseID(leaseID)\n\t\t\tkv.mu.Unlock()\n\t\tcase <-kv.expirationTicker.C:\n\t\t\tkv.mu.Lock()\n\t\t\tnow := time.Now()\n\t\t\tfor leaseID, expiry := range kv.activeLeases {\n\t\t\t\tif now.After(expiry) {\n\t\t\t\t\tdelete(kv.activeLeases, leaseID)\n\t\t\t\t\tkv.deleteEntriesByLeaseID(leaseID) // Delete associated entries and notify\n\t\t\t\t}\n\t\t\t}\n\t\t\tkv.mu.Unlock()\n\t\tcase <-kv.stopLeaseManager:\n\t\t\tkv.expirationTicker.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// RegisterLease registers a new lease with a given ID and TTL.\nfunc (kv *InMemoryKV) RegisterLease(leaseID string, ttl time.Duration) {\n\tkv.registerLeaseCh <- struct { leaseID string; ttl time.Duration }{leaseID, ttl}\n}\n\n// KeepLeaseAlive renews the expiration time for an existing lease.\nfunc (kv *InMemoryKV) KeepLeaseAlive(leaseID string) {\n\tkv.keepAliveLeaseCh <- leaseID\n}\n\n// RevokeLease immediately revokes a lease and deletes associated KV entries.\nfunc (kv *InMemoryKV) RevokeLease(leaseID string) {\n\tkv.revokeLeaseCh <- leaseID\n}\n\n// IsLeaseValid checks if a lease with the given ID is currently active.\nfunc (kv *InMemoryKV) IsLeaseValid(leaseID string) bool {\n\tif leaseID == \"\" {\n\t\treturn false // Empty lease ID is never valid\n\t}\n\tkv.mu.RLock()\n\tdefer kv.mu.RUnlock()\n\t_, ok := kv.activeLeases[leaseID]\n\treturn ok\n}\n\n// deleteEntriesByLeaseID must be called with kv.mu held.\n// It removes all KV entries associated with the given leaseID and notifies watchers.\nfunc (kv *InMemoryKV) deleteEntriesByLeaseID(leaseID string) {\n\tvar changedKeys []string\n\tfor k, entry := range kv.data {\n\t\tif entry.LeaseID == leaseID {\n\t\t\tdelete(kv.data, k)\n\t\t\tchangedKeys = append(changedKeys, k)\n\t\t}\n\t}\n\t// Notify watchers for the deleted keys\n\tfor _, k := range changedKeys {\n\t\tkv.notifyWatchers(k, \"\") // Send empty string for deletion\n\t}\n}\n\n// Put adds or updates a key-value pair with an associated lease ID.\n// The leaseID must be valid.\nfunc (kv *InMemoryKV) Put(key, value string, leaseID string) error {\n\tif !kv.IsLeaseValid(leaseID) {\n\t\treturn ErrLeaseInvalid\n\t}\n\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tkv.data[key] = KVEntry{Value: value, LeaseID: leaseID}\n\tkv.notifyWatchers(key, value)\n\treturn nil\n}\n\n// Get retrieves the value and lease ID for a given key.\n// Returns ErrKeyNotFound if the key does not exist.\nfunc (kv *InMemoryKV) Get(key string) (string, string, error) {\n\tkv.mu.RLock()\n\tdefer kv.mu.RUnlock()\n\n\tentry, ok := kv.data[key]\n\tif !ok {\n\t\treturn \"\", \"\", ErrKeyNotFound\n\t}\n\treturn entry.Value, entry.LeaseID, nil\n}\n\n// Delete removes a key-value pair. Returns ErrKeyNotFound if the key does not exist.\nfunc (kv *InMemoryKV) Delete(key string) error {\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tif _, ok := kv.data[key]; !ok {\n\t\treturn ErrKeyNotFound\n\t}\n\tdelete(kv.data, key)\n\tkv.notifyWatchers(key, \"\") // Notify with empty string for deletion\n\treturn nil\n}\n\n// CompareAndSet performs a transactional update.\n// If oldValue and oldLeaseID match the current entry (or are both empty for a new key),\n// the key's value and lease ID are updated to newValue and newLeaseID.\n// For deletion: set newValue and newLeaseID to empty strings.\n// Returns true on success, false on mismatch, or an error.\nfunc (kv *InMemoryKV) CompareAndSet(key, oldValue, newValue string, oldLeaseID, newLeaseID string) (bool, error) {\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tcurrentEntry, exists := kv.data[key]\n\n\t// Validate new lease ID if not a delete operation\n\tif newValue != \"\" && newLeaseID != \"\" && !kv.IsLeaseValid(newLeaseID) {\n\t\treturn false, ErrLeaseInvalid\n\t}\n\n\tif exists {\n\t\t// Key exists, check if old values match\n\t\tif currentEntry.Value != oldValue || currentEntry.LeaseID != oldLeaseID {\n\t\t\treturn false, nil // Mismatch, CAS failed\n\t\t}\n\t\t// Match, perform update or delete\n\t\tif newValue == \"\" && newLeaseID == \"\" { // It's a delete operation\n\t\t\tdelete(kv.data, key)\n\t\t\tkv.notifyWatchers(key, \"\")\n\t\t} else { // Update operation\n\t\t\tkv.data[key] = KVEntry{Value: newValue, LeaseID: newLeaseID}\n\t\t\tkv.notifyWatchers(key, newValue)\n\t\t}\n\t} else {\n\t\t// Key does not exist\n\t\tif oldValue != \"\" || oldLeaseID != \"\" {\n\t\t\treturn false, nil // Mismatch (expected existing key), CAS failed\n\t\t}\n\t\t// Key doesn't exist, and we expect it not to exist (oldValue/oldLeaseID are empty)\n\t\tif newValue == \"\" && newLeaseID == \"\" {\n\t\t\t// Trying to delete a non-existent key, consider it a success for CAS\n\t\t\treturn true, nil\n\t\t}\n\t\t// Create new entry\n\t\tkv.data[key] = KVEntry{Value: newValue, LeaseID: newLeaseID}\n\t\tkv.notifyWatchers(key, newValue)\n\t}\n\treturn true, nil\n}\n\n// Watch returns a channel that receives value updates for a specific key (or keys matching a prefix).\n// The channel will be closed when the context is cancelled or the KV store is closed.\n// It sends the current value for the key first, then subsequent changes.\nfunc (kv *InMemoryKV) Watch(ctx context.Context, key string) <-chan string {\n\tout := make(chan string, 1) // Buffered channel to not block initial send\n\n\tkv.mu.Lock()\n\twatcherID := kv.nextWatcherID\n\tkv.nextWatcherID++\n\tif _, ok := kv.watchers[key]; !ok {\n\t\tkv.watchers[key] = make(map[int]chan string)\n\t}\n\tkv.watchers[key][watcherID] = out\n\tkv.mu.Unlock()\n\n\t// Goroutine to remove watcher when context is cancelled\n\tgo func() {\n\t\tdefer func() {\n\t\t\tkv.mu.Lock()\n\t\t\tdefer kv.mu.Unlock()\n\t\t\tif keyWatchers, ok := kv.watchers[key]; ok {\n\t\t\t\tdelete(keyWatchers, watcherID)\n\t\t\t\tif len(keyWatchers) == 0 {\n\t\t\t\t\tdelete(kv.watchers, key)\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose(out) // Ensure the channel is closed\n\t\t}()\n\n\t\t// Send initial value if exists\n\t\tvalue, _, err := kv.Get(key)\n\t\tif err == nil {\n\t\t\tselect {\n\t\t\tcase out <- value:\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn // Context cancelled before sending initial value\n\t\t\t}\n\t\t} else if err == ErrKeyNotFound {\n\t\t\t// If key doesn't exist, send empty string initially to indicate no leader\n\t\t\tselect {\n\t\t\tcase out <- \"\":\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t<-ctx.Done() // Block until context is cancelled\n\t}()\n\n\treturn out\n}\n\n// notifyWatchers must be called with kv.mu held.\n// It sends a value update to all watchers whose keys match the key.\n// In this specific implementation, watchers are registered for exact keys, not prefixes.\nfunc (kv *InMemoryKV) notifyWatchers(key, value string) {\n\tif watchers, ok := kv.watchers[key]; ok {\n\t\tfor _, ch := range watchers {\n\t\t\t// Non-blocking send, if a watcher is slow, it gets stale data\n\t\t\tselect {\n\t\t\tcase ch <- value:\n\t\t\tdefault:\n\t\t\t\t// Drop event if channel is full. Watchers are expected to keep up.\n\t\t\t}\n\t\t}\n\t}\n\t// Also check for prefix watchers if needed, but the current Election.Observe uses exact key matching\n\t// for `leaderKeyPrefix + name`, so this is sufficient.\n\t// For general prefix watching, a loop over all kv.watchers keys and strings.HasPrefix would be needed.\n\t// For example:\n\tfor watcherPrefix, watchersMap := range kv.watchers {\n\t\tif watcherPrefix != key && strings.HasPrefix(key, watcherPrefix) {\n\t\t\tfor _, ch := range watchersMap {\n\t\t\t\tselect {\n\t\t\t\tcase ch <- value:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Session represents a participant's connection or lease in the leader election system.\ntype Session struct {\n\tid          string\n\tleaseManager *InMemoryKV // Reference to the KV store for lease operations\n\tcancelCtx   context.CancelFunc // To signal session invalidation from outside\n\tctx         context.Context    // Context for session lifecycle\n}\n\n// NewSession creates a new session with a unique ID and registers it with the KV store's lease manager.\n// It also starts a background goroutine to periodically keep the lease alive.\nfunc NewSession(kv *InMemoryKV, ttl time.Duration) *Session {\n\tctx, cancel := context.WithCancel(context.Background())\n\ts := &Session{\n\t\tid:          uuid.New().String(),\n\t\tleaseManager: kv,\n\t\tcancelCtx:   cancel,\n\t\tctx:         ctx,\n\t}\n\tkv.RegisterLease(s.id, ttl)\n\tgo s.keepAliveLoop(ctx, ttl/2) // Renew lease at half the TTL\n\treturn s\n}\n\n// ID returns the unique identifier of the session.\nfunc (s *Session) ID() string {\n\treturn s.id\n}\n\n// IsAlive checks if the session is currently active.\nfunc (s *Session) IsAlive() bool {\n\treturn s.ctx.Err() == nil\n}\n\n// Close explicitly closes the session, revoking its lease and stopping its keep-alive loop.\nfunc (s *Session) Close() {\n\ts.cancelCtx()              // Signal the keep-alive loop to stop\n\ts.leaseManager.RevokeLease(s.id) // Unregister from the KV's lease manager\n}\n\n// keepAliveLoop periodically sends a keep-alive signal for the session's lease.\nfunc (s *Session) keepAliveLoop(ctx context.Context, renewInterval time.Duration) {\n\tticker := time.NewTicker(renewInterval)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done(): // Session explicitly closed or parent context cancelled\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\ts.leaseManager.KeepLeaseAlive(s.id)\n\t\t}\n\t}\n}\n\nconst leaderKeyPrefix = \"/election/\"\n\n// Election manages the leader election process for a specific election name.\ntype Election struct {\n\tsession  *Session\n\tkv       *InMemoryKV\n\tkey      string // The key in KV store representing this election (e.g., /election/my-election)\n\tleaderVal string // Cached leader value for current session if it IS leader\n\tisLeader bool   // Flag to indicate if this instance currently holds leadership\n\tmu       sync.Mutex // Protects isLeader, leaderVal\n}\n\n// NewElection creates a new Election instance.\nfunc NewElection(session *Session, kv *InMemoryKV, name string) *Election {\n\treturn &Election{\n\t\tsession: session,\n\t\tkv:      kv,\n\t\tkey:     leaderKeyPrefix + name,\n\t}\n}\n\n// Campaign attempts to become the leader with the given value.\n// It blocks until the participant becomes the leader, the context is cancelled, or the session expires.\nfunc (e *Election) Campaign(ctx context.Context, value string) error {\n\tif !e.session.IsAlive() {\n\t\treturn ErrSessionInvalid\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Context cancelled, best-effort resign if we became leader during this campaign.\n\t\t\te.Resign(context.Background())\n\t\t\treturn ctx.Err()\n\t\tcase <-e.session.ctx.Done():\n\t\t\t// Session expired/closed, can no longer be leader.\n\t\t\treturn ErrSessionInvalid\n\t\tdefault:\n\t\t\tok, err := e.tryBecomeLeader(ctx, value)\n\t\t\tif err != nil {\n\t\t\t\tif err == ErrSessionInvalid {\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\t}\n\t\t\t\t// Log error and retry after a short backoff for transient issues.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) tryBecomeLeader error: %v. Retrying in 100ms.\\n\", e.key, e.session.ID(), value, err)\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done(): return ctx.Err()\n\t\t\t\tcase <-e.session.ctx.Done(): return ErrSessionInvalid\n\t\t\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ok {\n\t\t\t\t// We are now the leader.\n\t\t\t\te.mu.Lock()\n\t\t\t\te.isLeader = true\n\t\t\t\te.leaderVal = value\n\t\t\t\te.mu.Unlock()\n\t\t\t\tlog.Printf(\"Election %s Participant %s BECAME LEADER with value %q.\\n\", e.key, e.session.ID(), value)\n\n\t\t\t\t// Maintain leadership until context cancels, session invalidates, or explicit resign.\n\t\t\t\tmaintainErr := e.maintainLeadership(ctx, value)\n\n\t\t\t\t// Clear leadership status on exit from maintainLeadership.\n\t\t\t\te.mu.Lock()\n\t\t\t\te.isLeader = false\n\t\t\t\te.leaderVal = \"\"\n\t\t\t\te.mu.Unlock()\n\n\t\t\t\tif maintainErr == nil {\n\t\t\t\t\t// This implies a clean exit from maintainLeadership (e.g., due to a Resign call).\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif maintainErr == context.Canceled {\n\t\t\t\t\treturn ctx.Err()\n\t\t\t\t}\n\t\t\t\tif maintainErr == ErrSessionInvalid {\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\t}\n\t\t\t\t// If maintainErr is some other error, it means we lost leadership unexpectedly.\n\t\t\t\t// The loop should continue to try to regain leadership.\n\t\t\t\tlog.Printf(\"Election %s Participant %s LOST LEADERSHIP unexpectedly: %v. Retrying campaign.\\n\", e.key, e.session.ID(), maintainErr)\n\t\t\t} else {\n\t\t\t\t// Did not become leader (someone else is leader and their lease is valid).\n\t\t\t\t// Wait for a change in the leader key.\n\t\t\t\twatchCtx, watchCancel := context.WithCancel(ctx)\n\t\t\t\tleaderEvents := e.kv.Watch(watchCtx, e.key)\n\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) waiting for leader change...\\n\", e.key, e.session.ID(), value)\n\t\t\t\tselect {\n\t\t\t\tcase <-leaderEvents:\n\t\t\t\t\tlog.Printf(\"Election %s Participant %s detected leader change, re-campaigning.\\n\", e.key, e.session.ID())\n\t\t\t\t\twatchCancel()\n\t\t\t\t\t// Leader changed, loop will retry campaign immediately.\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\twatchCancel()\n\t\t\t\t\treturn ctx.Err()\n\t\t\t\tcase <-e.session.ctx.Done():\n\t\t\t\t\twatchCancel()\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\tcase <-time.After(e.kv.leaseTTL + time.Second): // Also re-check periodically if no watch event\n\t\t\t\t\twatchCancel()\n\t\t\t\t\tlog.Printf(\"Election %s Participant %s timed out waiting for leader change or lease expired, re-campaigning.\\n\", e.key, e.session.ID())\n\t\t\t\t\t// Loop will retry.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// tryBecomeLeader attempts to acquire leadership or update existing leadership for the session.\n// Returns true if the session becomes or successfully renews its leadership,\n// false if another valid leader exists, or an error on failure.\nfunc (e *Election) tryBecomeLeader(ctx context.Context, value string) (bool, error) {\n\tif !e.session.IsAlive() {\n\t\treturn false, ErrSessionInvalid\n\t}\n\n\tcurrentVal, currentLeaseID, err := e.kv.Get(e.key)\n\tif err != nil && err != ErrKeyNotFound {\n\t\treturn false, fmt.Errorf(\"failed to get current leader state: %w\", err)\n\t}\n\n\tif err == ErrKeyNotFound {\n\t\t// No leader, try to become one (compare-and-set with empty old values)\n\t\tok, casErr := e.kv.CompareAndSet(e.key, \"\", value, \"\", e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to become leader failed: %w\", casErr)\n\t\t}\n\t\treturn ok, nil // If ok is true, we are leader\n\t}\n\n\t// There is an existing leader entry\n\tif currentLeaseID == e.session.ID() {\n\t\t// We are already the leader (same session ID), update value and keep lease alive.\n\t\tok, casErr := e.kv.CompareAndSet(e.key, currentVal, value, e.session.ID(), e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to update leadership failed (we are current leader): %w\", casErr)\n\t\t}\n\t\treturn ok, nil\n\t}\n\n\t// Someone else is the leader. Check if their lease is valid.\n\tif !e.kv.IsLeaseValid(currentLeaseID) {\n\t\t// Current leader's lease is invalid, try to take over.\n\t\t// Use CAS to ensure we only take over if the current, invalid leader is still in place.\n\t\tok, casErr := e.kv.CompareAndSet(e.key, currentVal, value, currentLeaseID, e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to take over expired leadership failed: %w\", casErr)\n\t\t}\n\t\treturn ok, nil\n\t}\n\n\t// Someone else is leader and their lease is still valid.\n\treturn false, nil\n}\n\n// maintainLeadership periodically renews the leader's lease and monitors for leadership changes.\n// It returns nil if leadership was cleanly resigned by this instance,\n// context.Canceled if the provided ctx was cancelled,\n// ErrSessionInvalid if the session became invalid,\n// or an error if leadership was lost unexpectedly (e.g., taken over by another, or key deleted).\nfunc (e *Election) maintainLeadership(ctx context.Context, currentKnownValue string) error {\n\trenewInterval := e.kv.leaseTTL / 3\n\tif renewInterval < 100*time.Millisecond {\n\t\trenewInterval = 100 * time.Millisecond // Minimum for very short TTLs\n\t}\n\tticker := time.NewTicker(renewInterval)\n\tdefer ticker.Stop()\n\n\twatchCtx, watchCancel := context.WithCancel(ctx)\n\tdefer watchCancel()\n\tleaderEvents := e.kv.Watch(watchCtx, e.key)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Parent context cancelled, need to resign best-effort.\n\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Context cancelled. Resigning...\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\te.Resign(context.Background())\n\t\t\treturn ctx.Err()\n\t\tcase <-e.session.ctx.Done():\n\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Session invalid. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\treturn ErrSessionInvalid\n\t\tcase <-ticker.C:\n\t\t\t// Periodically re-assert leadership and keep lease alive.\n\t\t\t// This CAS acts as a heartbeart and ensures no one else has tampered with our key.\n\t\t\tok, casErr := e.kv.CompareAndSet(e.key, currentKnownValue, currentKnownValue, e.session.ID(), e.session.ID())\n\t\t\tif casErr != nil {\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: CAS failed during renewal: %v. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue, casErr)\n\t\t\t\treturn fmt.Errorf(\"lost leadership during renewal: %w\", casErr)\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\t// CAS returned false, meaning our oldValue/oldLeaseID didn't match what's in KV.\n\t\t\t\t// This implies leadership was taken over or deleted.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: CAS returned false during renewal. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\t\treturn errors.New(\"lost leadership during renewal due to CAS mismatch\")\n\t\t\t}\n\t\t\t// Leadership successfully renewed.\n\t\tcase observedVal := <-leaderEvents:\n\t\t\t// A change was observed on our leader key.\n\t\t\t// Re-fetch state to confirm if leadership is still held by us.\n\t\t\tval, leaseID, err := e.kv.Get(e.key)\n\n\t\t\tif err == ErrKeyNotFound || leaseID != e.session.ID() || !e.kv.IsLeaseValid(leaseID) {\n\t\t\t\t// Our key was deleted, taken over by another, or our lease became invalid.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Observed change indicates leadership lost. Current: %q, LeaseID: %q, IsValid: %t, Err: %v\\n\",\n\t\t\t\t\te.key, e.session.ID(), currentKnownValue, val, leaseID, e.kv.IsLeaseValid(leaseID), err)\n\t\t\t\treturn errors.New(\"observed leadership loss or takeover\")\n\t\t\t}\n\n\t\t\t// We are still the leader, but the value might have been updated (e.g., by another Campaign call from the same session).\n\t\t\tif val != currentKnownValue {\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Observed leader value changed from %q to %q (same session update).\\n\", e.key, e.session.ID(), currentKnownValue, val)\n\t\t\t\te.mu.Lock()\n\t\t\t\te.leaderVal = val // Update cached leader value\n\t\t\t\te.mu.Unlock()\n\t\t\t\tcurrentKnownValue = val // Update for subsequent CAS operations\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Resign voluntarily steps down from leadership.\n// It will only succeed if the session is currently the leader.\nfunc (e *Election) Resign(ctx context.Context) error {\n\te.mu.Lock()\n\tisLeader := e.isLeader // Check if this instance believes it is leader\n\tleaderVal := e.leaderVal\n\te.mu.Unlock()\n\n\tif !isLeader {\n\t\treturn nil // Not leader, nothing to resign.\n\t}\n\tif !e.session.IsAlive() {\n\t\treturn ErrSessionInvalid\n\t}\n\n\t// Use CAS to delete the key ONLY if it's currently held by this session.\n\tok, err := e.kv.CompareAndSet(e.key, leaderVal, \"\", e.session.ID(), \"\") // newValue and newLeaseID empty for delete\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resign: %w\", err)\n\t}\n\tif !ok {\n\t\t// This means our leadership was already gone when we tried to resign (e.g., expired or taken over).\n\t\treturn fmt.Errorf(\"failed to resign: no longer leader when attempting CAS delete\")\n\t}\n\n\te.mu.Lock()\n\te.isLeader = false\n\te.leaderVal = \"\"\n\te.mu.Unlock()\n\tlog.Printf(\"Election %s Participant %s RESIGNED leadership.\\n\", e.key, e.session.ID())\n\treturn nil\n}\n\n// Leader returns the current leader's value.\n// It returns an empty string if there is no leader or the leader's lease is invalid.\nfunc (e *Election) Leader(ctx context.Context) (string, error) {\n\tval, leaseID, err := e.kv.Get(e.key)\n\tif err == ErrKeyNotFound {\n\t\treturn \"\", nil // No leader entry\n\t}\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to get leader: %w\", err)\n\t}\n\t// Even if there's an entry, check if its lease is valid\n\tif !e.kv.IsLeaseValid(leaseID) {\n\t\treturn \"\", nil // Lease expired, effectively no leader\n\t}\n\treturn val, nil\n}\n\n// Observe returns a channel that emits the current leader's value whenever it changes.\n// The channel will emit the current leader's value initially.\nfunc (e *Election) Observe(ctx context.Context) <-chan string {\n\tout := make(chan string)\n\tkvWatchCh := e.kv.Watch(ctx, e.key)\n\n\tgo func() {\n\t\tdefer close(out)\n\t\t// Send initial leader state\n\t\tcurrentLeader, err := e.Leader(ctx)\n\t\tif err == nil {\n\t\t\tselect {\n\t\t\tcase out <- currentLeader:\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\t// Log error but continue watching\n\t\t\tlog.Printf(\"Election %s Observer initial leader check error: %v\\n\", e.key, err)\n\t\t}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-kvWatchCh: // A change in the underlying key\n\t\t\t\tleaderVal, err := e.Leader(ctx) // Re-fetch current leader state\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Election %s Observer error getting leader after change: %v\\n\", e.key, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase out <- leaderVal:\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn out\n}\n\nfunc main() {\n\tlog.SetFlags(log.Ltime | log.Lmicroseconds)\n\n\t// --- Test Scenario 1: Same session, multiple elections for the same key ---\n\tlog.Println(\"\\n--- Test Scenario 1: Same session, multiple elections for the same key ---\")\n\tsessionTTL := 2 * time.Second\n\tkv := NewInMemoryKV(sessionTTL)\n\tdefer kv.Close()\n\n\tsession := NewSession(kv, sessionTTL)\n\tdefer session.Close()\n\n\telection1 := NewElection(session, kv, \"my-election\")\n\telection2 := NewElection(session, kv, \"my-election\")\n\n\tvar wg sync.WaitGroup\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Observer to watch changes for \"my-election\"\n\tleaderObserverCh := election1.Observe(ctx)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase val := <-leaderObserverCh:\n\t\t\t\tlog.Printf(\"[Observer for my-election] Current leader: %q\\n\", val)\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Println(\"Election 1: Campaigning with value1...\")\n\t\terr := election1.Campaign(ctx, \"value1\")\n\t\tif err != nil && err != context.Canceled {\n\t\t\tlog.Printf(\"Election 1 Campaign error: %v\\n\", err)\n\t\t} else if err == nil {\n\t\t\tlog.Println(\"Election 1: Campaign with value1 completed successfully (may have resigned or context cancelled).\")\n\t\t}\n\t}()\n\n\t// Give election1 a brief moment to establish leadership\n\ttime.Sleep(200 * time.Millisecond)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Println(\"Election 2: Campaigning with value2 (same session, same election name)...\")\n\t\terr := election2.Campaign(ctx, \"value2\")\n\t\tif err != nil && err != context.Canceled {\n\t\t\tlog.Printf(\"Election 2 Campaign error: %v\\n\", err)\n\t\t} else if err == nil {\n\t\t\tlog.Println(\"Election 2: Campaign with value2 completed successfully (value should have been updated).\")\n\t\t}\n\t}()\n\n\twg.Wait()\n\ttime.Sleep(50 * time.Millisecond) // Give observers time to react\n\tcurrentLeader, err := election1.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting leader for 'my-election': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'my-election' after scenario 1: %q (expected: value2)\\n\", currentLeader)\n\t}\n\n\t// --- Test Scenario 2: Three concurrent participants competing and resigning ---\n\tlog.Println(\"\\n--- Test Scenario 2: Three concurrent participants competing and resigning ---\")\n\tsessionTTL2 := 3 * time.Second\n\tkv2 := NewInMemoryKV(sessionTTL2)\n\tdefer kv2.Close()\n\n\tsessionA := NewSession(kv2, sessionTTL2)\n\tsessionB := NewSession(kv2, sessionTTL2)\n\tsessionC := NewSession(kv2, sessionTTL2)\n\tdefer sessionA.Close()\n\tdefer sessionB.Close()\n\tdefer sessionC.Close()\n\n\telectionA := NewElection(sessionA, kv2, \"test-election-compete\")\n\telectionB := NewElection(sessionB, kv2, \"test-election-compete\")\n\telectionC := NewElection(sessionC, kv2, \"test-election-compete\")\n\n\tvar wg2 sync.WaitGroup\n\tctx2, cancel2 := context.WithCancel(context.Background())\n\tdefer cancel2()\n\n\t// Observer for the competing election\n\tleaderCompeteObserverCh := electionA.Observe(ctx2)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase l := <-leaderCompeteObserverCh:\n\t\t\t\tlog.Printf(\"[Compete Observer] Leader for 'test-election-compete': %q\\n\", l)\n\t\t\tcase <-ctx2.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tcampaignAndResign := func(name string, election *Election, val string, holdDuration time.Duration) {\n\t\tdefer wg2.Done()\n\t\tlog.Printf(\"Participant %s: Trying to campaign with value %q...\\n\", name, val)\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx2, 10*time.Second) // Campaign for max 10s\n\t\tdefer campaignCancel()\n\n\t\terr := election.Campaign(campaignCtx, val)\n\t\tif err != nil && err != context.Canceled && err != ErrSessionInvalid {\n\t\t\tlog.Printf(\"Participant %s: Campaign for %q failed: %v\\n\", name, val, err)\n\t\t\treturn\n\t\t}\n\t\tif err == ErrSessionInvalid {\n\t\t\tlog.Printf(\"Participant %s: Campaign failed due to session invalid: %v\\n\", name, err)\n\t\t\treturn\n\t\t}\n\t\tif err == context.Canceled {\n\t\t\tlog.Printf(\"Participant %s: Campaign cancelled.\\n\", name)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Participant %s: IS THE LEADER with value %q! Holding for %v\\n\", name, val, holdDuration)\n\t\tselect {\n\t\tcase <-time.After(holdDuration):\n\t\t\t// Hold leadership for some time\n\t\tcase <-ctx2.Done():\n\t\t\tlog.Printf(\"Participant %s: Context cancelled while holding leadership.\\n\", name)\n\t\t\treturn\n\t\tcase <-election.session.ctx.Done():\n\t\t\tlog.Printf(\"Participant %s: Session invalid while holding leadership.\\n\", name)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Participant %s: Resigning leadership...\\n\", name)\n\t\tresignCtx, resignCancel := context.WithTimeout(context.Background(), 1*time.Second) // Resign with its own ctx\n\t\tdefer resignCancel()\n\t\tif err := election.Resign(resignCtx); err != nil {\n\t\t\tlog.Printf(\"Participant %s: Failed to resign: %v\\n\", name, err)\n\t\t} else {\n\t\t\tlog.Printf(\"Participant %s: Successfully resigned.\\n\", name)\n\t\t}\n\t}\n\n\twg2.Add(3)\n\tgo campaignAndResign(\"Alpha\", electionA, \"AlphaLeader\", 2*time.Second)\n\tgo campaignAndResign(\"Beta\", electionB, \"BetaLeader\", 2*time.Second)\n\tgo campaignAndResign(\"Gamma\", electionC, \"GammaLeader\", 2*time.Second)\n\n\twg2.Wait()\n\ttime.Sleep(50 * time.Millisecond)\n\tcurrentLeader2, err := electionA.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting final leader for 'test-election-compete': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'test-election-compete' after scenario 2: %q\\n\", currentLeader2)\n\t}\n\n\t// --- Test Scenario 3: Leader expiration leading to handover ---\n\tlog.Println(\"\\n--- Test Scenario 3: Leader expiration leading to handover ---\")\n\tsessionTTL3 := 1 * time.Second // Short TTL for demonstration\n\tkv3 := NewInMemoryKV(sessionTTL3)\n\tdefer kv3.Close()\n\n\tsessionP1 := NewSession(kv3, sessionTTL3)\n\tsessionP2 := NewSession(kv3, sessionTTL3)\n\tdefer sessionP1.Close()\n\tdefer sessionP2.Close()\n\n\telectionP1 := NewElection(sessionP1, kv3, \"expiring-election\")\n\telectionP2 := NewElection(sessionP2, kv3, \"expiring-election\")\n\n\tvar wg3 sync.WaitGroup\n\tctx3, cancel3 := context.WithCancel(context.Background())\n\tdefer cancel3()\n\n\t// Observer for expiration scenario\n\tleaderExpObserverCh := electionP1.Observe(ctx3)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase l := <-leaderExpObserverCh:\n\t\t\t\tlog.Printf(\"[Expiration Observer] Leader for 'expiring-election': %q\\n\", l)\n\t\t\tcase <-ctx3.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\twg3.Add(1)\n\tgo func() {\n\t\tdefer wg3.Done()\n\t\tlog.Println(\"P1: Campaigning for 'expiring-election'...\")\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx3, 5*time.Second) // Give enough time\n\t\tdefer campaignCancel()\n\n\t\terr := electionP1.Campaign(campaignCtx, \"P1-leader\")\n\t\tif err != nil && err != context.Canceled && err != ErrSessionInvalid {\n\t\t\tlog.Printf(\"P1 campaign error: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tif err == nil {\n\t\t\tlog.Println(\"P1: Is leader. Holding until session expires (should happen after approx 1 second).\")\n\t\t\ttime.Sleep(2 * sessionTTL3) // Wait long enough for lease to expire\n\t\t\tlog.Println(\"P1: Leadership should have expired by now (or P1 resigned).\")\n\t\t} else {\n\t\t\tlog.Printf(\"P1: Campaign ended with error or cancellation: %v\\n\", err)\n\t\t}\n\t}()\n\n\twg3.Add(1)\n\tgo func() {\n\t\tdefer wg3.Done()\n\t\ttime.Sleep(500 * time.Millisecond) // Let P1 become leader first\n\t\tlog.Println(\"P2: Campaigning for 'expiring-election'...\")\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx3, 5*time.Second) // Give enough time\n\t\tdefer campaignCancel()\n\n\t\terr := electionP2.Campaign(campaignCtx, \"P2-leader\")\n\t\tif err != nil && err != context.Canceled && err != ErrSessionInvalid {\n\t\t\tlog.Printf(\"P2 campaign error: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tif err == nil {\n\t\t\tlog.Println(\"P2: Successfully became leader after P1's expiration or resignation.\")\n\t\t\ttime.Sleep(1 * time.Second) // Hold for a moment\n\t\t} else {\n\t\t\tlog.Printf(\"P2: Campaign ended with error or cancellation: %v\\n\", err)\n\t\t}\n\t}()\n\n\twg3.Wait()\n\ttime.Sleep(50 * time.Millisecond)\n\tfinalLeaderExp, err := electionP1.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting final leader for 'expiring-election': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'expiring-election' after scenario 3: %q\\n\", finalLeaderExp)\n\t}\n\tlog.Println(\"\\n--- All test scenarios completed ---\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:594:8: declared and not used: observedVal"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:594:8: declared and not used: observedVal\n\n\nGolang errors in file: [/tmp/go_synthesis_lte03wul/main.go]:\n\n  > [line 594 : column 8] - declared and not used: observedVal\n\n\n\n[\u001b[37;40m/tmp/go_synthesis_lte03wul/main.go:574\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    573: \t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Context cancelled. Resigning...\\n\", e.key, e.session.ID(), currentKnownValue)\n  > 574: \t\t\te.Resign(context.Background())\n    575: \t\t\treturn ctx.Err()\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_lte03wul/main.go:426\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    425: \t\t\t// Context cancelled, best-effort resign if we became leader during this campaign.\n  > 426: \t\t\te.Resign(context.Background())\n    427: \t\t\treturn ctx.Err()\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 950\n  Nosec  : 0\n  Issues : \u001b[1;31m2\u001b[0m\n\n[gosec] 2025/12/01 12:35:20 Including rules: default\n[gosec] 2025/12/01 12:35:20 Excluding rules: default\n[gosec] 2025/12/01 12:35:20 Including analyzers: default\n[gosec] 2025/12/01 12:35:20 Excluding analyzers: default\n[gosec] 2025/12/01 12:35:20 Import directory: /tmp/go_synthesis_lte03wul\n[gosec] 2025/12/01 12:35:20 Checking package: main\n[gosec] 2025/12/01 12:35:20 Checking file: /tmp/go_synthesis_lte03wul/main.go"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_lte03wul/main.go:594:8: declared and not used: observedVal\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:594:8: declared and not used: observedVal /tmp/go_synthesis_lte03wul/main.go:594:8: declared and not used: observedVal]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:594:8: declared and not used: observedVal\n/tmp/go_synthesis_lte03wul/main.go:594:8: declared and not used: observedVal\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:594:8: declared and not used: observedVal (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// ErrKeyNotFound indicates that the requested key was not found in the store.\nvar ErrKeyNotFound = errors.New(\"key not found\")\n\n// ErrLeaseInvalid indicates that the lease associated with an operation is invalid or expired.\nvar ErrLeaseInvalid = errors.New(\"lease invalid\")\n\n// ErrCASFailed indicates that a compare-and-set operation failed due to a mismatch.\nvar ErrCASFailed = errors.New(\"compare-and-set failed\")\n\n// ErrSessionInvalid indicates that an election session is no longer active.\nvar ErrSessionInvalid = errors.New(\"election session is invalid\")\n\n// KVEntry represents a single key-value pair in the InMemoryKV store,\n// associating it with a lease ID.\ntype KVEntry struct {\n\tValue   string\n\tLeaseID string // The lease ID associated with this entry\n}\n\n// InMemoryKV is a simple in-memory key-value store with lease management and watch capabilities.\ntype InMemoryKV struct {\n\tmu            sync.RWMutex\n\tdata          map[string]KVEntry\n\twatchers      map[string]map[int]chan string // key -> watcherID -> channel\n\tnextWatcherID int\n\n\t// Lease Management\n\tactiveLeases     map[string]time.Time // leaseID -> expirationTime\n\tleaseTTL         time.Duration\n\tregisterLeaseCh  chan struct { leaseID string; ttl time.Duration }\n\tkeepAliveLeaseCh chan string\n\trevokeLeaseCh    chan string\n\texpirationTicker *time.Ticker\n\tstopLeaseManager chan struct{}\n\twgLeaseManager   sync.WaitGroup\n}\n\n// NewInMemoryKV creates and initializes a new InMemoryKV store.\n// sessionTTL defines the default time-to-live for sessions managed by this KV store.\nfunc NewInMemoryKV(sessionTTL time.Duration) *InMemoryKV {\n\tkv := &InMemoryKV{\n\t\tdata:             make(map[string]KVEntry),\n\t\twatchers:         make(map[string]map[int]chan string),\n\t\tactiveLeases:     make(map[string]time.Time),\n\t\tleaseTTL:         sessionTTL,\n\t\tregisterLeaseCh:  make(chan struct { leaseID string; ttl time.Duration }, 1), // Buffered for non-blocking send\n\t\tkeepAliveLeaseCh: make(chan string, 1), // Buffered for non-blocking send\n\t\trevokeLeaseCh:    make(chan string, 1), // Buffered for non-blocking send\n\t\texpirationTicker: time.NewTicker(sessionTTL / 5), // Check expiration more frequently than TTL\n\t\tstopLeaseManager: make(chan struct{}),\n\t}\n\tif kv.leaseTTL/5 == 0 { // Ensure ticker interval is not zero for very short TTLs\n\t\tkv.expirationTicker = time.NewTicker(50 * time.Millisecond)\n\t}\n\n\tkv.wgLeaseManager.Add(1)\n\tgo kv.runLeaseManager()\n\treturn kv\n}\n\n// Close gracefully shuts down the InMemoryKV store and its background goroutines.\nfunc (kv *InMemoryKV) Close() {\n\tclose(kv.stopLeaseManager)\n\tkv.wgLeaseManager.Wait() // Wait for lease manager to exit\n\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\t// Close all watcher channels\n\tfor _, keyWatchers := range kv.watchers {\n\t\tfor _, ch := range keyWatchers {\n\t\t\tclose(ch)\n\t\t}\n\t}\n\tkv.watchers = nil\n\tkv.data = nil\n\tkv.activeLeases = nil\n}\n\n// runLeaseManager is a background goroutine that manages lease expirations and updates.\nfunc (kv *InMemoryKV) runLeaseManager() {\n\tdefer kv.wgLeaseManager.Done()\n\tfor {\n\t\tselect {\n\t\tcase leaseIDTTL := <-kv.registerLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tkv.activeLeases[leaseIDTTL.leaseID] = time.Now().Add(leaseIDTTL.ttl)\n\t\t\tkv.mu.Unlock()\n\t\tcase leaseID := <-kv.keepAliveLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tif _, ok := kv.activeLeases[leaseID]; ok {\n\t\t\t\tkv.activeLeases[leaseID] = time.Now().Add(kv.leaseTTL)\n\t\t\t}\n\t\t\tkv.mu.Unlock()\n\t\tcase leaseID := <-kv.revokeLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tdelete(kv.activeLeases, leaseID)\n\t\t\t// Immediately delete associated KV entries and notify watchers\n\t\t\tkv.deleteEntriesByLeaseID(leaseID)\n\t\t\tkv.mu.Unlock()\n\t\tcase <-kv.expirationTicker.C:\n\t\t\tkv.mu.Lock()\n\t\t\tnow := time.Now()\n\t\t\tfor leaseID, expiry := range kv.activeLeases {\n\t\t\t\tif now.After(expiry) {\n\t\t\t\t\tdelete(kv.activeLeases, leaseID)\n\t\t\t\t\tkv.deleteEntriesByLeaseID(leaseID) // Delete associated entries and notify\n\t\t\t\t}\n\t\t\t}\n\t\t\tkv.mu.Unlock()\n\t\tcase <-kv.stopLeaseManager:\n\t\t\tkv.expirationTicker.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// RegisterLease registers a new lease with a given ID and TTL.\nfunc (kv *InMemoryKV) RegisterLease(leaseID string, ttl time.Duration) {\n\t// Non-blocking send, if channel is full it means lease manager is busy,\n\t// but it should catch up soon enough.\n\tselect {\n\tcase kv.registerLeaseCh <- struct { leaseID string; ttl time.Duration }{leaseID, ttl}:\n\tdefault:\n\t\tlog.Printf(\"Warning: RegisterLease channel full for %s\\n\", leaseID)\n\t}\n}\n\n// KeepLeaseAlive renews the expiration time for an existing lease.\nfunc (kv *InMemoryKV) KeepLeaseAlive(leaseID string) {\n\t// Non-blocking send\n\tselect {\n\tcase kv.keepAliveLeaseCh <- leaseID:\n\tdefault:\n\t\tlog.Printf(\"Warning: KeepLeaseAlive channel full for %s\\n\", leaseID)\n\t}\n}\n\n// RevokeLease immediately revokes a lease and deletes associated KV entries.\nfunc (kv *InMemoryKV) RevokeLease(leaseID string) {\n\t// Non-blocking send\n\tselect {\n\tcase kv.revokeLeaseCh <- leaseID:\n\tdefault:\n\t\tlog.Printf(\"Warning: RevokeLease channel full for %s\\n\", leaseID)\n\t}\n}\n\n// IsLeaseValid checks if a lease with the given ID is currently active.\nfunc (kv *InMemoryKV) IsLeaseValid(leaseID string) bool {\n\tif leaseID == \"\" {\n\t\treturn false // Empty lease ID is never valid\n\t}\n\tkv.mu.RLock()\n\tdefer kv.mu.RUnlock()\n\t_, ok := kv.activeLeases[leaseID]\n\treturn ok\n}\n\n// deleteEntriesByLeaseID must be called with kv.mu held.\n// It removes all KV entries associated with the given leaseID and notifies watchers.\nfunc (kv *InMemoryKV) deleteEntriesByLeaseID(leaseID string) {\n\tvar changedKeys []string\n\tfor k, entry := range kv.data {\n\t\tif entry.LeaseID == leaseID {\n\t\t\tdelete(kv.data, k)\n\t\t\tchangedKeys = append(changedKeys, k)\n\t\t}\n\t}\n\t// Notify watchers for the deleted keys\n\tfor _, k := range changedKeys {\n\t\tkv.notifyWatchers(k, \"\") // Send empty string for deletion\n\t}\n}\n\n// Put adds or updates a key-value pair with an associated lease ID.\n// The leaseID must be valid.\nfunc (kv *InMemoryKV) Put(key, value string, leaseID string) error {\n\tif !kv.IsLeaseValid(leaseID) {\n\t\treturn ErrLeaseInvalid\n\t}\n\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tkv.data[key] = KVEntry{Value: value, LeaseID: leaseID}\n\tkv.notifyWatchers(key, value)\n\treturn nil\n}\n\n// Get retrieves the value and lease ID for a given key.\n// Returns ErrKeyNotFound if the key does not exist.\nfunc (kv *InMemoryKV) Get(key string) (string, string, error) {\n\tkv.mu.RLock()\n\tdefer kv.mu.RUnlock()\n\n\tentry, ok := kv.data[key]\n\tif !ok {\n\t\treturn \"\", \"\", ErrKeyNotFound\n\t}\n\treturn entry.Value, entry.LeaseID, nil\n}\n\n// Delete removes a key-value pair. Returns ErrKeyNotFound if the key does not exist.\nfunc (kv *InMemoryKV) Delete(key string) error {\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tif _, ok := kv.data[key]; !ok {\n\t\treturn ErrKeyNotFound\n\t}\n\tdelete(kv.data, key)\n\tkv.notifyWatchers(key, \"\") // Notify with empty string for deletion\n\treturn nil\n}\n\n// CompareAndSet performs a transactional update.\n// If oldValue and oldLeaseID match the current entry (or are both empty for a new key),\n// the key's value and lease ID are updated to newValue and newLeaseID.\n// For deletion: set newValue and newLeaseID to empty strings.\n// Returns true on success, false on mismatch, or an error.\nfunc (kv *InMemoryKV) CompareAndSet(key, oldValue, newValue string, oldLeaseID, newLeaseID string) (bool, error) {\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tcurrentEntry, exists := kv.data[key]\n\n\t// Validate new lease ID if not a delete operation\n\tif newValue != \"\" && newLeaseID != \"\" && !kv.IsLeaseValid(newLeaseID) {\n\t\treturn false, ErrLeaseInvalid\n\t}\n\n\tif exists {\n\t\t// Key exists, check if old values match\n\t\tif currentEntry.Value != oldValue || currentEntry.LeaseID != oldLeaseID {\n\t\t\treturn false, nil // Mismatch, CAS failed\n\t\t}\n\t\t// Match, perform update or delete\n\t\tif newValue == \"\" && newLeaseID == \"\" { // It's a delete operation\n\t\t\tdelete(kv.data, key)\n\t\t\tkv.notifyWatchers(key, \"\")\n\t\t} else { // Update operation\n\t\t\tkv.data[key] = KVEntry{Value: newValue, LeaseID: newLeaseID}\n\t\t\tkv.notifyWatchers(key, newValue)\n\t\t}\n\t} else {\n\t\t// Key does not exist\n\t\tif oldValue != \"\" || oldLeaseID != \"\" {\n\t\t\treturn false, nil // Mismatch (expected existing key), CAS failed\n\t\t}\n\t\t// Key doesn't exist, and we expect it not to exist (oldValue/oldLeaseID are empty)\n\t\tif newValue == \"\" && newLeaseID == \"\" {\n\t\t\t// Trying to delete a non-existent key, consider it a success for CAS\n\t\t\treturn true, nil\n\t\t}\n\t\t// Create new entry\n\t\tkv.data[key] = KVEntry{Value: newValue, LeaseID: newLeaseID}\n\t\tkv.notifyWatchers(key, newValue)\n\t}\n\treturn true, nil\n}\n\n// Watch returns a channel that receives value updates for a specific key.\n// The channel will be closed when the context is cancelled or the KV store is closed.\n// It sends the current value for the key first, then subsequent changes.\nfunc (kv *InMemoryKV) Watch(ctx context.Context, key string) <-chan string {\n\tout := make(chan string, 1) // Buffered channel to not block initial send\n\n\tkv.mu.Lock()\n\twatcherID := kv.nextWatcherID\n\tkv.nextWatcherID++\n\tif _, ok := kv.watchers[key]; !ok {\n\t\tkv.watchers[key] = make(map[int]chan string)\n\t}\n\tkv.watchers[key][watcherID] = out\n\tkv.mu.Unlock()\n\n\t// Goroutine to remove watcher when context is cancelled\n\tgo func() {\n\t\tdefer func() {\n\t\t\tkv.mu.Lock()\n\t\t\tdefer kv.mu.Unlock()\n\t\t\tif keyWatchers, ok := kv.watchers[key]; ok {\n\t\t\t\tdelete(keyWatchers, watcherID)\n\t\t\t\tif len(keyWatchers) == 0 {\n\t\t\t\t\tdelete(kv.watchers, key)\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose(out) // Ensure the channel is closed\n\t\t}()\n\n\t\t// Send initial value if exists\n\t\tvalue, _, err := kv.Get(key)\n\t\tif err == nil {\n\t\t\tselect {\n\t\t\tcase out <- value:\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn // Context cancelled before sending initial value\n\t\t\t}\n\t\t} else if err == ErrKeyNotFound {\n\t\t\t// If key doesn't exist, send empty string initially to indicate no leader\n\t\t\tselect {\n\t\t\tcase out <- \"\":\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t<-ctx.Done() // Block until context is cancelled\n\t}()\n\n\treturn out\n}\n\n// notifyWatchers must be called with kv.mu held.\n// It sends a value update to all watchers whose keys match the key.\n// This also covers prefix watchers if implemented.\nfunc (kv *InMemoryKV) notifyWatchers(key, value string) {\n\t// Notify exact key watchers\n\tif watchers, ok := kv.watchers[key]; ok {\n\t\tfor _, ch := range watchers {\n\t\t\tselect {\n\t\t\tcase ch <- value:\n\t\t\tdefault:\n\t\t\t\t// Drop event if channel is full. Watchers are expected to keep up or handle buffering.\n\t\t\t}\n\t\t}\n\t}\n\t// For general prefix watching (not strictly required by current `Election.Observe` but good to have)\n\tfor watcherPrefix, watchersMap := range kv.watchers {\n\t\tif watcherPrefix != key && strings.HasPrefix(key, watcherPrefix) {\n\t\t\tfor _, ch := range watchersMap {\n\t\t\t\tselect {\n\t\t\t\tcase ch <- value:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Session represents a participant's connection or lease in the leader election system.\ntype Session struct {\n\tid          string\n\tleaseManager *InMemoryKV // Reference to the KV store for lease operations\n\tcancelCtx   context.CancelFunc // To signal session invalidation from outside\n\tctx         context.Context    // Context for session lifecycle\n}\n\n// NewSession creates a new session with a unique ID and registers it with the KV store's lease manager.\n// It also starts a background goroutine to periodically keep the lease alive.\nfunc NewSession(kv *InMemoryKV, ttl time.Duration) *Session {\n\tctx, cancel := context.WithCancel(context.Background())\n\ts := &Session{\n\t\tid:          uuid.New().String(),\n\t\tleaseManager: kv,\n\t\tcancelCtx:   cancel,\n\t\tctx:         ctx,\n\t}\n\tkv.RegisterLease(s.id, ttl)\n\tgo s.keepAliveLoop(ctx, ttl/2) // Renew lease at half the TTL\n\treturn s\n}\n\n// ID returns the unique identifier of the session.\nfunc (s *Session) ID() string {\n\treturn s.id\n}\n\n// IsAlive checks if the session is currently active.\nfunc (s *Session) IsAlive() bool {\n\treturn s.ctx.Err() == nil\n}\n\n// Close explicitly closes the session, revoking its lease and stopping its keep-alive loop.\nfunc (s *Session) Close() {\n\ts.cancelCtx()              // Signal the keep-alive loop to stop\n\ts.leaseManager.RevokeLease(s.id) // Unregister from the KV's lease manager\n}\n\n// keepAliveLoop periodically sends a keep-alive signal for the session's lease.\nfunc (s *Session) keepAliveLoop(ctx context.Context, renewInterval time.Duration) {\n\tticker := time.NewTicker(renewInterval)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done(): // Session explicitly closed or parent context cancelled\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\ts.leaseManager.KeepLeaseAlive(s.id)\n\t\t}\n\t}\n}\n\nconst leaderKeyPrefix = \"/election/\"\n\n// Election manages the leader election process for a specific election name.\ntype Election struct {\n\tsession  *Session\n\tkv       *InMemoryKV\n\tkey      string // The key in KV store representing this election (e.g., /election/my-election)\n\tleaderVal string // Cached leader value for current session if it IS leader\n\tisLeader bool   // Flag to indicate if this instance currently holds leadership\n\tmu       sync.Mutex // Protects isLeader, leaderVal\n}\n\n// NewElection creates a new Election instance.\nfunc NewElection(session *Session, kv *InMemoryKV, name string) *Election {\n\treturn &Election{\n\t\tsession: session,\n\t\tkv:      kv,\n\t\tkey:     leaderKeyPrefix + name,\n\t}\n}\n\n// Campaign attempts to become the leader with the given value.\n// It blocks until the participant becomes the leader, the context is cancelled, or the session expires.\nfunc (e *Election) Campaign(ctx context.Context, value string) error {\n\tif !e.session.IsAlive() {\n\t\treturn ErrSessionInvalid\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Context cancelled, best-effort resign if we became leader during this campaign.\n\t\t\te.mu.Lock()\n\t\t\twasLeader := e.isLeader\n\t\t\te.mu.Unlock()\n\t\t\tif wasLeader {\n\t\t\t\tif err := e.Resign(context.Background()); err != nil && err != context.Canceled {\n\t\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) Campaign error resigning on context cancel: %v\\n\", e.key, e.session.ID(), value, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ctx.Err()\n\t\tcase <-e.session.ctx.Done():\n\t\t\t// Session expired/closed, can no longer be leader.\n\t\t\treturn ErrSessionInvalid\n\t\tdefault:\n\t\t\tok, err := e.tryBecomeLeader(ctx, value)\n\t\t\tif err != nil {\n\t\t\t\tif err == ErrSessionInvalid {\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\t}\n\t\t\t\t// Log error and retry after a short backoff for transient issues.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) tryBecomeLeader error: %v. Retrying in 100ms.\\n\", e.key, e.session.ID(), value, err)\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done(): return ctx.Err()\n\t\t\t\tcase <-e.session.ctx.Done(): return ErrSessionInvalid\n\t\t\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ok {\n\t\t\t\t// We are now the leader.\n\t\t\t\te.mu.Lock()\n\t\t\t\te.isLeader = true\n\t\t\t\te.leaderVal = value\n\t\t\t\te.mu.Unlock()\n\t\t\t\tlog.Printf(\"Election %s Participant %s BECAME LEADER with value %q.\\n\", e.key, e.session.ID(), value)\n\n\t\t\t\t// Maintain leadership until context cancels, session invalidates, or explicit resign.\n\t\t\t\tmaintainErr := e.maintainLeadership(ctx, value)\n\n\t\t\t\t// Clear leadership status on exit from maintainLeadership.\n\t\t\t\te.mu.Lock()\n\t\t\t\te.isLeader = false\n\t\t\t\te.leaderVal = \"\"\n\t\t\t\te.mu.Unlock()\n\n\t\t\t\tif maintainErr == nil {\n\t\t\t\t\t// This implies a clean exit from maintainLeadership (e.g., due to a Resign call).\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif maintainErr == context.Canceled || maintainErr == context.DeadlineExceeded {\n\t\t\t\t\treturn ctx.Err()\n\t\t\t\t}\n\t\t\t\tif maintainErr == ErrSessionInvalid {\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\t}\n\t\t\t\t// If maintainErr is some other error, it means we lost leadership unexpectedly.\n\t\t\t\t// The loop should continue to try to regain leadership.\n\t\t\t\tlog.Printf(\"Election %s Participant %s LOST LEADERSHIP unexpectedly: %v. Retrying campaign.\\n\", e.key, e.session.ID(), maintainErr)\n\t\t\t} else {\n\t\t\t\t// Did not become leader (someone else is leader and their lease is valid).\n\t\t\t\t// Wait for a change in the leader key.\n\t\t\t\twatchCtx, watchCancel := context.WithCancel(ctx)\n\t\t\t\tleaderEvents := e.kv.Watch(watchCtx, e.key)\n\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) waiting for leader change...\\n\", e.key, e.session.ID(), value)\n\t\t\t\tselect {\n\t\t\t\tcase <-leaderEvents: // Removed observedVal\n\t\t\t\t\tlog.Printf(\"Election %s Participant %s detected leader change, re-campaigning.\\n\", e.key, e.session.ID())\n\t\t\t\t\twatchCancel()\n\t\t\t\t\t// Leader changed, loop will retry campaign immediately.\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\twatchCancel()\n\t\t\t\t\treturn ctx.Err()\n\t\t\t\tcase <-e.session.ctx.Done():\n\t\t\t\t\twatchCancel()\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\tcase <-time.After(e.kv.leaseTTL + time.Second): // Also re-check periodically if no watch event\n\t\t\t\t\twatchCancel()\n\t\t\t\t\tlog.Printf(\"Election %s Participant %s timed out waiting for leader change or lease expired, re-campaigning.\\n\", e.key, e.session.ID())\n\t\t\t\t\t// Loop will retry.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// tryBecomeLeader attempts to acquire leadership or update existing leadership for the session.\n// Returns true if the session becomes or successfully renews its leadership,\n// false if another valid leader exists, or an error on failure.\nfunc (e *Election) tryBecomeLeader(ctx context.Context, value string) (bool, error) {\n\tif !e.session.IsAlive() {\n\t\treturn false, ErrSessionInvalid\n\t}\n\n\tcurrentVal, currentLeaseID, err := e.kv.Get(e.key)\n\tif err != nil && err != ErrKeyNotFound {\n\t\treturn false, fmt.Errorf(\"failed to get current leader state: %w\", err)\n\t}\n\n\tif err == ErrKeyNotFound {\n\t\t// No leader, try to become one (compare-and-set with empty old values)\n\t\tok, casErr := e.kv.CompareAndSet(e.key, \"\", value, \"\", e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to become leader failed: %w\", casErr)\n\t\t}\n\t\treturn ok, nil // If ok is true, we are leader\n\t}\n\n\t// There is an existing leader entry\n\tif currentLeaseID == e.session.ID() {\n\t\t// We are already the leader (same session ID), update value and keep lease alive.\n\t\tok, casErr := e.kv.CompareAndSet(e.key, currentVal, value, e.session.ID(), e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to update leadership failed (we are current leader): %w\", casErr)\n\t\t}\n\t\treturn ok, nil\n\t}\n\n\t// Someone else is the leader. Check if their lease is valid.\n\tif !e.kv.IsLeaseValid(currentLeaseID) {\n\t\t// Current leader's lease is invalid, try to take over.\n\t\t// Use CAS to ensure we only take over if the current, invalid leader is still in place.\n\t\tok, casErr := e.kv.CompareAndSet(e.key, currentVal, value, currentLeaseID, e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to take over expired leadership failed: %w\", casErr)\n\t\t}\n\t\treturn ok, nil\n\t}\n\n\t// Someone else is leader and their lease is still valid.\n\treturn false, nil\n}\n\n// maintainLeadership periodically renews the leader's lease and monitors for leadership changes.\n// It returns nil if leadership was cleanly resigned by this instance,\n// context.Canceled if the provided ctx was cancelled,\n// ErrSessionInvalid if the session became invalid,\n// or an error if leadership was lost unexpectedly (e.g., taken over by another, or key deleted).\nfunc (e *Election) maintainLeadership(ctx context.Context, currentKnownValue string) error {\n\trenewInterval := e.kv.leaseTTL / 3\n\tif renewInterval < 100*time.Millisecond {\n\t\trenewInterval = 100 * time.Millisecond // Minimum for very short TTLs\n\t}\n\tticker := time.NewTicker(renewInterval)\n\tdefer ticker.Stop()\n\n\twatchCtx, watchCancel := context.WithCancel(ctx)\n\tdefer watchCancel()\n\tleaderEvents := e.kv.Watch(watchCtx, e.key)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Parent context cancelled, need to resign best-effort.\n\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Context cancelled. Resigning...\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\tif err := e.Resign(context.Background()); err != nil && err != context.Canceled {\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Error resigning on context cancel: %v\\n\", e.key, e.session.ID(), currentKnownValue, err)\n\t\t\t}\n\t\t\treturn ctx.Err()\n\t\tcase <-e.session.ctx.Done():\n\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Session invalid. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\treturn ErrSessionInvalid\n\t\tcase <-ticker.C:\n\t\t\t// Periodically re-assert leadership and keep lease alive.\n\t\t\t// This CAS acts as a heartbeart and ensures no one else has tampered with our key.\n\t\t\tok, casErr := e.kv.CompareAndSet(e.key, currentKnownValue, currentKnownValue, e.session.ID(), e.session.ID())\n\t\t\tif casErr != nil {\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: CAS failed during renewal: %v. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue, casErr)\n\t\t\t\treturn fmt.Errorf(\"lost leadership during renewal: %w\", casErr)\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\t// CAS returned false, meaning our oldValue/oldLeaseID didn't match what's in KV.\n\t\t\t\t// This implies leadership was taken over or deleted.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: CAS returned false during renewal. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\t\treturn errors.New(\"lost leadership during renewal due to CAS mismatch\")\n\t\t\t}\n\t\t\t// Leadership successfully renewed.\n\t\tcase <-leaderEvents: // Removed observedVal\n\t\t\t// A change was observed on our leader key.\n\t\t\t// Re-fetch state to confirm if leadership is still held by us.\n\t\t\tval, leaseID, err := e.kv.Get(e.key)\n\n\t\t\tif err == ErrKeyNotFound || leaseID != e.session.ID() || !e.kv.IsLeaseValid(leaseID) {\n\t\t\t\t// Our key was deleted, taken over by another, or our lease became invalid.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Observed change indicates leadership lost. Current: %q, LeaseID: %q, IsValid: %t, Err: %v\\n\",\n\t\t\t\t\te.key, e.session.ID(), currentKnownValue, val, leaseID, e.kv.IsLeaseValid(leaseID), err)\n\t\t\t\treturn errors.New(\"observed leadership loss or takeover\")\n\t\t\t}\n\n\t\t\t// We are still the leader, but the value might have been updated (e.g., by another Campaign call from the same session).\n\t\t\tif val != currentKnownValue {\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Observed leader value changed from %q to %q (same session update).\\n\", e.key, e.session.ID(), currentKnownValue, val)\n\t\t\t\te.mu.Lock()\n\t\t\t\te.leaderVal = val // Update cached leader value\n\t\t\t\te.mu.Unlock()\n\t\t\t\tcurrentKnownValue = val // Update for subsequent CAS operations\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Resign voluntarily steps down from leadership.\n// It will only succeed if the session is currently the leader.\nfunc (e *Election) Resign(ctx context.Context) error {\n\te.mu.Lock()\n\tisLeader := e.isLeader // Check if this instance believes it is leader\n\tleaderVal := e.leaderVal\n\te.mu.Unlock()\n\n\tif !isLeader {\n\t\treturn nil // Not leader, nothing to resign.\n\t}\n\tif !e.session.IsAlive() {\n\t\treturn ErrSessionInvalid\n\t}\n\n\t// Use CAS to delete the key ONLY if it's currently held by this session.\n\tok, err := e.kv.CompareAndSet(e.key, leaderVal, \"\", e.session.ID(), \"\") // newValue and newLeaseID empty for delete\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resign: %w\", err)\n\t}\n\tif !ok {\n\t\t// This means our leadership was already gone when we tried to resign (e.g., expired or taken over).\n\t\treturn fmt.Errorf(\"failed to resign: no longer leader when attempting CAS delete\")\n\t}\n\n\te.mu.Lock()\n\te.isLeader = false\n\te.leaderVal = \"\"\n\te.mu.Unlock()\n\tlog.Printf(\"Election %s Participant %s RESIGNED leadership.\\n\", e.key, e.session.ID())\n\treturn nil\n}\n\n// Leader returns the current leader's value.\n// It returns an empty string if there is no leader or the leader's lease is invalid.\nfunc (e *Election) Leader(ctx context.Context) (string, error) {\n\tval, leaseID, err := e.kv.Get(e.key)\n\tif err == ErrKeyNotFound {\n\t\treturn \"\", nil // No leader entry\n\t}\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to get leader: %w\", err)\n\t}\n\t// Even if there's an entry, check if its lease is valid\n\tif !e.kv.IsLeaseValid(leaseID) {\n\t\treturn \"\", nil // Lease expired, effectively no leader\n\t}\n\treturn val, nil\n}\n\n// Observe returns a channel that emits the current leader's value whenever it changes.\n// The channel will emit the current leader's value initially.\nfunc (e *Election) Observe(ctx context.Context) <-chan string {\n\tout := make(chan string)\n\tkvWatchCh := e.kv.Watch(ctx, e.key)\n\n\tgo func() {\n\t\tdefer close(out)\n\t\t// Send initial leader state\n\t\tcurrentLeader, err := e.Leader(ctx)\n\t\tif err == nil {\n\t\t\tselect {\n\t\t\tcase out <- currentLeader:\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\t// Log error but continue watching\n\t\t\tlog.Printf(\"Election %s Observer initial leader check error: %v\\n\", e.key, err)\n\t\t}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-kvWatchCh: // A change in the underlying key\n\t\t\t\tleaderVal, err := e.Leader(ctx) // Re-fetch current leader state\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Election %s Observer error getting leader after change: %v\\n\", e.key, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase out <- leaderVal:\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn out\n}\n\nfunc main() {\n\tlog.SetFlags(log.Ltime | log.Lmicroseconds)\n\n\t// --- Test Scenario 1: Same session, multiple elections for the same key ---\n\tlog.Println(\"\\n--- Test Scenario 1: Same session, multiple elections for the same key ---\")\n\tsessionTTL := 2 * time.Second\n\tkv := NewInMemoryKV(sessionTTL)\n\tdefer kv.Close()\n\n\tsession := NewSession(kv, sessionTTL)\n\tdefer session.Close()\n\n\telection1 := NewElection(session, kv, \"my-election\")\n\telection2 := NewElection(session, kv, \"my-election\")\n\n\tvar wg sync.WaitGroup\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Observer to watch changes for \"my-election\"\n\tleaderObserverCh := election1.Observe(ctx)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase val := <-leaderObserverCh:\n\t\t\t\tlog.Printf(\"[Observer for my-election] Current leader: %q\\n\", val)\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Println(\"Election 1: Campaigning with value1...\")\n\t\terr := election1.Campaign(ctx, \"value1\")\n\t\tif err != nil && err != context.Canceled {\n\t\t\tlog.Printf(\"Election 1 Campaign error: %v\\n\", err)\n\t\t} else if err == nil {\n\t\t\tlog.Println(\"Election 1: Campaign with value1 completed successfully (may have resigned or context cancelled).\")\n\t\t}\n\t}()\n\n\t// Give election1 a brief moment to establish leadership\n\ttime.Sleep(200 * time.Millisecond)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Println(\"Election 2: Campaigning with value2 (same session, same election name)...\")\n\t\terr := election2.Campaign(ctx, \"value2\")\n\t\tif err != nil && err != context.Canceled {\n\t\t\tlog.Printf(\"Election 2 Campaign error: %v\\n\", err)\n\t\t} else if err == nil {\n\t\t\tlog.Println(\"Election 2: Campaign with value2 completed successfully (value should have been updated).\")\n\t\t}\n\t}()\n\n\twg.Wait()\n\ttime.Sleep(50 * time.Millisecond) // Give observers time to react\n\tcurrentLeader, err := election1.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting leader for 'my-election': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'my-election' after scenario 1: %q (expected: value2)\\n\", currentLeader)\n\t}\n\n\t// --- Test Scenario 2: Three concurrent participants competing and resigning ---\n\tlog.Println(\"\\n--- Test Scenario 2: Three concurrent participants competing and resigning ---\")\n\tsessionTTL2 := 3 * time.Second\n\tkv2 := NewInMemoryKV(sessionTTL2)\n\tdefer kv2.Close()\n\n\tsessionA := NewSession(kv2, sessionTTL2)\n\tsessionB := NewSession(kv2, sessionTTL2)\n\tsessionC := NewSession(kv2, sessionTTL2)\n\tdefer sessionA.Close()\n\tdefer sessionB.Close()\n\tdefer sessionC.Close()\n\n\telectionA := NewElection(sessionA, kv2, \"test-election-compete\")\n\telectionB := NewElection(sessionB, kv2, \"test-election-compete\")\n\telectionC := NewElection(sessionC, kv2, \"test-election-compete\")\n\n\tvar wg2 sync.WaitGroup\n\tctx2, cancel2 := context.WithCancel(context.Background())\n\tdefer cancel2()\n\n\t// Observer for the competing election\n\tleaderCompeteObserverCh := electionA.Observe(ctx2)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase l := <-leaderCompeteObserverCh:\n\t\t\t\tlog.Printf(\"[Compete Observer] Leader for 'test-election-compete': %q\\n\", l)\n\t\t\tcase <-ctx2.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tcampaignAndResign := func(name string, election *Election, val string, holdDuration time.Duration) {\n\t\tdefer wg2.Done()\n\t\tlog.Printf(\"Participant %s: Trying to campaign with value %q...\\n\", name, val)\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx2, 10*time.Second) // Campaign for max 10s\n\t\tdefer campaignCancel()\n\n\t\terr := election.Campaign(campaignCtx, val)\n\t\tif err != nil && err != context.Canceled && err != context.DeadlineExceeded && err != ErrSessionInvalid {\n\t\t\tlog.Printf(\"Participant %s: Campaign for %q failed: %v\\n\", name, val, err)\n\t\t\treturn\n\t\t}\n\t\tif err == ErrSessionInvalid {\n\t\t\tlog.Printf(\"Participant %s: Campaign failed due to session invalid: %v\\n\", name, err)\n\t\t\treturn\n\t\t}\n\t\tif err == context.Canceled || err == context.DeadlineExceeded {\n\t\t\tlog.Printf(\"Participant %s: Campaign cancelled or timed out.\\n\", name)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Participant %s: IS THE LEADER with value %q! Holding for %v\\n\", name, val, holdDuration)\n\t\tselect {\n\t\tcase <-time.After(holdDuration):\n\t\t\t// Hold leadership for some time\n\t\tcase <-ctx2.Done():\n\t\t\tlog.Printf(\"Participant %s: Context cancelled while holding leadership.\\n\", name)\n\t\t\treturn\n\t\tcase <-election.session.ctx.Done():\n\t\t\tlog.Printf(\"Participant %s: Session invalid while holding leadership.\\n\", name)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Participant %s: Resigning leadership...\\n\", name)\n\t\tresignCtx, resignCancel := context.WithTimeout(context.Background(), 1*time.Second) // Resign with its own ctx\n\t\tdefer resignCancel()\n\t\tif err := election.Resign(resignCtx); err != nil {\n\t\t\tlog.Printf(\"Participant %s: Failed to resign: %v\\n\", name, err)\n\t\t} else {\n\t\t\tlog.Printf(\"Participant %s: Successfully resigned.\\n\", name)\n\t\t}\n\t}\n\n\twg2.Add(3)\n\tgo campaignAndResign(\"Alpha\", electionA, \"AlphaLeader\", 2*time.Second)\n\tgo campaignAndResign(\"Beta\", electionB, \"BetaLeader\", 2*time.Second)\n\tgo campaignAndResign(\"Gamma\", electionC, \"GammaLeader\", 2*time.Second)\n\n\twg2.Wait()\n\ttime.Sleep(50 * time.Millisecond)\n\tcurrentLeader2, err := electionA.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting final leader for 'test-election-compete': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'test-election-compete' after scenario 2: %q\\n\", currentLeader2)\n\t}\n\n\t// --- Test Scenario 3: Leader expiration leading to handover ---\n\tlog.Println(\"\\n--- Test Scenario 3: Leader expiration leading to handover ---\")\n\tsessionTTL3 := 1 * time.Second // Short TTL for demonstration\n\tkv3 := NewInMemoryKV(sessionTTL3)\n\tdefer kv3.Close()\n\n\tsessionP1 := NewSession(kv3, sessionTTL3)\n\tsessionP2 := NewSession(kv3, sessionTTL3)\n\tdefer sessionP1.Close()\n\tdefer sessionP2.Close()\n\n\telectionP1 := NewElection(sessionP1, kv3, \"expiring-election\")\n\telectionP2 := NewElection(sessionP2, kv3, \"expiring-election\")\n\n\tvar wg3 sync.WaitGroup\n\tctx3, cancel3 := context.WithCancel(context.Background())\n\tdefer cancel3()\n\n\t// Observer for expiration scenario\n\tleaderExpObserverCh := electionP1.Observe(ctx3)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase l := <-leaderExpObserverCh:\n\t\t\t\tlog.Printf(\"[Expiration Observer] Leader for 'expiring-election': %q\\n\", l)\n\t\t\tcase <-ctx3.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\twg3.Add(1)\n\tgo func() {\n\t\tdefer wg3.Done()\n\t\tlog.Println(\"P1: Campaigning for 'expiring-election'...\")\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx3, 5*time.Second) // Give enough time\n\t\tdefer campaignCancel()\n\n\t\terr := electionP1.Campaign(campaignCtx, \"P1-leader\")\n\t\tif err != nil && err != context.Canceled && err != context.DeadlineExceeded && err != ErrSessionInvalid {\n\t\t\tlog.Printf(\"P1 campaign error: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tif err == nil {\n\t\t\tlog.Println(\"P1: Is leader. Holding until session expires (should happen after approx 1 second).\")\n\t\t\ttime.Sleep(2 * sessionTTL3) // Wait long enough for lease to expire\n\t\t\tlog.Println(\"P1: Leadership should have expired by now (or P1 resigned).\")\n\t\t} else {\n\t\t\tlog.Printf(\"P1: Campaign ended with error or cancellation: %v\\n\", err)\n\t\t}\n\t}()\n\n\twg3.Add(1)\n\tgo func() {\n\t\tdefer wg3.Done()\n\t\ttime.Sleep(500 * time.Millisecond) // Let P1 become leader first\n\t\tlog.Println(\"P2: Campaigning for 'expiring-election'...\")\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx3, 5*time.Second) // Give enough time\n\t\tdefer campaignCancel()\n\n\t\terr := electionP2.Campaign(campaignCtx, \"P2-leader\")\n\t\tif err != nil && err != context.Canceled && err != context.DeadlineExceeded && err != ErrSessionInvalid {\n\t\t\tlog.Printf(\"P2 campaign error: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tif err == nil {\n\t\t\tlog.Println(\"P2: Successfully became leader after P1's expiration or resignation.\")\n\t\t\ttime.Sleep(1 * time.Second) // Hold for a moment\n\t\t} else {\n\t\t\tlog.Printf(\"P2: Campaign ended with error or cancellation: %v\\n\", err)\n\t\t}\n\t}()\n\n\twg3.Wait()\n\ttime.Sleep(50 * time.Millisecond)\n\tfinalLeaderExp, err := electionP1.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting final leader for 'expiring-election': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'expiring-election' after scenario 3: %q\\n\", finalLeaderExp)\n\t}\n\tlog.Println(\"\\n--- All test scenarios completed ---\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go-errorlint",
                    "error": "/tmp/go_synthesis_lte03wul/main.go:313:13: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:443:61: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:454:8: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:488:8: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:488:43: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:491:8: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:534:19: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:538:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:594:60: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:621:7: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:677:5: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:769:20: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:784:20: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:841:20: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:841:47: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:841:82: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:845:6: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:849:6: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:849:33: comparing with == will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:929:20: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:929:47: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:929:82: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:951:20: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:951:47: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_lte03wul/main.go:951:82: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// ErrKeyNotFound indicates that the requested key was not found in the store.\nvar ErrKeyNotFound = errors.New(\"key not found\")\n\n// ErrLeaseInvalid indicates that the lease associated with an operation is invalid or expired.\nvar ErrLeaseInvalid = errors.New(\"lease invalid\")\n\n// ErrCASFailed indicates that a compare-and-set operation failed due to a mismatch.\nvar ErrCASFailed = errors.New(\"compare-and-set failed\")\n\n// ErrSessionInvalid indicates that an election session is no longer active.\nvar ErrSessionInvalid = errors.New(\"election session is invalid\")\n\n// KVEntry represents a single key-value pair in the InMemoryKV store,\n// associating it with a lease ID.\ntype KVEntry struct {\n\tValue   string\n\tLeaseID string // The lease ID associated with this entry\n}\n\n// InMemoryKV is a simple in-memory key-value store with lease management and watch capabilities.\ntype InMemoryKV struct {\n\tmu            sync.RWMutex\n\tdata          map[string]KVEntry\n\twatchers      map[string]map[int]chan string // key -> watcherID -> channel\n\tnextWatcherID int\n\n\t// Lease Management\n\tactiveLeases     map[string]time.Time // leaseID -> expirationTime\n\tleaseTTL         time.Duration\n\tregisterLeaseCh  chan struct { leaseID string; ttl time.Duration }\n\tkeepAliveLeaseCh chan string\n\trevokeLeaseCh    chan string\n\texpirationTicker *time.Ticker\n\tstopLeaseManager chan struct{}\n\twgLeaseManager   sync.WaitGroup\n}\n\n// NewInMemoryKV creates and initializes a new InMemoryKV store.\n// sessionTTL defines the default time-to-live for sessions managed by this KV store.\nfunc NewInMemoryKV(sessionTTL time.Duration) *InMemoryKV {\n\tkv := &InMemoryKV{\n\t\tdata:             make(map[string]KVEntry),\n\t\twatchers:         make(map[string]map[int]chan string),\n\t\tactiveLeases:     make(map[string]time.Time),\n\t\tleaseTTL:         sessionTTL,\n\t\tregisterLeaseCh:  make(chan struct { leaseID string; ttl time.Duration }, 1), // Buffered for non-blocking send\n\t\tkeepAliveLeaseCh: make(chan string, 1), // Buffered for non-blocking send\n\t\trevokeLeaseCh:    make(chan string, 1), // Buffered for non-blocking send\n\t\texpirationTicker: time.NewTicker(sessionTTL / 5), // Check expiration more frequently than TTL\n\t\tstopLeaseManager: make(chan struct{}),\n\t}\n\tif kv.leaseTTL/5 == 0 { // Ensure ticker interval is not zero for very short TTLs\n\t\tkv.expirationTicker = time.NewTicker(50 * time.Millisecond)\n\t}\n\n\tkv.wgLeaseManager.Add(1)\n\tgo kv.runLeaseManager()\n\treturn kv\n}\n\n// Close gracefully shuts down the InMemoryKV store and its background goroutines.\nfunc (kv *InMemoryKV) Close() {\n\tclose(kv.stopLeaseManager)\n\tkv.wgLeaseManager.Wait() // Wait for lease manager to exit\n\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\t// Close all watcher channels\n\tfor _, keyWatchers := range kv.watchers {\n\t\tfor _, ch := range keyWatchers {\n\t\t\tclose(ch)\n\t\t}\n\t}\n\tkv.watchers = nil\n\tkv.data = nil\n\tkv.activeLeases = nil\n}\n\n// runLeaseManager is a background goroutine that manages lease expirations and updates.\nfunc (kv *InMemoryKV) runLeaseManager() {\n\tdefer kv.wgLeaseManager.Done()\n\tfor {\n\t\tselect {\n\t\tcase leaseIDTTL := <-kv.registerLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tkv.activeLeases[leaseIDTTL.leaseID] = time.Now().Add(leaseIDTTL.ttl)\n\t\t\tkv.mu.Unlock()\n\t\tcase leaseID := <-kv.keepAliveLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tif _, ok := kv.activeLeases[leaseID]; ok {\n\t\t\t\tkv.activeLeases[leaseID] = time.Now().Add(kv.leaseTTL)\n\t\t\t}\n\t\t\tkv.mu.Unlock()\n\t\tcase leaseID := <-kv.revokeLeaseCh:\n\t\t\tkv.mu.Lock()\n\t\t\tdelete(kv.activeLeases, leaseID)\n\t\t\t// Immediately delete associated KV entries and notify watchers\n\t\t\tkv.deleteEntriesByLeaseID(leaseID)\n\t\t\tkv.mu.Unlock()\n\t\tcase <-kv.expirationTicker.C:\n\t\t\tkv.mu.Lock()\n\t\t\tnow := time.Now()\n\t\t\tfor leaseID, expiry := range kv.activeLeases {\n\t\t\t\tif now.After(expiry) {\n\t\t\t\t\tdelete(kv.activeLeases, leaseID)\n\t\t\t\t\tkv.deleteEntriesByLeaseID(leaseID) // Delete associated entries and notify\n\t\t\t\t}\n\t\t\t}\n\t\t\tkv.mu.Unlock()\n\t\tcase <-kv.stopLeaseManager:\n\t\t\tkv.expirationTicker.Stop()\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// RegisterLease registers a new lease with a given ID and TTL.\nfunc (kv *InMemoryKV) RegisterLease(leaseID string, ttl time.Duration) {\n\t// Non-blocking send, if channel is full it means lease manager is busy,\n\t// but it should catch up soon enough.\n\tselect {\n\tcase kv.registerLeaseCh <- struct { leaseID string; ttl time.Duration }{leaseID, ttl}:\n\tdefault:\n\t\tlog.Printf(\"Warning: RegisterLease channel full for %s\\n\", leaseID)\n\t}\n}\n\n// KeepLeaseAlive renews the expiration time for an existing lease.\nfunc (kv *InMemoryKV) KeepLeaseAlive(leaseID string) {\n\t// Non-blocking send\n\tselect {\n\tcase kv.keepAliveLeaseCh <- leaseID:\n\tdefault:\n\t\tlog.Printf(\"Warning: KeepLeaseAlive channel full for %s\\n\", leaseID)\n\t}\n}\n\n// RevokeLease immediately revokes a lease and deletes associated KV entries.\nfunc (kv *InMemoryKV) RevokeLease(leaseID string) {\n\t// Non-blocking send\n\tselect {\n\tcase kv.revokeLeaseCh <- leaseID:\n\tdefault:\n\t\tlog.Printf(\"Warning: RevokeLease channel full for %s\\n\", leaseID)\n\t}\n}\n\n// IsLeaseValid checks if a lease with the given ID is currently active.\nfunc (kv *InMemoryKV) IsLeaseValid(leaseID string) bool {\n\tif leaseID == \"\" {\n\t\treturn false // Empty lease ID is never valid\n\t}\n\tkv.mu.RLock()\n\tdefer kv.mu.RUnlock()\n\t_, ok := kv.activeLeases[leaseID]\n\treturn ok\n}\n\n// deleteEntriesByLeaseID must be called with kv.mu held.\n// It removes all KV entries associated with the given leaseID and notifies watchers.\nfunc (kv *InMemoryKV) deleteEntriesByLeaseID(leaseID string) {\n\tvar changedKeys []string\n\tfor k, entry := range kv.data {\n\t\tif entry.LeaseID == leaseID {\n\t\t\tdelete(kv.data, k)\n\t\t\tchangedKeys = append(changedKeys, k)\n\t\t}\n\t}\n\t// Notify watchers for the deleted keys\n\tfor _, k := range changedKeys {\n\t\tkv.notifyWatchers(k, \"\") // Send empty string for deletion\n\t}\n}\n\n// Put adds or updates a key-value pair with an associated lease ID.\n// The leaseID must be valid.\nfunc (kv *InMemoryKV) Put(key, value string, leaseID string) error {\n\tif !kv.IsLeaseValid(leaseID) {\n\t\treturn ErrLeaseInvalid\n\t}\n\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tkv.data[key] = KVEntry{Value: value, LeaseID: leaseID}\n\tkv.notifyWatchers(key, value)\n\treturn nil\n}\n\n// Get retrieves the value and lease ID for a given key.\n// Returns ErrKeyNotFound if the key does not exist.\nfunc (kv *InMemoryKV) Get(key string) (string, string, error) {\n\tkv.mu.RLock()\n\tdefer kv.mu.RUnlock()\n\n\tentry, ok := kv.data[key]\n\tif !ok {\n\t\treturn \"\", \"\", ErrKeyNotFound\n\t}\n\treturn entry.Value, entry.LeaseID, nil\n}\n\n// Delete removes a key-value pair. Returns ErrKeyNotFound if the key does not exist.\nfunc (kv *InMemoryKV) Delete(key string) error {\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tif _, ok := kv.data[key]; !ok {\n\t\treturn ErrKeyNotFound\n\t}\n\tdelete(kv.data, key)\n\tkv.notifyWatchers(key, \"\") // Notify with empty string for deletion\n\treturn nil\n}\n\n// CompareAndSet performs a transactional update.\n// If oldValue and oldLeaseID match the current entry (or are both empty for a new key),\n// the key's value and lease ID are updated to newValue and newLeaseID.\n// For deletion: set newValue and newLeaseID to empty strings.\n// Returns true on success, false on mismatch, or an error.\nfunc (kv *InMemoryKV) CompareAndSet(key, oldValue, newValue string, oldLeaseID, newLeaseID string) (bool, error) {\n\tkv.mu.Lock()\n\tdefer kv.mu.Unlock()\n\n\tcurrentEntry, exists := kv.data[key]\n\n\t// Validate new lease ID if not a delete operation\n\tif newValue != \"\" && newLeaseID != \"\" && !kv.IsLeaseValid(newLeaseID) {\n\t\treturn false, ErrLeaseInvalid\n\t}\n\n\tif exists {\n\t\t// Key exists, check if old values match\n\t\tif currentEntry.Value != oldValue || currentEntry.LeaseID != oldLeaseID {\n\t\t\treturn false, nil // Mismatch, CAS failed\n\t\t}\n\t\t// Match, perform update or delete\n\t\tif newValue == \"\" && newLeaseID == \"\" { // It's a delete operation\n\t\t\tdelete(kv.data, key)\n\t\t\tkv.notifyWatchers(key, \"\")\n\t\t} else { // Update operation\n\t\t\tkv.data[key] = KVEntry{Value: newValue, LeaseID: newLeaseID}\n\t\t\tkv.notifyWatchers(key, newValue)\n\t\t}\n\t} else {\n\t\t// Key does not exist\n\t\tif oldValue != \"\" || oldLeaseID != \"\" {\n\t\t\treturn false, nil // Mismatch (expected existing key), CAS failed\n\t\t}\n\t\t// Key doesn't exist, and we expect it not to exist (oldValue/oldLeaseID are empty)\n\t\tif newValue == \"\" && newLeaseID == \"\" {\n\t\t\t// Trying to delete a non-existent key, consider it a success for CAS\n\t\t\treturn true, nil\n\t\t}\n\t\t// Create new entry\n\t\tkv.data[key] = KVEntry{Value: newValue, LeaseID: newLeaseID}\n\t\tkv.notifyWatchers(key, newValue)\n\t}\n\treturn true, nil\n}\n\n// Watch returns a channel that receives value updates for a specific key.\n// The channel will be closed when the context is cancelled or the KV store is closed.\n// It sends the current value for the key first, then subsequent changes.\nfunc (kv *InMemoryKV) Watch(ctx context.Context, key string) <-chan string {\n\tout := make(chan string, 1) // Buffered channel to not block initial send\n\n\tkv.mu.Lock()\n\twatcherID := kv.nextWatcherID\n\tkv.nextWatcherID++\n\tif _, ok := kv.watchers[key]; !ok {\n\t\tkv.watchers[key] = make(map[int]chan string)\n\t}\n\tkv.watchers[key][watcherID] = out\n\tkv.mu.Unlock()\n\n\t// Goroutine to remove watcher when context is cancelled\n\tgo func() {\n\t\tdefer func() {\n\t\t\tkv.mu.Lock()\n\t\t\tdefer kv.mu.Unlock()\n\t\t\tif keyWatchers, ok := kv.watchers[key]; ok {\n\t\t\t\tdelete(keyWatchers, watcherID)\n\t\t\t\tif len(keyWatchers) == 0 {\n\t\t\t\t\tdelete(kv.watchers, key)\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose(out) // Ensure the channel is closed\n\t\t}()\n\n\t\t// Send initial value if exists\n\t\tvalue, _, err := kv.Get(key)\n\t\tif err == nil {\n\t\t\tselect {\n\t\t\tcase out <- value:\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn // Context cancelled before sending initial value\n\t\t\t}\n\t\t} else if errors.Is(err, ErrKeyNotFound) {\n\t\t\t// If key doesn't exist, send empty string initially to indicate no leader\n\t\t\tselect {\n\t\t\tcase out <- \"\":\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\t<-ctx.Done() // Block until context is cancelled\n\t}()\n\n\treturn out\n}\n\n// notifyWatchers must be called with kv.mu held.\n// It sends a value update to all watchers whose keys match the key.\n// This also covers prefix watchers if implemented.\nfunc (kv *InMemoryKV) notifyWatchers(key, value string) {\n\t// Notify exact key watchers\n\tif watchers, ok := kv.watchers[key]; ok {\n\t\tfor _, ch := range watchers {\n\t\t\tselect {\n\t\t\tcase ch <- value:\n\t\t\tdefault:\n\t\t\t\t// Drop event if channel is full. Watchers are expected to keep up or handle buffering.\n\t\t\t}\n\t\t}\n\t}\n\t// For general prefix watching (not strictly required by current `Election.Observe` but good to have)\n\tfor watcherPrefix, watchersMap := range kv.watchers {\n\t\tif watcherPrefix != key && strings.HasPrefix(key, watcherPrefix) {\n\t\t\tfor _, ch := range watchersMap {\n\t\t\t\tselect {\n\t\t\t\tcase ch <- value:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Session represents a participant's connection or lease in the leader election system.\ntype Session struct {\n\tid          string\n\tleaseManager *InMemoryKV // Reference to the KV store for lease operations\n\tcancelCtx   context.CancelFunc // To signal session invalidation from outside\n\tctx         context.Context    // Context for session lifecycle\n}\n\n// NewSession creates a new session with a unique ID and registers it with the KV store's lease manager.\n// It also starts a background goroutine to periodically keep the lease alive.\nfunc NewSession(kv *InMemoryKV, ttl time.Duration) *Session {\n\tctx, cancel := context.WithCancel(context.Background())\n\ts := &Session{\n\t\tid:          uuid.New().String(),\n\t\tleaseManager: kv,\n\t\tcancelCtx:   cancel,\n\t\tctx:         ctx,\n\t}\n\tkv.RegisterLease(s.id, ttl)\n\tgo s.keepAliveLoop(ctx, ttl/2) // Renew lease at half the TTL\n\treturn s\n}\n\n// ID returns the unique identifier of the session.\nfunc (s *Session) ID() string {\n\treturn s.id\n}\n\n// IsAlive checks if the session is currently active.\nfunc (s *Session) IsAlive() bool {\n\treturn s.ctx.Err() == nil\n}\n\n// Close explicitly closes the session, revoking its lease and stopping its keep-alive loop.\nfunc (s *Session) Close() {\n\ts.cancelCtx()              // Signal the keep-alive loop to stop\n\ts.leaseManager.RevokeLease(s.id) // Unregister from the KV's lease manager\n}\n\n// keepAliveLoop periodically sends a keep-alive signal for the session's lease.\nfunc (s *Session) keepAliveLoop(ctx context.Context, renewInterval time.Duration) {\n\tticker := time.NewTicker(renewInterval)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done(): // Session explicitly closed or parent context cancelled\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\ts.leaseManager.KeepLeaseAlive(s.id)\n\t\t}\n\t}\n}\n\nconst leaderKeyPrefix = \"/election/\"\n\n// Election manages the leader election process for a specific election name.\ntype Election struct {\n\tsession  *Session\n\tkv       *InMemoryKV\n\tkey      string // The key in KV store representing this election (e.g., /election/my-election)\n\tleaderVal string // Cached leader value for current session if it IS leader\n\tisLeader bool   // Flag to indicate if this instance currently holds leadership\n\tmu       sync.Mutex // Protects isLeader, leaderVal\n}\n\n// NewElection creates a new Election instance.\nfunc NewElection(session *Session, kv *InMemoryKV, name string) *Election {\n\treturn &Election{\n\t\tsession: session,\n\t\tkv:      kv,\n\t\tkey:     leaderKeyPrefix + name,\n\t}\n}\n\n// Campaign attempts to become the leader with the given value.\n// It blocks until the participant becomes the leader, the context is cancelled, or the session expires.\nfunc (e *Election) Campaign(ctx context.Context, value string) error {\n\tif !e.session.IsAlive() {\n\t\treturn ErrSessionInvalid\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Context cancelled, best-effort resign if we became leader during this campaign.\n\t\t\te.mu.Lock()\n\t\t\twasLeader := e.isLeader\n\t\t\te.mu.Unlock()\n\t\t\tif wasLeader {\n\t\t\t\tif err := e.Resign(context.Background()); err != nil && !errors.Is(err, context.Canceled) { // Fix: use errors.Is\n\t\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) Campaign error resigning on context cancel: %v\\n\", e.key, e.session.ID(), value, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ctx.Err()\n\t\tcase <-e.session.ctx.Done():\n\t\t\t// Session expired/closed, can no longer be leader.\n\t\t\treturn ErrSessionInvalid\n\t\tdefault:\n\t\t\tok, err := e.tryBecomeLeader(ctx, value)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, ErrSessionInvalid) { // Fix: use errors.Is\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\t}\n\t\t\t\t// Log error and retry after a short backoff for transient issues.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) tryBecomeLeader error: %v. Retrying in 100ms.\\n\", e.key, e.session.ID(), value, err)\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done(): return ctx.Err()\n\t\t\t\tcase <-e.session.ctx.Done(): return ErrSessionInvalid\n\t\t\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ok {\n\t\t\t\t// We are now the leader.\n\t\t\t\te.mu.Lock()\n\t\t\t\te.isLeader = true\n\t\t\t\te.leaderVal = value\n\t\t\t\te.mu.Unlock()\n\t\t\t\tlog.Printf(\"Election %s Participant %s BECAME LEADER with value %q.\\n\", e.key, e.session.ID(), value)\n\n\t\t\t\t// Maintain leadership until context cancels, session invalidates, or explicit resign.\n\t\t\t\tmaintainErr := e.maintainLeadership(ctx, value)\n\n\t\t\t\t// Clear leadership status on exit from maintainLeadership.\n\t\t\t\te.mu.Lock()\n\t\t\t\te.isLeader = false\n\t\t\t\te.leaderVal = \"\"\n\t\t\t\te.mu.Unlock()\n\n\t\t\t\tif maintainErr == nil {\n\t\t\t\t\t// This implies a clean exit from maintainLeadership (e.g., due to a Resign call).\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif errors.Is(maintainErr, context.Canceled) || errors.Is(maintainErr, context.DeadlineExceeded) { // Fix: use errors.Is\n\t\t\t\t\treturn ctx.Err()\n\t\t\t\t}\n\t\t\t\tif errors.Is(maintainErr, ErrSessionInvalid) { // Fix: use errors.Is\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\t}\n\t\t\t\t// If maintainErr is some other error, it means we lost leadership unexpectedly.\n\t\t\t\t// The loop should continue to try to regain leadership.\n\t\t\t\tlog.Printf(\"Election %s Participant %s LOST LEADERSHIP unexpectedly: %v. Retrying campaign.\\n\", e.key, e.session.ID(), maintainErr)\n\t\t\t} else {\n\t\t\t\t// Did not become leader (someone else is leader and their lease is valid).\n\t\t\t\t// Wait for a change in the leader key.\n\t\t\t\twatchCtx, watchCancel := context.WithCancel(ctx)\n\t\t\t\tleaderEvents := e.kv.Watch(watchCtx, e.key)\n\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) waiting for leader change...\\n\", e.key, e.session.ID(), value)\n\t\t\t\tselect {\n\t\t\t\tcase <-leaderEvents: // Removed observedVal\n\t\t\t\t\tlog.Printf(\"Election %s Participant %s detected leader change, re-campaigning.\\n\", e.key, e.session.ID())\n\t\t\t\t\twatchCancel()\n\t\t\t\t\t// Leader changed, loop will retry campaign immediately.\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\twatchCancel()\n\t\t\t\t\treturn ctx.Err()\n\t\t\t\tcase <-e.session.ctx.Done():\n\t\t\t\t\twatchCancel()\n\t\t\t\t\treturn ErrSessionInvalid\n\t\t\t\tcase <-time.After(e.kv.leaseTTL + time.Second): // Also re-check periodically if no watch event\n\t\t\t\t\twatchCancel()\n\t\t\t\t\tlog.Printf(\"Election %s Participant %s timed out waiting for leader change or lease expired, re-campaigning.\\n\", e.key, e.session.ID())\n\t\t\t\t\t// Loop will retry.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// tryBecomeLeader attempts to acquire leadership or update existing leadership for the session.\n// Returns true if the session becomes or successfully renews its leadership,\n// false if another valid leader exists, or an error on failure.\nfunc (e *Election) tryBecomeLeader(ctx context.Context, value string) (bool, error) {\n\tif !e.session.IsAlive() {\n\t\treturn false, ErrSessionInvalid\n\t}\n\n\tcurrentVal, currentLeaseID, err := e.kv.Get(e.key)\n\tif err != nil && !errors.Is(err, ErrKeyNotFound) { // Fix: use errors.Is\n\t\treturn false, fmt.Errorf(\"failed to get current leader state: %w\", err)\n\t}\n\n\tif errors.Is(err, ErrKeyNotFound) { // Fix: use errors.Is\n\t\t// No leader, try to become one (compare-and-set with empty old values)\n\t\tok, casErr := e.kv.CompareAndSet(e.key, \"\", value, \"\", e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to become leader failed: %w\", casErr)\n\t\t}\n\t\treturn ok, nil // If ok is true, we are leader\n\t}\n\n\t// There is an existing leader entry\n\tif currentLeaseID == e.session.ID() {\n\t\t// We are already the leader (same session ID), update value and keep lease alive.\n\t\tok, casErr := e.kv.CompareAndSet(e.key, currentVal, value, e.session.ID(), e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to update leadership failed (we are current leader): %w\", casErr)\n\t\t}\n\t\treturn ok, nil\n\t}\n\n\t// Someone else is the leader. Check if their lease is valid.\n\tif !e.kv.IsLeaseValid(currentLeaseID) {\n\t\t// Current leader's lease is invalid, try to take over.\n\t\t// Use CAS to ensure we only take over if the current, invalid leader is still in place.\n\t\tok, casErr := e.kv.CompareAndSet(e.key, currentVal, value, currentLeaseID, e.session.ID())\n\t\tif casErr != nil {\n\t\t\treturn false, fmt.Errorf(\"CAS to take over expired leadership failed: %w\", casErr)\n\t\t}\n\t\treturn ok, nil\n\t}\n\n\t// Someone else is leader and their lease is still valid.\n\treturn false, nil\n}\n\n// maintainLeadership periodically renews the leader's lease and monitors for leadership changes.\n// It returns nil if leadership was cleanly resigned by this instance,\n// context.Canceled if the provided ctx was cancelled,\n// ErrSessionInvalid if the session became invalid,\n// or an error if leadership was lost unexpectedly (e.g., taken over by another, or key deleted).\nfunc (e *Election) maintainLeadership(ctx context.Context, currentKnownValue string) error {\n\trenewInterval := e.kv.leaseTTL / 3\n\tif renewInterval < 100*time.Millisecond {\n\t\trenewInterval = 100 * time.Millisecond // Minimum for very short TTLs\n\t}\n\tticker := time.NewTicker(renewInterval)\n\tdefer ticker.Stop()\n\n\twatchCtx, watchCancel := context.WithCancel(ctx)\n\tdefer watchCancel()\n\tleaderEvents := e.kv.Watch(watchCtx, e.key)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Parent context cancelled, need to resign best-effort.\n\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Context cancelled. Resigning...\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\tif err := e.Resign(context.Background()); err != nil && !errors.Is(err, context.Canceled) { // Fix: use errors.Is\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Error resigning on context cancel: %v\\n\", e.key, e.session.ID(), currentKnownValue, err)\n\t\t\t}\n\t\t\treturn ctx.Err()\n\t\tcase <-e.session.ctx.Done():\n\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Session invalid. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\treturn ErrSessionInvalid\n\t\tcase <-ticker.C:\n\t\t\t// Periodically re-assert leadership and keep lease alive.\n\t\t\t// This CAS acts as a heartbeart and ensures no one else has tampered with our key.\n\t\t\tok, casErr := e.kv.CompareAndSet(e.key, currentKnownValue, currentKnownValue, e.session.ID(), e.session.ID())\n\t\t\tif casErr != nil {\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: CAS failed during renewal: %v. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue, casErr)\n\t\t\t\treturn fmt.Errorf(\"lost leadership during renewal: %w\", casErr)\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\t// CAS returned false, meaning our oldValue/oldLeaseID didn't match what's in KV.\n\t\t\t\t// This implies leadership was taken over or deleted.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: CAS returned false during renewal. Leadership lost.\\n\", e.key, e.session.ID(), currentKnownValue)\n\t\t\t\treturn errors.New(\"lost leadership during renewal due to CAS mismatch\")\n\t\t\t}\n\t\t\t// Leadership successfully renewed.\n\t\tcase <-leaderEvents: // Removed observedVal\n\t\t\t// A change was observed on our leader key.\n\t\t\t// Re-fetch state to confirm if leadership is still held by us.\n\t\t\tval, leaseID, err := e.kv.Get(e.key)\n\n\t\t\tif errors.Is(err, ErrKeyNotFound) || leaseID != e.session.ID() || !e.kv.IsLeaseValid(leaseID) { // Fix: use errors.Is\n\t\t\t\t// Our key was deleted, taken over by another, or our lease became invalid.\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Observed change indicates leadership lost. Current: %q, LeaseID: %q, IsValid: %t, Err: %v\\n\",\n\t\t\t\t\te.key, e.session.ID(), currentKnownValue, val, leaseID, e.kv.IsLeaseValid(leaseID), err)\n\t\t\t\treturn errors.New(\"observed leadership loss or takeover\")\n\t\t\t}\n\n\t\t\t// We are still the leader, but the value might have been updated (e.g., by another Campaign call from the same session).\n\t\t\tif val != currentKnownValue {\n\t\t\t\tlog.Printf(\"Election %s Participant %s (val %q) MAINTAIN: Observed leader value changed from %q to %q (same session update).\\n\", e.key, e.session.ID(), currentKnownValue, val)\n\t\t\t\te.mu.Lock()\n\t\t\t\te.leaderVal = val // Update cached leader value\n\t\t\t\te.mu.Unlock()\n\t\t\t\tcurrentKnownValue = val // Update for subsequent CAS operations\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Resign voluntarily steps down from leadership.\n// It will only succeed if the session is currently the leader.\nfunc (e *Election) Resign(ctx context.Context) error {\n\te.mu.Lock()\n\tisLeader := e.isLeader // Check if this instance believes it is leader\n\tleaderVal := e.leaderVal\n\te.mu.Unlock()\n\n\tif !isLeader {\n\t\treturn nil // Not leader, nothing to resign.\n\t}\n\tif !e.session.IsAlive() {\n\t\treturn ErrSessionInvalid\n\t}\n\n\t// Use CAS to delete the key ONLY if it's currently held by this session.\n\tok, err := e.kv.CompareAndSet(e.key, leaderVal, \"\", e.session.ID(), \"\") // newValue and newLeaseID empty for delete\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resign: %w\", err)\n\t}\n\tif !ok {\n\t\t// This means our leadership was already gone when we tried to resign (e.g., expired or taken over).\n\t\treturn fmt.Errorf(\"failed to resign: no longer leader when attempting CAS delete\")\n\t}\n\n\te.mu.Lock()\n\te.isLeader = false\n\te.leaderVal = \"\"\n\te.mu.Unlock()\n\tlog.Printf(\"Election %s Participant %s RESIGNED leadership.\\n\", e.key, e.session.ID())\n\treturn nil\n}\n\n// Leader returns the current leader's value.\n// It returns an empty string if there is no leader or the leader's lease is invalid.\nfunc (e *Election) Leader(ctx context.Context) (string, error) {\n\tval, leaseID, err := e.kv.Get(e.key)\n\tif errors.Is(err, ErrKeyNotFound) { // Fix: use errors.Is\n\t\treturn \"\", nil // No leader entry\n\t}\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to get leader: %w\", err)\n\t}\n\t// Even if there's an entry, check if its lease is valid\n\tif !e.kv.IsLeaseValid(leaseID) {\n\t\treturn \"\", nil // Lease expired, effectively no leader\n\t}\n\treturn val, nil\n}\n\n// Observe returns a channel that emits the current leader's value whenever it changes.\n// The channel will emit the current leader's value initially.\nfunc (e *Election) Observe(ctx context.Context) <-chan string {\n\tout := make(chan string)\n\tkvWatchCh := e.kv.Watch(ctx, e.key)\n\n\tgo func() {\n\t\tdefer close(out)\n\t\t// Send initial leader state\n\t\tcurrentLeader, err := e.Leader(ctx)\n\t\tif err == nil {\n\t\t\tselect {\n\t\t\tcase out <- currentLeader:\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t} else {\n\t\t\t// Log error but continue watching\n\t\t\tlog.Printf(\"Election %s Observer initial leader check error: %v\\n\", e.key, err)\n\t\t}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-kvWatchCh: // A change in the underlying key\n\t\t\t\tleaderVal, err := e.Leader(ctx) // Re-fetch current leader state\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Election %s Observer error getting leader after change: %v\\n\", e.key, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tselect {\n\t\t\t\tcase out <- leaderVal:\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn out\n}\n\nfunc main() {\n\tlog.SetFlags(log.Ltime | log.Lmicroseconds)\n\n\t// --- Test Scenario 1: Same session, multiple elections for the same key ---\n\tlog.Println(\"\\n--- Test Scenario 1: Same session, multiple elections for the same key ---\")\n\tsessionTTL := 2 * time.Second\n\tkv := NewInMemoryKV(sessionTTL)\n\tdefer kv.Close()\n\n\tsession := NewSession(kv, sessionTTL)\n\tdefer session.Close()\n\n\telection1 := NewElection(session, kv, \"my-election\")\n\telection2 := NewElection(session, kv, \"my-election\")\n\n\tvar wg sync.WaitGroup\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Observer to watch changes for \"my-election\"\n\tleaderObserverCh := election1.Observe(ctx)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase val := <-leaderObserverCh:\n\t\t\t\tlog.Printf(\"[Observer for my-election] Current leader: %q\\n\", val)\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Println(\"Election 1: Campaigning with value1...\")\n\t\terr := election1.Campaign(ctx, \"value1\")\n\t\tif err != nil && !errors.Is(err, context.Canceled) { // Fix: use errors.Is\n\t\t\tlog.Printf(\"Election 1 Campaign error: %v\\n\", err)\n\t\t} else if err == nil {\n\t\t\tlog.Println(\"Election 1: Campaign with value1 completed successfully (may have resigned or context cancelled).\")\n\t\t}\n\t}()\n\n\t// Give election1 a brief moment to establish leadership\n\ttime.Sleep(200 * time.Millisecond)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Println(\"Election 2: Campaigning with value2 (same session, same election name)...\")\n\t\terr := election2.Campaign(ctx, \"value2\")\n\t\tif err != nil && !errors.Is(err, context.Canceled) { // Fix: use errors.Is\n\t\t\tlog.Printf(\"Election 2 Campaign error: %v\\n\", err)\n\t\t} else if err == nil {\n\t\t\tlog.Println(\"Election 2: Campaign with value2 completed successfully (value should have been updated).\")\n\t\t}\n\t}()\n\n\twg.Wait()\n\ttime.Sleep(50 * time.Millisecond) // Give observers time to react\n\tcurrentLeader, err := election1.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting leader for 'my-election': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'my-election' after scenario 1: %q (expected: value2)\\n\", currentLeader)\n\t}\n\n\t// --- Test Scenario 2: Three concurrent participants competing and resigning ---\n\tlog.Println(\"\\n--- Test Scenario 2: Three concurrent participants competing and resigning ---\")\n\tsessionTTL2 := 3 * time.Second\n\tkv2 := NewInMemoryKV(sessionTTL2)\n\tdefer kv2.Close()\n\n\tsessionA := NewSession(kv2, sessionTTL2)\n\tsessionB := NewSession(kv2, sessionTTL2)\n\tsessionC := NewSession(kv2, sessionTTL2)\n\tdefer sessionA.Close()\n\tdefer sessionB.Close()\n\tdefer sessionC.Close()\n\n\telectionA := NewElection(sessionA, kv2, \"test-election-compete\")\n\telectionB := NewElection(sessionB, kv2, \"test-election-compete\")\n\telectionC := NewElection(sessionC, kv2, \"test-election-compete\")\n\n\tvar wg2 sync.WaitGroup\n\tctx2, cancel2 := context.WithCancel(context.Background())\n\tdefer cancel2()\n\n\t// Observer for the competing election\n\tleaderCompeteObserverCh := electionA.Observe(ctx2)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase l := <-leaderCompeteObserverCh:\n\t\t\t\tlog.Printf(\"[Compete Observer] Leader for 'test-election-compete': %q\\n\", l)\n\t\t\tcase <-ctx2.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tcampaignAndResign := func(name string, election *Election, val string, holdDuration time.Duration) {\n\t\tdefer wg2.Done()\n\t\tlog.Printf(\"Participant %s: Trying to campaign with value %q...\\n\", name, val)\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx2, 10*time.Second) // Campaign for max 10s\n\t\tdefer campaignCancel()\n\n\t\terr := election.Campaign(campaignCtx, val)\n\t\tif err != nil && !errors.Is(err, context.Canceled) && !errors.Is(err, context.DeadlineExceeded) && !errors.Is(err, ErrSessionInvalid) { // Fix: use errors.Is\n\t\t\tlog.Printf(\"Participant %s: Campaign for %q failed: %v\\n\", name, val, err)\n\t\t\treturn\n\t\t}\n\t\tif errors.Is(err, ErrSessionInvalid) { // Fix: use errors.Is\n\t\t\tlog.Printf(\"Participant %s: Campaign failed due to session invalid: %v\\n\", name, err)\n\t\t\treturn\n\t\t}\n\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) { // Fix: use errors.Is\n\t\t\tlog.Printf(\"Participant %s: Campaign cancelled or timed out.\\n\", name)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Participant %s: IS THE LEADER with value %q! Holding for %v\\n\", name, val, holdDuration)\n\t\tselect {\n\t\tcase <-time.After(holdDuration):\n\t\t\t// Hold leadership for some time\n\t\tcase <-ctx2.Done():\n\t\t\tlog.Printf(\"Participant %s: Context cancelled while holding leadership.\\n\", name)\n\t\t\treturn\n\t\tcase <-election.session.ctx.Done():\n\t\t\tlog.Printf(\"Participant %s: Session invalid while holding leadership.\\n\", name)\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Participant %s: Resigning leadership...\\n\", name)\n\t\tresignCtx, resignCancel := context.WithTimeout(context.Background(), 1*time.Second) // Resign with its own ctx\n\t\tdefer resignCancel()\n\t\tif err := election.Resign(resignCtx); err != nil {\n\t\t\tlog.Printf(\"Participant %s: Failed to resign: %v\\n\", name, err)\n\t\t} else {\n\t\t\tlog.Printf(\"Participant %s: Successfully resigned.\\n\", name)\n\t\t}\n\t}\n\n\twg2.Add(3)\n\tgo campaignAndResign(\"Alpha\", electionA, \"AlphaLeader\", 2*time.Second)\n\tgo campaignAndResign(\"Beta\", electionB, \"BetaLeader\", 2*time.Second)\n\tgo campaignAndResign(\"Gamma\", electionC, \"GammaLeader\", 2*time.Second)\n\n\twg2.Wait()\n\ttime.Sleep(50 * time.Millisecond)\n\tcurrentLeader2, err := electionA.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting final leader for 'test-election-compete': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'test-election-compete' after scenario 2: %q\\n\", currentLeader2)\n\t}\n\n\t// --- Test Scenario 3: Leader expiration leading to handover ---\n\tlog.Println(\"\\n--- Test Scenario 3: Leader expiration leading to handover ---\")\n\tsessionTTL3 := 1 * time.Second // Short TTL for demonstration\n\tkv3 := NewInMemoryKV(sessionTTL3)\n\tdefer kv3.Close()\n\n\tsessionP1 := NewSession(kv3, sessionTTL3)\n\tsessionP2 := NewSession(kv3, sessionTTL3)\n\tdefer sessionP1.Close()\n\tdefer sessionP2.Close()\n\n\telectionP1 := NewElection(sessionP1, kv3, \"expiring-election\")\n\telectionP2 := NewElection(sessionP2, kv3, \"expiring-election\")\n\n\tvar wg3 sync.WaitGroup\n\tctx3, cancel3 := context.WithCancel(context.Background())\n\tdefer cancel3()\n\n\t// Observer for expiration scenario\n\tleaderExpObserverCh := electionP1.Observe(ctx3)\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase l := <-leaderExpObserverCh:\n\t\t\t\tlog.Printf(\"[Expiration Observer] Leader for 'expiring-election': %q\\n\", l)\n\t\t\tcase <-ctx3.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\twg3.Add(1)\n\tgo func() {\n\t\tdefer wg3.Done()\n\t\tlog.Println(\"P1: Campaigning for 'expiring-election'...\")\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx3, 5*time.Second) // Give enough time\n\t\tdefer campaignCancel()\n\n\t\terr := electionP1.Campaign(campaignCtx, \"P1-leader\")\n\t\tif err != nil && !errors.Is(err, context.Canceled) && !errors.Is(err, context.DeadlineExceeded) && !errors.Is(err, ErrSessionInvalid) { // Fix: use errors.Is\n\t\t\tlog.Printf(\"P1 campaign error: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tif err == nil {\n\t\t\tlog.Println(\"P1: Is leader. Holding until session expires (should happen after approx 1 second).\")\n\t\t\ttime.Sleep(2 * sessionTTL3) // Wait long enough for lease to expire\n\t\t\tlog.Println(\"P1: Leadership should have expired by now (or P1 resigned).\")\n\t\t} else {\n\t\t\tlog.Printf(\"P1: Campaign ended with error or cancellation: %v\\n\", err)\n\t\t}\n\t}()\n\n\twg3.Add(1)\n\tgo func() {\n\t\tdefer wg3.Done()\n\t\ttime.Sleep(500 * time.Millisecond) // Let P1 become leader first\n\t\tlog.Println(\"P2: Campaigning for 'expiring-election'...\")\n\t\tcampaignCtx, campaignCancel := context.WithTimeout(ctx3, 5*time.Second) // Give enough time\n\t\tdefer campaignCancel()\n\n\t\terr := electionP2.Campaign(campaignCtx, \"P2-leader\")\n\t\tif err != nil && !errors.Is(err, context.Canceled) && !errors.Is(err, context.DeadlineExceeded) && !errors.Is(err, ErrSessionInvalid) { // Fix: use errors.Is\n\t\t\tlog.Printf(\"P2 campaign error: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tif err == nil {\n\t\t\tlog.Println(\"P2: Successfully became leader after P1's expiration or resignation.\")\n\t\t\ttime.Sleep(1 * time.Second) // Hold for a moment\n\t\t} else {\n\t\t\tlog.Printf(\"P2: Campaign ended with error or cancellation: %v\\n\", err)\n\t\t}\n\t}()\n\n\twg3.Wait()\n\ttime.Sleep(50 * time.Millisecond)\n\tfinalLeaderExp, err := electionP1.Leader(context.Background())\n\tif err != nil {\n\t\tlog.Printf(\"Error getting final leader for 'expiring-election': %v\\n\", err)\n\t} else {\n\t\tlog.Printf(\"Final leader for 'expiring-election' after scenario 3: %q\\n\", finalLeaderExp)\n\t}\n\tlog.Println(\"\\n--- All test scenarios completed ---\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}