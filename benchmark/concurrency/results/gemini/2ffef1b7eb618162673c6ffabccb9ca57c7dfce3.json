{
    "task": "2ffef1b7eb618162673c6ffabccb9ca57c7dfce3.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// DeviceState represents the current state of a device.\ntype DeviceState int\n\nconst (\n\tDeviceStateCreated DeviceState = iota\n\tDeviceStateMounted\n\tDeviceStateUnmounted\n)\n\n// String returns the string representation of a DeviceState.\nfunc (s DeviceState) String() string {\n\tswitch s {\n\tcase DeviceStateCreated:\n\t\treturn \"Created\"\n\tcase DeviceStateMounted:\n\t\treturn \"Mounted\"\n\tcase DeviceStateUnmounted:\n\t\treturn \"Unmounted\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n\n// Device represents a virtual storage device.\ntype Device struct {\n\tID        string\n\tParentID  string\n\tMountPath string // The path where the device is mounted. Once set, it cannot change.\n\tMountCount int   // Reference count for how many times the device is \"mounted\".\n\tState     DeviceState\n\tmu        sync.Mutex // Mutex to protect this device's fields.\n}\n\n// DeviceStatus provides a snapshot of a device's current state.\ntype DeviceStatus struct {\n\tID        string\n\tParentID  string\n\tMountPath string\n\tMountCount int\n\tState     DeviceState\n}\n\n// DeviceManager manages the collection of virtual devices.\ntype DeviceManager struct {\n\tdevices map[string]*Device\n\tmu      sync.Mutex // Mutex to protect the 'devices' map.\n}\n\n// Global mutex for synchronized logging to prevent interleaved output.\nvar logMutex sync.Mutex\n\n// logMsg prints a timestamped message to standard output.\nfunc logMsg(gID, format string, args ...interface{}) {\n\tlogMutex.Lock()\n\tdefer logMutex.Unlock()\n\ttimestamp := time.Now().Format(\"15:04:05.000\")\n\tfmt.Printf(\"[%s] %s: %s\\n\", timestamp, gID, fmt.Sprintf(format, args...))\n}\n\n// NewDeviceManager creates and initializes a new DeviceManager.\nfunc NewDeviceManager() *DeviceManager {\n\tdm := &DeviceManager{\n\t\tdevices: make(map[string]*Device),\n\t}\n\t// Create the base device\n\tbaseDevice := &Device{\n\t\tID:        \"base\",\n\t\tParentID:  \"\", // No parent for the base device\n\t\tMountPath: \"\",\n\t\tMountCount: 0,\n\t\tState:     DeviceStateUnmounted,\n\t}\n\tdm.devices[\"base\"] = baseDevice\n\tlogMsg(\"DeviceManager\", \"Base device 'base' initialized.\")\n\treturn dm\n}\n\n// AddDevice creates a new device based on a parent device.\nfunc (dm *DeviceManager) AddDevice(deviceID, parentID string) error {\n\tdm.mu.Lock()\n\tdefer dm.mu.Unlock()\n\n\tif _, exists := dm.devices[deviceID]; exists {\n\t\treturn fmt.Errorf(\"device '%s' already exists\", deviceID)\n\t}\n\tif _, exists := dm.devices[parentID]; !exists {\n\t\treturn fmt.Errorf(\"parent device '%s' does not exist\", parentID)\n\t}\n\n\tnewDevice := &Device{\n\t\tID:        deviceID,\n\t\tParentID:  parentID,\n\t\tMountPath: \"\",\n\t\tMountCount: 0,\n\t\tState:     DeviceStateCreated,\n\t}\n\tdm.devices[deviceID] = newDevice\n\treturn nil\n}\n\n// DeleteDevice removes a device from the system.\nfunc (dm *DeviceManager) DeleteDevice(deviceID string) error {\n\tdm.mu.Lock()\n\tdefer dm.mu.Unlock()\n\n\tif deviceID == \"base\" {\n\t\treturn fmt.Errorf(\"cannot delete the base device '%s'\", deviceID)\n\t}\n\n\tdev, exists := dm.devices[deviceID]\n\tif !exists {\n\t\treturn fmt.Errorf(\"device '%s' not found\", deviceID)\n\t}\n\n\tdev.mu.Lock() // Lock the device to check its state\n\tdefer dev.mu.Unlock()\n\n\tif dev.MountCount > 0 {\n\t\treturn fmt.Errorf(\"device '%s' cannot be deleted while it is mounted (mount count: %d)\", deviceID, dev.MountCount)\n\t}\n\n\tdelete(dm.devices, deviceID)\n\treturn nil\n}\n\n// MountDevice mounts a device to a specific path.\nfunc (dm *DeviceManager) MountDevice(deviceID, mountPath string) error {\n\tdm.mu.Lock()\n\tdev, exists := dm.devices[deviceID]\n\tdm.mu.Unlock() // Unlock global mutex as soon as we have the device pointer\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"device '%s' not found\", deviceID)\n\t}\n\n\tdev.mu.Lock()\n\tdefer dev.mu.Unlock()\n\n\t// Simulate work\n\ttime.Sleep(100 * time.Millisecond)\n\n\tif dev.MountPath != \"\" && dev.MountPath != mountPath {\n\t\treturn fmt.Errorf(\"device '%s' is already mounted at a different path '%s'\", deviceID, dev.MountPath)\n\t}\n\n\tif dev.MountCount == 0 { // First mount, set the path and state\n\t\tdev.MountPath = mountPath\n\t\tdev.State = DeviceStateMounted\n\t}\n\tdev.MountCount++\n\tdev.State = DeviceStateMounted // Ensure state is mounted even if already counted\n\n\treturn nil\n}\n\n// UnmountDevice unmounts a device.\nfunc (dm *DeviceManager) UnmountDevice(deviceID string) error {\n\tdm.mu.Lock()\n\tdev, exists := dm.devices[deviceID]\n\tdm.mu.Unlock() // Unlock global mutex\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"device '%s' not found\", deviceID)\n\t}\n\n\tdev.mu.Lock()\n\tdefer dev.mu.Unlock()\n\n\t// Simulate work\n\ttime.Sleep(100 * time.Millisecond)\n\n\tif dev.MountCount == 0 {\n\t\treturn fmt.Errorf(\"device '%s' is not mounted\", deviceID)\n\t}\n\n\tdev.MountCount--\n\tif dev.MountCount == 0 {\n\t\tdev.MountPath = \"\" // Clear path only when no longer mounted\n\t\tdev.State = DeviceStateUnmounted\n\t}\n\n\treturn nil\n}\n\n// GetDeviceStatus retrieves the current status of a device.\nfunc (dm *DeviceManager) GetDeviceStatus(deviceID string) (*DeviceStatus, error) {\n\tdm.mu.Lock()\n\tdev, exists := dm.devices[deviceID]\n\tdm.mu.Unlock() // Unlock global mutex\n\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"device '%s' not found\", deviceID)\n\t}\n\n\tdev.mu.Lock()\n\tdefer dev.mu.Unlock()\n\n\tstatus := &DeviceStatus{\n\t\tID:        dev.ID,\n\t\tParentID:  dev.ParentID,\n\t\tMountPath: dev.MountPath,\n\t\tMountCount: dev.MountCount,\n\t\tState:     dev.State,\n\t}\n\treturn status, nil\n}\n\nfunc main() {\n\tdm := NewDeviceManager()\n\tvar wg sync.WaitGroup\n\n\t// 1. Create device \"dev1\" from \"base\"\n\tif err := dm.AddDevice(\"dev1\", \"base\"); err != nil {\n\t\tlogMsg(\"main\", \"AddDevice dev1 with parent base - Failed: %v\", err)\n\t} else {\n\t\tlogMsg(\"main\", \"AddDevice dev1 with parent base - Success\")\n\t}\n\n\t// 2. In goroutine A: Mount \"dev1\", sleep for 2 seconds, then unmount\n\twg.Add(1)\n\tgo func(gID string) {\n\t\tdefer wg.Done()\n\t\tmountPath := \"/mnt/dev1\"\n\n\t\tif err := dm.MountDevice(\"dev1\", mountPath); err != nil {\n\t\t\tlogMsg(gID, \"MountDevice dev1 at %s - Failed: %v\", mountPath, err)\n\t\t} else {\n\t\t\tlogMsg(gID, \"MountDevice dev1 at %s - Success\", mountPath)\n\t\t}\n\n\t\ttime.Sleep(2 * time.Second) // Simulate long-running operation\n\n\t\tif err := dm.UnmountDevice(\"dev1\"); err != nil {\n\t\t\tlogMsg(gID, \"UnmountDevice dev1 - Failed: %v\", err)\n\t\t} else {\n\t\t\tlogMsg(gID, \"UnmountDevice dev1 - Success\")\n\t\t}\n\t}(\"Goroutine A\")\n\n\t// Start B and C after 500ms\n\ttime.Sleep(500 * time.Millisecond)\n\n\t// 3. In goroutine B: Try to get status of \"dev1\"\n\twg.Add(1)\n\tgo func(gID string) {\n\t\tdefer wg.Done()\n\t\tstatus, err := dm.GetDeviceStatus(\"dev1\")\n\t\tif err != nil {\n\t\t\tlogMsg(gID, \"GetDeviceStatus dev1 - Failed: %v\", err)\n\t\t} else {\n\t\t\tlogMsg(gID, \"GetDeviceStatus dev1 - Success (state: %s, count: %d, path: %s)\",\n\t\t\t\tstatus.State, status.MountCount, status.MountPath)\n\t\t}\n\t}(\"Goroutine B\")\n\n\t// 4. In goroutine C: Try to mount \"dev1\" to same path\n\twg.Add(1)\n\tgo func(gID string) {\n\t\tdefer wg.Done()\n\t\tmountPath := \"/mnt/dev1\"\n\n\t\tif err := dm.MountDevice(\"dev1\", mountPath); err != nil {\n\t\t\tlogMsg(gID, \"MountDevice dev1 at %s - Failed: %v\", mountPath, err)\n\t\t} else {\n\t\t\tlogMsg(gID, \"MountDevice dev1 at %s - Success\", mountPath)\n\t\t}\n\t\t// Goroutine C does not unmount, so dev1 will remain mounted by C.\n\t}(\"Goroutine C\")\n\n\twg.Wait() // Wait for A, B, C to complete\n\n\t// 5. After all operations complete: Delete \"dev1\"\n\t// This should fail because Goroutine C mounted it and didn't unmount it.\n\tif err := dm.DeleteDevice(\"dev1\"); err != nil {\n\t\tlogMsg(\"main\", \"DeleteDevice dev1 - Failed: %v\", err)\n\t} else {\n\t\tlogMsg(\"main\", \"DeleteDevice dev1 - Success\")\n\t}\n\n\t// Additional check: Try to delete the base device (should fail)\n\tif err := dm.DeleteDevice(\"base\"); err != nil {\n\t\tlogMsg(\"main\", \"DeleteDevice base - Failed: %v\", err)\n\t} else {\n\t\tlogMsg(\"main\", \"DeleteDevice base - Success\")\n\t}\n\n\t// Final status check for dev1\n\tstatus, err := dm.GetDeviceStatus(\"dev1\")\n\tif err != nil {\n\t\tlogMsg(\"main\", \"Final GetDeviceStatus dev1 - Failed: %v\", err)\n\t} else {\n\t\tlogMsg(\"main\", \"Final GetDeviceStatus dev1 - (state: %s, count: %d, path: %s)\",\n\t\t\tstatus.State, status.MountCount, status.MountPath)\n\t}\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}