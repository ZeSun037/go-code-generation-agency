{
    "task": "1b1fabef8ffec606909f01c3983300fff539f214.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Token represents an authentication token with its associated data.\ntype Token struct {\n\tUsername       string\n\tExpirationTime time.Time\n}\n\n// TokenManager manages tokens, their expiration, and concurrent access.\ntype TokenManager struct {\n\ttokens     map[string]Token                 // Maps token string to Token details\n\tuserTokens map[string]map[string]struct{}   // Maps username to a set of token strings for quick lookup\n\tmu         sync.Mutex                       // Protects access to tokens and userTokens maps\n\tquitCh     chan struct{}                    // Signals the cleaner goroutine to stop\n\twg         sync.WaitGroup                   // Waits for the cleaner goroutine to finish\n\n\texpirationDuration time.Duration // How long tokens are valid for (e.g., 5 seconds)\n\tcleanerInterval    time.Duration // How often the cleaner goroutine runs (e.g., 100 milliseconds)\n}\n\n// NewTokenManager creates and returns a new TokenManager instance.\nfunc NewTokenManager() *TokenManager {\n\ttm := &TokenManager{\n\t\ttokens:             make(map[string]Token),\n\t\tuserTokens:         make(map[string]map[string]struct{}),\n\t\tquitCh:             make(chan struct{}),\n\t\texpirationDuration: 5 * time.Second,\n\t\tcleanerInterval:    100 * time.Millisecond,\n\t}\n\n\ttm.wg.Add(1)\n\tgo tm.cleanerGoroutine() // Start the background cleaner\n\treturn tm\n}\n\n// generateTokenString generates a random URL-safe base64 string of a fixed length (16 characters).\n// 12 bytes of random data encode to 16 URL-safe base64 characters.\nfunc generateTokenString() (string, error) {\n\tconst tokenByteLength = 12\n\tb := make([]byte, tokenByteLength)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read random bytes: %w\", err)\n\t}\n\treturn base64.URLEncoding.EncodeToString(b), nil\n}\n\n// CreateToken generates and stores a new token for a user.\nfunc (tm *TokenManager) CreateToken(username string) string {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\tvar tokenStr string\n\tvar err error\n\tfor {\n\t\ttokenStr, err = generateTokenString()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error generating token string: %v\", err)\n\t\t\treturn \"\" // In a real application, consider retrying or more robust error handling\n\t\t}\n\t\tif _, exists := tm.tokens[tokenStr]; !exists {\n\t\t\tbreak // Found a unique token string\n\t\t}\n\t\t// In an extremely unlikely scenario of collision, loop and try again.\n\t}\n\n\tnewToken := Token{\n\t\tUsername:       username,\n\t\tExpirationTime: time.Now().Add(tm.expirationDuration),\n\t}\n\n\ttm.tokens[tokenStr] = newToken\n\n\tif _, ok := tm.userTokens[username]; !ok {\n\t\ttm.userTokens[username] = make(map[string]struct{})\n\t}\n\ttm.userTokens[username][tokenStr] = struct{}{}\n\n\treturn tokenStr\n}\n\n// RefreshToken resets the expiration time of an existing token.\n// Returns true if the token existed and was refreshed, false otherwise.\nfunc (tm *TokenManager) RefreshToken(tokenStr string) bool {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\ttoken, exists := tm.tokens[tokenStr]\n\tif !exists || token.ExpirationTime.Before(time.Now()) {\n\t\t// Token doesn't exist or is already expired\n\t\treturn false\n\t}\n\n\t// Token exists and is not expired, refresh it\n\ttoken.ExpirationTime = time.Now().Add(tm.expirationDuration)\n\ttm.tokens[tokenStr] = token // Update the map with the modified struct\n\n\treturn true\n}\n\n// ValidateToken checks if a token is valid and returns the associated username.\n// If valid, it also refreshes its expiration time.\n// Returns the username and true if valid, empty string and false otherwise.\nfunc (tm *TokenManager) ValidateToken(tokenStr string) (string, bool) {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\ttoken, exists := tm.tokens[tokenStr]\n\tif !exists || token.ExpirationTime.Before(time.Now()) {\n\t\treturn \"\", false // Token does not exist or has expired\n\t}\n\n\t// Token is valid, refresh its expiration\n\ttoken.ExpirationTime = time.Now().Add(tm.expirationDuration)\n\ttm.tokens[tokenStr] = token // Update the map with the modified struct\n\n\treturn token.Username, true\n}\n\n// RevokeUser immediately invalidates all tokens belonging to a specific user.\nfunc (tm *TokenManager) RevokeUser(username string) {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\tuserTokensSet, exists := tm.userTokens[username]\n\tif !exists {\n\t\treturn // No tokens for this user\n\t}\n\n\t// Remove each token associated with the user from the main tokens map\n\tfor tokenStr := range userTokensSet {\n\t\tdelete(tm.tokens, tokenStr)\n\t}\n\t// Remove the user's entry from the userTokens map\n\tdelete(tm.userTokens, username)\n}\n\n// cleanerGoroutine runs in the background to remove expired tokens periodically.\nfunc (tm *TokenManager) cleanerGoroutine() {\n\tdefer tm.wg.Done()\n\tticker := time.NewTicker(tm.cleanerInterval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\ttm.cleanExpiredTokens()\n\t\tcase <-tm.quitCh:\n\t\t\tlog.Println(\"Token cleaner goroutine stopping.\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// cleanExpiredTokens identifies and removes tokens whose expiration time is in the past.\nfunc (tm *TokenManager) cleanExpiredTokens() {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\tnow := time.Now()\n\texpiredTokens := make([]string, 0)\n\n\t// First pass: identify all expired tokens\n\tfor tokenStr, token := range tm.tokens {\n\t\tif token.ExpirationTime.Before(now) {\n\t\t\texpiredTokens = append(expiredTokens, tokenStr)\n\t\t}\n\t}\n\n\t// Second pass: remove identified expired tokens from both maps\n\tfor _, tokenStr := range expiredTokens {\n\t\ttoken := tm.tokens[tokenStr] // Get the token details before deleting from tm.tokens\n\t\tdelete(tm.tokens, tokenStr)\n\n\t\tif userTokensSet, ok := tm.userTokens[token.Username]; ok {\n\t\t\tdelete(userTokensSet, tokenStr)\n\t\t\tif len(userTokensSet) == 0 {\n\t\t\t\tdelete(tm.userTokens, token.Username) // Clean up user entry if no more tokens\n\t\t\t}\n\t\t}\n\t}\n\tif len(expiredTokens) > 0 {\n\t\tlog.Printf(\"Cleaned %d expired tokens.\", len(expiredTokens))\n\t}\n}\n\n// Shutdown stops the background cleaner goroutine and cleans up resources.\nfunc (tm *TokenManager) Shutdown() {\n\tlog.Println(\"Shutting down Token Manager...\")\n\tclose(tm.quitCh) // Signal the cleaner to stop\n\ttm.wg.Wait()     // Wait for the cleaner to finish gracefully\n\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\t// Optionally clear maps for explicit resource release, though GC would handle it eventually\n\ttm.tokens = make(map[string]Token)\n\ttm.userTokens = make(map[string]map[string]struct{})\n\tlog.Println(\"Token Manager shutdown complete.\")\n}\n\nfunc main() {\n\tmanager := NewTokenManager()\n\tdefer manager.Shutdown() // Ensure shutdown is called when main exits\n\n\tvar wg sync.WaitGroup\n\tlog.Println(\"Starting Token Manager test program...\")\n\n\t// --- Test Case 1: Create and validate tokens concurrently ---\n\tlog.Println(\"\\n--- Test Case 1: Concurrent token creation and validation ---\")\n\tuserCount := 3\n\ttokensPerUser := 5\n\tcreatedTokens := make(chan string, userCount*tokensPerUser)\n\n\t// Concurrently create tokens for multiple users\n\tfor i := 0; i < userCount; i++ {\n\t\tusername := fmt.Sprintf(\"user%d\", i)\n\t\twg.Add(1)\n\t\tgo func(u string) {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < tokensPerUser; j++ {\n\t\t\t\ttoken := manager.CreateToken(u)\n\t\t\t\tif token != \"\" {\n\t\t\t\t\tcreatedTokens <- token\n\t\t\t\t\t// log.Printf(\"[%s] Created token: %s\", u, token) // Commented for cleaner output\n\t\t\t\t}\n\t\t\t\ttime.Sleep(10 * time.Millisecond) // Simulate some work\n\t\t\t}\n\t\t}(username)\n\t}\n\twg.Wait()\n\tclose(createdTokens) // All creators are done, close the channel\n\n\t// Collect all created tokens for subsequent validation\n\tallTokens := []string{}\n\tfor token := range createdTokens {\n\t\tallTokens = append(allTokens, token)\n\t}\n\tlog.Printf(\"Created %d tokens for %d users.\", len(allTokens), userCount)\n\n\t// Concurrently validate tokens for a duration\n\tvalidationDuration := 3 * time.Second\n\tlog.Printf(\"Validating tokens concurrently for %v...\", validationDuration)\n\tstopValidation := make(chan struct{})\n\tgo func() {\n\t\ttime.Sleep(validationDuration)\n\t\tclose(stopValidation)\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tvalidationCounter := 0\n\t\tif len(allTokens) == 0 {\n\t\t\tlog.Println(\"No tokens to validate.\")\n\t\t\treturn\n\t\t}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stopValidation:\n\t\t\t\tlog.Printf(\"Stopped concurrent validation. Total validations: %d\", validationCounter)\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\ttokenToValidate := allTokens[validationCounter%len(allTokens)] // Cycle through tokens\n\t\t\t\tusername, valid := manager.ValidateToken(tokenToValidate)\n\t\t\t\tif valid {\n\t\t\t\t\t// log.Printf(\"[Validator] Token %s for %s is valid and refreshed.\", tokenToValidate, username) // Commented for cleaner output\n\t\t\t\t\tvalidationCounter++\n\t\t\t\t} else {\n\t\t\t\t\t// log.Printf(\"[Validator] Token %s for %s is INVALID (could be expired or revoked).\", tokenToValidate, username) // Commented for cleaner output\n\t\t\t\t}\n\t\t\t\ttime.Sleep(50 * time.Millisecond) // Prevent busy-waiting\n\t\t\t}\n\t\t}\n\t}()\n\n\t// --- Test Case 2: Token Expiration ---\n\tlog.Println(\"\\n--- Test Case 2: Token Expiration ---\")\n\tuserA := \"user_expiration\"\n\ttokenA := manager.CreateToken(userA)\n\tif tokenA == \"\" {\n\t\tlog.Fatal(\"Failed to create token for expiration test.\")\n\t}\n\tlog.Printf(\"Created token for %s: %s. Will expire in %v.\", userA, tokenA, manager.expirationDuration)\n\n\t_, valid = manager.ValidateToken(tokenA)\n\tlog.Printf(\"Immediately validating token %s: %t (Expected: true)\", tokenA, valid) // Should be true\n\n\tlog.Printf(\"Waiting for token %s to expire (approx %v + cleaner interval)...\", tokenA, manager.expirationDuration)\n\t// Wait slightly longer than expiration duration + cleaner interval to ensure cleaner has run\n\ttime.Sleep(manager.expirationDuration + manager.cleanerInterval + 100*time.Millisecond)\n\n\t_, valid = manager.ValidateToken(tokenA)\n\tlog.Printf(\"Validating token %s after expiration: %t (Expected: false)\", tokenA, valid) // Should be false\n\n\t// --- Test Case 3: Revoke User ---\n\tlog.Println(\"\\n--- Test Case 3: Revoke User ---\")\n\tuserToRevoke := \"user_revoke\"\n\ttokenR1 := manager.CreateToken(userToRevoke)\n\ttokenR2 := manager.CreateToken(userToRevoke)\n\tif tokenR1 == \"\" || tokenR2 == \"\" {\n\t\tlog.Fatal(\"Failed to create tokens for revoke test.\")\n\t}\n\tlog.Printf(\"Created tokens for %s: %s, %s\", userToRevoke, tokenR1, tokenR2)\n\n\t_, valid = manager.ValidateToken(tokenR1)\n\tlog.Printf(\"Validating token %s before revoke: %t (Expected: true)\", tokenR1, valid) // Should be true\n\n\tlog.Printf(\"Revoking all tokens for user %s...\", userToRevoke)\n\tmanager.RevokeUser(userToRevoke)\n\ttime.Sleep(50 * time.Millisecond) // Give a moment for any potential internal goroutine sync\n\n\t_, valid = manager.ValidateToken(tokenR1)\n\tlog.Printf(\"Validating token %s after revoke: %t (Expected: false)\", tokenR1, valid) // Should be false\n\t_, valid = manager.ValidateToken(tokenR2)\n\tlog.Printf(\"Validating token %s after revoke: %t (Expected: false)\", tokenR2, valid) // Should be false\n\n\t// --- Test Case 4: Refresh Token ---\n\tlog.Println(\"\\n--- Test Case 4: Refresh Token ---\")\n\tuserRefresh := \"user_refresh\"\n\ttokenRefresh := manager.CreateToken(userRefresh)\n\tif tokenRefresh == \"\" {\n\t\tlog.Fatal(\"Failed to create token for refresh test.\")\n\t}\n\tlog.Printf(\"Created token for %s: %s. Will expire in %v.\", userRefresh, tokenRefresh, manager.expirationDuration)\n\n\tlog.Printf(\"Waiting for %v before refreshing token...\", manager.expirationDuration/2)\n\ttime.Sleep(manager.expirationDuration / 2) // Wait half the expiration time\n\n\trefreshed := manager.RefreshToken(tokenRefresh)\n\tlog.Printf(\"Attempting to refresh token %s: %t (Expected: true)\", tokenRefresh, refreshed) // Should be true\n\n\t_, valid = manager.ValidateToken(tokenRefresh)\n\tlog.Printf(\"Validating token %s immediately after refresh: %t (Expected: true)\", tokenRefresh, valid) // Should be true\n\n\tlog.Printf(\"Waiting for token %s to expire after refresh (approx %v + cleaner interval)...\", tokenRefresh, manager.expirationDuration)\n\ttime.Sleep(manager.expirationDuration + manager.cleanerInterval + 100*time.Millisecond)\n\n\t_, valid = manager.ValidateToken(tokenRefresh)\n\tlog.Printf(\"Validating token %s after refreshed expiration: %t (Expected: false)\", tokenRefresh, valid) // Should be false\n\n\t// Wait for all concurrent test goroutines to finish before main exits\n\twg.Wait()\n\tlog.Println(\"\\nAll test cases completed. Program will now shut down.\")\n\t// manager.Shutdown() is called via defer\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:273:5: declared and not used: username\n./main.go:294:5: undefined: valid\n./main.go:295:77: undefined: valid\n./main.go:301:5: undefined: valid\n./main.go:302:83: undefined: valid\n./main.go:314:5: undefined: valid\n./main.go:315:80: undefined: valid\n./main.go:321:5: undefined: valid\n./main.go:322:80: undefined: valid\n./main.go:323:5: undefined: valid\n./main.go:323:5: too many errors"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:273:5: declared and not used: username\n./main.go:294:5: undefined: valid\n./main.go:295:77: undefined: valid\n./main.go:301:5: undefined: valid\n./main.go:302:83: undefined: valid\n./main.go:314:5: undefined: valid\n./main.go:315:80: undefined: valid\n./main.go:321:5: undefined: valid\n./main.go:322:80: undefined: valid\n./main.go:323:5: undefined: valid\n./main.go:323:5: too many errors\n\n\nGolang errors in file: [/tmp/go_synthesis_sb5pt_tr/main.go]:\n\n  > [line 273 : column 5] - declared and not used: username\n\n  > [line 294 : column 5] - undefined: valid\n\n  > [line 295 : column 77] - undefined: valid\n\n  > [line 301 : column 5] - undefined: valid\n\n  > [line 302 : column 83] - undefined: valid\n\n  > [line 314 : column 5] - undefined: valid\n\n  > [line 315 : column 80] - undefined: valid\n\n  > [line 321 : column 5] - undefined: valid\n\n  > [line 322 : column 80] - undefined: valid\n\n  > [line 323 : column 5] - undefined: valid\n\n  > [line 324 : column 80] - undefined: valid\n\n  > [line 341 : column 5] - undefined: valid\n\n  > [line 342 : column 97] - undefined: valid\n\n  > [line 347 : column 5] - undefined: valid\n\n  > [line 348 : column 99] - undefined: valid\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 354\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 12:37:50 Including rules: default\n[gosec] 2025/12/01 12:37:50 Excluding rules: default\n[gosec] 2025/12/01 12:37:50 Including analyzers: default\n[gosec] 2025/12/01 12:37:50 Excluding analyzers: default\n[gosec] 2025/12/01 12:37:50 Import directory: /tmp/go_synthesis_sb5pt_tr\n[gosec] 2025/12/01 12:37:50 Checking package: main\n[gosec] 2025/12/01 12:37:50 Checking file: /tmp/go_synthesis_sb5pt_tr/main.go\n[gosec] 2025/12/01 12:37:51 Panic when running SSA analyzer on package: main. Panic: no types.Object for ast.Ident valid @ /tmp/go_synthesis_sb5pt_tr/main.go:294:5\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xe6fbe0?, 0xc000c12050?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*Function).objectOf(0xc000bda200, 0xc000d9e420)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/func.go:29 +0x19d\ngolang.org/x/tools/go/ssa.(*builder).addr(0xc000b7ccc0, 0xc000bda200, {0x11e2648?, 0xc000d9e420}, 0x0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:443 +0xaf\ngolang.org/x/tools/go/ssa.(*builder).assignStmt(0xc000b7ccc0, 0xc000bda200, {0xc000d9e440, 0x2, 0xc000bf5970?}, {0xc000e7d0a0, 0x1, 0x0?}, 0x0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1216 +0x28e\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000b7ccc0, 0xc000bda200, {0x11e2d90?, 0xc000d9a700?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2720 +0x5b5\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000b7ccc0, 0xc000bda200, {0x11e2eb0?, 0xc000e82030?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000b7ccc0, 0xc000bda200)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000bda200)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000b7ccc0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc000bb6080)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc0001ef320?, 0xc000e6a840?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc000b9e000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc000a5fa00)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc000c2dc00, 0xc000a5fa00)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc000c2dc00, {0x0, 0x0, 0x0}, {0xc00026cba0, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 12:37:51 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_sb5pt_tr/main.go:273:5: declared and not used: username\n/tmp/go_synthesis_sb5pt_tr/main.go:294:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:295:77: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:301:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:302:83: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:314:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:315:80: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:321:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:322:80: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:323:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:324:80: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:341:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:342:97: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:347:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:348:99: undefined: valid\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:273:5: declared and not used: username\n./main.go:294:5: undefined: valid\n./main.go:295:77: undefined: valid\n./main.go:301:5: undefined: valid\n./main.go:302:83: undefined: valid\n./main.go:314:5: undefined: valid\n./main.go:315:80: undefined: valid\n./main.go:321:5: undefined: valid\n./main.go:322:80: undefined: valid\n./main.go:323:5: undefined: valid\n./main.go:323:5: too many errors /tmp/go_synthesis_sb5pt_tr/main.go:273:5: declared and not used: username /tmp/go_synthesis_sb5pt_tr/main.go:294:5: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:295:77: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:301:5: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:302:83: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:314:5: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:315:80: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:321:5: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:322:80: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:323:5: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:324:80: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:341:5: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:342:97: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:347:5: undefined: valid /tmp/go_synthesis_sb5pt_tr/main.go:348:99: undefined: valid]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:273:5: declared and not used: username\n./main.go:294:5: undefined: valid\n./main.go:295:77: undefined: valid\n./main.go:301:5: undefined: valid\n./main.go:302:83: undefined: valid\n./main.go:314:5: undefined: valid\n./main.go:315:80: undefined: valid\n./main.go:321:5: undefined: valid\n./main.go:322:80: undefined: valid\n./main.go:323:5: undefined: valid\n./main.go:323:5: too many errors\n/tmp/go_synthesis_sb5pt_tr/main.go:273:5: declared and not used: username\n/tmp/go_synthesis_sb5pt_tr/main.go:294:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:295:77: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:301:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:302:83: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:314:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:315:80: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:321:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:322:80: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:323:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:324:80: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:341:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:342:97: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:347:5: undefined: valid\n/tmp/go_synthesis_sb5pt_tr/main.go:348:99: undefined: valid\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:273:5: declared and not used: username\n./main.go:294:5: undefined: valid\n./main.go:295:77: undefined: valid\n./main.go:301:5: undefined: valid\n./main.go:302:83: undefined: valid\n./main.go:314:5: undefined: valid\n./main.go:315:80: undefined: valid\n./main.go:321:5: undefined: valid\n./main.go:322:80: undefined: valid\n./main.go:323:5: undefined: valid\n./main.go:323:5: too many errors (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Token represents an authentication token with its associated data.\ntype Token struct {\n\tUsername       string\n\tExpirationTime time.Time\n}\n\n// TokenManager manages tokens, their expiration, and concurrent access.\ntype TokenManager struct {\n\ttokens     map[string]Token                 // Maps token string to Token details\n\tuserTokens map[string]map[string]struct{}   // Maps username to a set of token strings for quick lookup\n\tmu         sync.Mutex                       // Protects access to tokens and userTokens maps\n\tquitCh     chan struct{}                    // Signals the cleaner goroutine to stop\n\twg         sync.WaitGroup                   // Waits for the cleaner goroutine to finish\n\n\texpirationDuration time.Duration // How long tokens are valid for (e.g., 5 seconds)\n\tcleanerInterval    time.Duration // How often the cleaner goroutine runs (e.g., 100 milliseconds)\n}\n\n// NewTokenManager creates and returns a new TokenManager instance.\nfunc NewTokenManager() *TokenManager {\n\ttm := &TokenManager{\n\t\ttokens:             make(map[string]Token),\n\t\tuserTokens:         make(map[string]map[string]struct{}),\n\t\tquitCh:             make(chan struct{}),\n\t\texpirationDuration: 5 * time.Second,\n\t\tcleanerInterval:    100 * time.Millisecond,\n\t}\n\n\ttm.wg.Add(1)\n\tgo tm.cleanerGoroutine() // Start the background cleaner\n\treturn tm\n}\n\n// generateTokenString generates a random URL-safe base64 string of a fixed length (16 characters).\n// 12 bytes of random data encode to 16 URL-safe base64 characters.\nfunc generateTokenString() (string, error) {\n\tconst tokenByteLength = 12\n\tb := make([]byte, tokenByteLength)\n\t_, err := rand.Read(b)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read random bytes: %w\", err)\n\t}\n\treturn base64.URLEncoding.EncodeToString(b), nil\n}\n\n// CreateToken generates and stores a new token for a user.\nfunc (tm *TokenManager) CreateToken(username string) string {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\tvar tokenStr string\n\tvar err error\n\tfor {\n\t\ttokenStr, err = generateTokenString()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error generating token string: %v\", err)\n\t\t\treturn \"\" // In a real application, consider retrying or more robust error handling\n\t\t}\n\t\tif _, exists := tm.tokens[tokenStr]; !exists {\n\t\t\tbreak // Found a unique token string\n\t\t}\n\t\t// In an extremely unlikely scenario of collision, loop and try again.\n\t}\n\n\tnewToken := Token{\n\t\tUsername:       username,\n\t\tExpirationTime: time.Now().Add(tm.expirationDuration),\n\t}\n\n\ttm.tokens[tokenStr] = newToken\n\n\tif _, ok := tm.userTokens[username]; !ok {\n\t\ttm.userTokens[username] = make(map[string]struct{})\n\t}\n\ttm.userTokens[username][tokenStr] = struct{}{}\n\n\treturn tokenStr\n}\n\n// RefreshToken resets the expiration time of an existing token.\n// Returns true if the token existed and was refreshed, false otherwise.\nfunc (tm *TokenManager) RefreshToken(tokenStr string) bool {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\ttoken, exists := tm.tokens[tokenStr]\n\tif !exists || token.ExpirationTime.Before(time.Now()) {\n\t\t// Token doesn't exist or is already expired\n\t\treturn false\n\t}\n\n\t// Token exists and is not expired, refresh it\n\ttoken.ExpirationTime = time.Now().Add(tm.expirationDuration)\n\ttm.tokens[tokenStr] = token // Update the map with the modified struct\n\n\treturn true\n}\n\n// ValidateToken checks if a token is valid and returns the associated username.\n// If valid, it also refreshes its expiration time.\n// Returns the username and true if valid, empty string and false otherwise.\nfunc (tm *TokenManager) ValidateToken(tokenStr string) (string, bool) {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\ttoken, exists := tm.tokens[tokenStr]\n\tif !exists || token.ExpirationTime.Before(time.Now()) {\n\t\treturn \"\", false // Token does not exist or has expired\n\t}\n\n\t// Token is valid, refresh its expiration\n\ttoken.ExpirationTime = time.Now().Add(tm.expirationDuration)\n\ttm.tokens[tokenStr] = token // Update the map with the modified struct\n\n\treturn token.Username, true\n}\n\n// RevokeUser immediately invalidates all tokens belonging to a specific user.\nfunc (tm *TokenManager) RevokeUser(username string) {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\tuserTokensSet, exists := tm.userTokens[username]\n\tif !exists {\n\t\treturn // No tokens for this user\n\t}\n\n\t// Remove each token associated with the user from the main tokens map\n\tfor tokenStr := range userTokensSet {\n\t\tdelete(tm.tokens, tokenStr)\n\t}\n\t// Remove the user's entry from the userTokens map\n\tdelete(tm.userTokens, username)\n}\n\n// cleanerGoroutine runs in the background to remove expired tokens periodically.\nfunc (tm *TokenManager) cleanerGoroutine() {\n\tdefer tm.wg.Done()\n\tticker := time.NewTicker(tm.cleanerInterval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\ttm.cleanExpiredTokens()\n\t\tcase <-tm.quitCh:\n\t\t\tlog.Println(\"Token cleaner goroutine stopping.\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// cleanExpiredTokens identifies and removes tokens whose expiration time is in the past.\nfunc (tm *TokenManager) cleanExpiredTokens() {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\n\tnow := time.Now()\n\texpiredTokens := make([]string, 0)\n\n\t// First pass: identify all expired tokens\n\tfor tokenStr, token := range tm.tokens {\n\t\tif token.ExpirationTime.Before(now) {\n\t\t\texpiredTokens = append(expiredTokens, tokenStr)\n\t\t}\n\t}\n\n\t// Second pass: remove identified expired tokens from both maps\n\tfor _, tokenStr := range expiredTokens {\n\t\ttoken := tm.tokens[tokenStr] // Get the token details before deleting from tm.tokens\n\t\tdelete(tm.tokens, tokenStr)\n\n\t\tif userTokensSet, ok := tm.userTokens[token.Username]; ok {\n\t\t\tdelete(userTokensSet, tokenStr)\n\t\t\tif len(userTokensSet) == 0 {\n\t\t\t\tdelete(tm.userTokens, token.Username) // Clean up user entry if no more tokens\n\t\t\t}\n\t\t}\n\t}\n\tif len(expiredTokens) > 0 {\n\t\tlog.Printf(\"Cleaned %d expired tokens.\", len(expiredTokens))\n\t}\n}\n\n// Shutdown stops the background cleaner goroutine and cleans up resources.\nfunc (tm *TokenManager) Shutdown() {\n\tlog.Println(\"Shutting down Token Manager...\")\n\tclose(tm.quitCh) // Signal the cleaner to stop\n\ttm.wg.Wait()     // Wait for the cleaner to finish gracefully\n\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\t// Optionally clear maps for explicit resource release, though GC would handle it eventually\n\ttm.tokens = make(map[string]Token)\n\ttm.userTokens = make(map[string]map[string]struct{})\n\tlog.Println(\"Token Manager shutdown complete.\")\n}\n\nfunc main() {\n\tmanager := NewTokenManager()\n\tdefer manager.Shutdown() // Ensure shutdown is called when main exits\n\n\tvar wg sync.WaitGroup\n\tlog.Println(\"Starting Token Manager test program...\")\n\n\t// --- Test Case 1: Create and validate tokens concurrently ---\n\tlog.Println(\"\\n--- Test Case 1: Concurrent token creation and validation ---\")\n\tuserCount := 3\n\ttokensPerUser := 5\n\tcreatedTokens := make(chan string, userCount*tokensPerUser)\n\n\t// Concurrently create tokens for multiple users\n\tfor i := 0; i < userCount; i++ {\n\t\tusername := fmt.Sprintf(\"user%d\", i)\n\t\twg.Add(1)\n\t\tgo func(u string) {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < tokensPerUser; j++ {\n\t\t\t\ttoken := manager.CreateToken(u)\n\t\t\t\tif token != \"\" {\n\t\t\t\t\tcreatedTokens <- token\n\t\t\t\t\t// log.Printf(\"[%s] Created token: %s\", u, token) // Commented for cleaner output\n\t\t\t\t}\n\t\t\t\ttime.Sleep(10 * time.Millisecond) // Simulate some work\n\t\t\t}\n\t\t}(username)\n\t}\n\twg.Wait()\n\tclose(createdTokens) // All creators are done, close the channel\n\n\t// Collect all created tokens for subsequent validation\n\tallTokens := []string{}\n\tfor token := range createdTokens {\n\t\tallTokens = append(allTokens, token)\n\t}\n\tlog.Printf(\"Created %d tokens for %d users.\", len(allTokens), userCount)\n\n\t// Concurrently validate tokens for a duration\n\tvalidationDuration := 3 * time.Second\n\tlog.Printf(\"Validating tokens concurrently for %v...\", validationDuration)\n\tstopValidation := make(chan struct{})\n\tgo func() {\n\t\ttime.Sleep(validationDuration)\n\t\tclose(stopValidation)\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tvalidationCounter := 0\n\t\tif len(allTokens) == 0 {\n\t\t\tlog.Println(\"No tokens to validate.\")\n\t\t\treturn\n\t\t}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-stopValidation:\n\t\t\t\tlog.Printf(\"Stopped concurrent validation. Total validations: %d\", validationCounter)\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\ttokenToValidate := allTokens[validationCounter%len(allTokens)] // Cycle through tokens\n\t\t\t\t// Assign username to _ as it's not used in the log here\n\t\t\t\t_, valid := manager.ValidateToken(tokenToValidate)\n\t\t\t\tif valid {\n\t\t\t\t\t// log.Printf(\"[Validator] Token %s for %s is valid and refreshed.\", tokenToValidate, username) // Commented for cleaner output\n\t\t\t\t\tvalidationCounter++\n\t\t\t\t} else {\n\t\t\t\t\t// log.Printf(\"[Validator] Token %s for %s is INVALID (could be expired or revoked).\", tokenToValidate, username) // Commented for cleaner output\n\t\t\t\t}\n\t\t\t\ttime.Sleep(50 * time.Millisecond) // Prevent busy-waiting\n\t\t\t}\n\t\t}\n\t}()\n\n\t// --- Test Case 2: Token Expiration ---\n\tlog.Println(\"\\n--- Test Case 2: Token Expiration ---\")\n\tuserA := \"user_expiration\"\n\ttokenA := manager.CreateToken(userA)\n\tif tokenA == \"\" {\n\t\tlog.Fatal(\"Failed to create token for expiration test.\")\n\t}\n\tlog.Printf(\"Created token for %s: %s. Will expire in %v.\", userA, tokenA, manager.expirationDuration)\n\n\t// Declare valid for this block\n\t_, valid := manager.ValidateToken(tokenA)\n\tlog.Printf(\"Immediately validating token %s: %t (Expected: true)\", tokenA, valid) // Should be true\n\n\tlog.Printf(\"Waiting for token %s to expire (approx %v + cleaner interval)...\", tokenA, manager.expirationDuration)\n\t// Wait slightly longer than expiration duration + cleaner interval to ensure cleaner has run\n\ttime.Sleep(manager.expirationDuration + manager.cleanerInterval + 100*time.Millisecond)\n\n\t_, valid = manager.ValidateToken(tokenA) // Reassign valid\n\tlog.Printf(\"Validating token %s after expiration: %t (Expected: false)\", tokenA, valid) // Should be false\n\n\t// --- Test Case 3: Revoke User ---\n\tlog.Println(\"\\n--- Test Case 3: Revoke User ---\")\n\tuserToRevoke := \"user_revoke\"\n\ttokenR1 := manager.CreateToken(userToRevoke)\n\ttokenR2 := manager.CreateToken(userToRevoke)\n\tif tokenR1 == \"\" || tokenR2 == \"\" {\n\t\tlog.Fatal(\"Failed to create tokens for revoke test.\")\n\t}\n\tlog.Printf(\"Created tokens for %s: %s, %s\", userToRevoke, tokenR1, tokenR2)\n\n\t// Declare valid for this block\n\t_, valid = manager.ValidateToken(tokenR1)\n\tlog.Printf(\"Validating token %s before revoke: %t (Expected: true)\", tokenR1, valid) // Should be true\n\n\tlog.Printf(\"Revoking all tokens for user %s...\", userToRevoke)\n\tmanager.RevokeUser(userToRevoke)\n\ttime.Sleep(50 * time.Millisecond) // Give a moment for any potential internal goroutine sync\n\n\t_, valid = manager.ValidateToken(tokenR1) // Reassign valid\n\tlog.Printf(\"Validating token %s after revoke: %t (Expected: false)\", tokenR1, valid) // Should be false\n\t_, valid = manager.ValidateToken(tokenR2) // Reassign valid\n\tlog.Printf(\"Validating token %s after revoke: %t (Expected: false)\", tokenR2, valid) // Should be false\n\n\t// --- Test Case 4: Refresh Token ---\n\tlog.Println(\"\\n--- Test Case 4: Refresh Token ---\")\n\tuserRefresh := \"user_refresh\"\n\ttokenRefresh := manager.CreateToken(userRefresh)\n\tif tokenRefresh == \"\" {\n\t\tlog.Fatal(\"Failed to create token for refresh test.\")\n\t}\n\tlog.Printf(\"Created token for %s: %s. Will expire in %v.\", userRefresh, tokenRefresh, manager.expirationDuration)\n\n\tlog.Printf(\"Waiting for %v before refreshing token...\", manager.expirationDuration/2)\n\ttime.Sleep(manager.expirationDuration / 2) // Wait half the expiration time\n\n\trefreshed := manager.RefreshToken(tokenRefresh)\n\tlog.Printf(\"Attempting to refresh token %s: %t (Expected: true)\", tokenRefresh, refreshed) // Should be true\n\n\t// Declare valid for this block or reassign if already declared\n\t_, valid = manager.ValidateToken(tokenRefresh)\n\tlog.Printf(\"Validating token %s immediately after refresh: %t (Expected: true)\", tokenRefresh, valid) // Should be true\n\n\tlog.Printf(\"Waiting for token %s to expire after refresh (approx %v + cleaner interval)...\", tokenRefresh, manager.expirationDuration)\n\ttime.Sleep(manager.expirationDuration + manager.cleanerInterval + 100*time.Millisecond)\n\n\t_, valid = manager.ValidateToken(tokenRefresh) // Reassign valid\n\tlog.Printf(\"Validating token %s after refreshed expiration: %t (Expected: false)\", tokenRefresh, valid) // Should be false\n\n\t// Wait for all concurrent test goroutines to finish before main exits\n\twg.Wait()\n\tlog.Println(\"\\nAll test cases completed. Program will now shut down.\")\n\t// manager.Shutdown() is called via defer\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}