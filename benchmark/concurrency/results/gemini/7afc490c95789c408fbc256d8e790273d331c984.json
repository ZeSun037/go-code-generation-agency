{
    "task": "7afc490c95789c408fbc256d8e790273d331c984.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// StatusInfo holds the current status of the TaskCoordinator.\ntype StatusInfo struct {\n\tTasksProcessed uint64\n\tIsRunning      bool\n\tCurrentState   string\n}\n\n// String implements the Stringer interface for StatusInfo, providing a human-readable representation.\nfunc (si StatusInfo) String() string {\n\treturn fmt.Sprintf(\"Status{TasksProcessed: %d, IsRunning: %t, CurrentState: \\\"%s\\\"}\",\n\t\tsi.TasksProcessed, si.IsRunning, si.CurrentState)\n}\n\n// TaskCoordinator manages task execution and maintains state.\ntype TaskCoordinator struct {\n\tmu             sync.RWMutex // Protects tasksProcessed, isRunning, currentState\n\ttasksProcessed uint64       // Counter for completed tasks\n\tisRunning      bool         // Indicates if the coordinator's processing loop is active\n\tcurrentState   string       // Descriptive string of the coordinator's state\n\n\tstopCh   chan struct{}  // Channel to signal the processing goroutine to stop\n\tworkerWg sync.WaitGroup // Waits for the processing goroutine to finish\n\tstopOnce sync.Once      // Ensures the stop signal is sent only once\n}\n\n// NewTaskCoordinator creates and initializes a new TaskCoordinator.\nfunc NewTaskCoordinator() *TaskCoordinator {\n\treturn &TaskCoordinator{\n\t\ttasksProcessed: 0,\n\t\tisRunning:      false,\n\t\tcurrentState:   \"idle\",\n\t\t// stopCh is initialized in Start() to allow potential restarts,\n\t\t// but for a single-use coordinator, initializing here is also fine.\n\t\t// Re-initializing in Start() makes it more robust for multiple Start/Stop cycles.\n\t}\n}\n\n// Start begins processing tasks in a background goroutine.\nfunc (tc *TaskCoordinator) Start() {\n\ttc.mu.Lock()\n\tif tc.isRunning {\n\t\ttc.mu.Unlock()\n\t\treturn // Coordinator is already running\n\t}\n\n\ttc.isRunning = true\n\ttc.currentState = \"processing\"\n\t// Re-initialize stopCh and stopOnce for each Start call to allow fresh start/stop cycles\n\ttc.stopCh = make(chan struct{})\n\ttc.stopOnce = sync.Once{}\n\ttc.mu.Unlock()\n\n\ttc.workerWg.Add(1)\n\tgo tc.processTasks() // Start the background task processing goroutine\n\tfmt.Println(\"Coordinator: started.\")\n}\n\n// processTasks is the background goroutine that simulates task execution.\nfunc (tc *TaskCoordinator) processTasks() {\n\tdefer tc.workerWg.Done() // Signal that this goroutine has completed when it exits\n\tfmt.Println(\"Coordinator: processing goroutine started.\")\n\n\t// Simulate processing a task every 20 milliseconds\n\tticker := time.NewTicker(20 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-tc.stopCh:\n\t\t\t// Received stop signal, exit the processing loop\n\t\t\tfmt.Println(\"Coordinator: processing goroutine received stop signal, exiting.\")\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\t// Time to simulate processing a task\n\t\t\ttc.mu.Lock()\n\t\t\t// Only increment if the coordinator is still marked as running.\n\t\t\t// This check helps prevent increments immediately after isRunning is set to false in Stop(),\n\t\t\t// but before the stopCh signal is fully processed.\n\t\t\tif tc.isRunning {\n\t\t\t\ttc.tasksProcessed++\n\t\t\t}\n\t\t\ttc.mu.Unlock()\n\t\t}\n\t}\n}\n\n// Stop gracefully shuts down the coordinator. It's safe to call multiple times.\nfunc (tc *TaskCoordinator) Stop() {\n\ttc.stopOnce.Do(func() {\n\t\ttc.mu.Lock()\n\t\tif !tc.isRunning {\n\t\t\t// If not running, ensure state reflects \"stopped\" and exit.\n\t\t\t// This covers cases where Start was never called, or it's already stopped.\n\t\t\ttc.currentState = \"stopped\"\n\t\t\ttc.mu.Unlock()\n\t\t\tfmt.Println(\"Coordinator: is already stopped or not running.\")\n\t\t\treturn\n\t\t}\n\n\t\t// Transition state to \"stopping\" and set isRunning to false immediately.\n\t\t// This ensures status queries reflect the shutdown phase without delay.\n\t\ttc.currentState = \"stopping\"\n\t\ttc.isRunning = false\n\t\ttc.mu.Unlock()\n\n\t\t// Signal the processing goroutine to stop\n\t\tclose(tc.stopCh)\n\n\t\t// Wait for the background worker goroutine to fully finish its shutdown\n\t\ttc.workerWg.Wait()\n\n\t\t// After the worker has exited, set the final state to \"stopped\"\n\t\ttc.mu.Lock()\n\t\ttc.currentState = \"stopped\"\n\t\ttc.mu.Unlock()\n\t\tfmt.Println(\"Coordinator: stopped.\")\n\t})\n}\n\n// Status returns the current state of the coordinator.\nfunc (tc *TaskCoordinator) Status() StatusInfo {\n\ttc.mu.RLock() // Use RLock for read access to allow concurrent reads\n\tdefer tc.mu.RUnlock()\n\n\treturn StatusInfo{\n\t\tTasksProcessed: tc.tasksProcessed,\n\t\tIsRunning:      tc.isRunning,\n\t\tCurrentState:   tc.currentState,\n\t}\n}\n\nfunc main() {\n\tcoordinator := NewTaskCoordinator()\n\n\t// Start the coordinator\n\tcoordinator.Start()\n\n\t// WaitGroup for managing query goroutines\n\tvar queryWg sync.WaitGroup\n\t// Channel to signal query goroutines to stop\n\tstopQueryCh := make(chan struct{})\n\n\t// Launch multiple goroutines to query the coordinator's status\n\tnumQueryers := 3\n\tfor i := 1; i <= numQueryers; i++ {\n\t\tqueryWg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer queryWg.Done()\n\t\t\t// Query every 100 milliseconds\n\t\t\tticker := time.NewTicker(100 * time.Millisecond)\n\t\t\tdefer ticker.Stop()\n\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\t// Get and print the current status\n\t\t\t\t\tstatus := coordinator.Status()\n\t\t\t\t\tfmt.Printf(\"Goroutine %d: %s\\n\", id, status.String())\n\t\t\t\tcase <-stopQueryCh:\n\t\t\t\t\t// Received stop signal for this query goroutine\n\t\t\t\t\tfmt.Printf(\"Goroutine %d: stopping status queries.\\n\", id)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Allow the coordinator to run and process tasks for a short period\n\tfmt.Println(\"Main: Allowing coordinator to run for 2 seconds...\")\n\ttime.Sleep(2 * time.Second)\n\n\t// Stop the coordinator\n\tcoordinator.Stop()\n\tfmt.Println(\"Main: Coordinator signalled to stop.\")\n\n\t// Allow some time for status queries to continue after the coordinator has officially stopped.\n\t// This demonstrates that status queries still function correctly and return the stopped state.\n\tfmt.Println(\"Main: Allowing queries to continue for 1 second after coordinator stopped...\")\n\ttime.Sleep(1 * time.Second)\n\n\t// Signal all query goroutines to stop and wait for them to finish\n\tfmt.Println(\"Main: Signalling query goroutines to stop.\")\n\tclose(stopQueryCh)\n\tqueryWg.Wait() // Ensure all query goroutines have exited\n\n\tfmt.Println(\"Main: Program completed successfully.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}