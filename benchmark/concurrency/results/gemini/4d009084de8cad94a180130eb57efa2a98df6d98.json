{
    "task": "4d009084de8cad94a180130eb57efa2a98df6d98.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Plugin represents a single plugin with its lifecycle management.\ntype Plugin struct {\n\tName    string\n\tactive  atomic.Bool   // Status: true if active, false if inactive. Atomic for concurrent updates.\n\texitCh  chan struct{} // Channel to signal the plugin's goroutine to stop.\n\twg      sync.WaitGroup // Used to wait for the plugin's goroutine to finish.\n\tlogMu   sync.Mutex     // Protects fmt.Printf calls to prevent interleaved output from multiple plugins.\n}\n\n// Run simulates the plugin's work. It runs in its own goroutine when activated.\nfunc (p *Plugin) Run() {\n\tp.wg.Add(1)\n\tdefer p.wg.Done()\n\n\tp.active.Store(true) // Mark plugin as active\n\tp.logMu.Lock()\n\tfmt.Printf(\"[%s] Plugin started.\\n\", p.Name)\n\tp.logMu.Unlock()\n\n\tticker := time.NewTicker(500 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// Simulate periodic work\n\t\t\tp.logMu.Lock()\n\t\t\tfmt.Printf(\"[%s] Working...\\n\", p.Name)\n\t\t\tp.logMu.Unlock()\n\t\tcase <-p.exitCh: // Received shutdown signal\n\t\t\tp.logMu.Lock()\n\t\t\tfmt.Printf(\"[%s] Shutdown signal received.\\n\", p.Name)\n\t\t\tp.logMu.Unlock()\n\t\t\tp.active.Store(false) // Mark plugin as inactive\n\t\t\treturn // Exit the goroutine\n\t\t}\n\t}\n}\n\n// Stop signals the plugin's goroutine to shut down and waits for it to finish.\nfunc (p *Plugin) Stop() {\n\t// Only close the channel if it hasn't been closed already.\n\t// This prevents panic if Stop is called multiple times.\n\tselect {\n\tcase <-p.exitCh:\n\t\t// Channel is already closed or a signal has been sent.\n\t\t// No need to close again.\n\tdefault:\n\t\t// Channel is open, send shutdown signal by closing it.\n\t\tclose(p.exitCh)\n\t}\n\tp.wg.Wait() // Wait for the plugin's Run() goroutine to complete its shutdown.\n\tp.logMu.Lock()\n\tfmt.Printf(\"[%s] Plugin stopped.\\n\", p.Name)\n\tp.logMu.Unlock()\n}\n\n// PluginManager manages the lifecycle of multiple plugins.\ntype PluginManager struct {\n\tplugins map[string]*Plugin // Stores registered plugins by name.\n\tmu      sync.RWMutex      // Protects concurrent access to the plugins map.\n}\n\n// NewPluginManager creates and returns a new PluginManager.\nfunc NewPluginManager() *PluginManager {\n\treturn &PluginManager{\n\t\tplugins: make(map[string]*Plugin),\n\t}\n}\n\n// Register adds a new plugin to the manager.\n// Returns an error if a plugin with the same name already exists.\nfunc (pm *PluginManager) Register(name string) error {\n\tpm.mu.Lock() // Acquire write lock to modify the plugins map.\n\tdefer pm.mu.Unlock()\n\n\tif _, exists := pm.plugins[name]; exists {\n\t\treturn fmt.Errorf(\"plugin '%s' already registered\", name)\n\t}\n\n\tp := &Plugin{\n\t\tName:   name,\n\t\texitCh: make(chan struct{}), // Initialize channel, will be reset on activate\n\t}\n\tpm.plugins[name] = p\n\tfmt.Printf(\"Manager: Registered plugin '%s'.\\n\", name)\n\treturn nil\n}\n\n// Activate starts a registered plugin's work goroutine and marks it as active.\n// Returns an error if the plugin is not found or is already active.\nfunc (pm *PluginManager) Activate(name string) error {\n\tpm.mu.RLock() // Acquire read lock to safely access the plugins map.\n\tp, exists := pm.plugins[name]\n\tpm.mu.RUnlock() // Release read lock.\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"plugin '%s' not found\", name)\n\t}\n\n\tif p.active.Load() { // Check active status using atomic load without manager's map lock.\n\t\treturn fmt.Errorf(\"plugin '%s' is already active\", name)\n\t}\n\n\t// For a fresh activation, re-create the exit channel.\n\t// This ensures that if a plugin was previously stopped and reactivated,\n\t// it gets a new, open channel for communication.\n\tp.exitCh = make(chan struct{})\n\tgo p.Run() // Start the plugin's main work goroutine.\n\n\tfmt.Printf(\"Manager: Activated plugin '%s'.\\n\", name)\n\treturn nil\n}\n\n// Deactivate stops a running plugin and marks it as inactive.\n// Returns an error if the plugin is not found or is already inactive.\nfunc (pm *PluginManager) Deactivate(name string) error {\n\tpm.mu.RLock() // Acquire read lock to safely access the plugins map.\n\tp, exists := pm.plugins[name]\n\tpm.mu.RUnlock() // Release read lock.\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"plugin '%s' not found\", name)\n\t}\n\n\tif !p.active.Load() { // Check active status using atomic load.\n\t\treturn fmt.Errorf(\"plugin '%s' is already inactive\", name)\n\t}\n\n\tp.Stop() // Signal the plugin to stop and wait for its goroutine to exit.\n\tfmt.Printf(\"Manager: Deactivated plugin '%s'.\\n\", name)\n\treturn nil\n}\n\n// Shutdown gracefully stops all currently active plugins managed by the system.\n// It iterates through active plugins, signals them to stop concurrently,\n// and waits for all of them to complete their shutdown.\nfunc (pm *PluginManager) Shutdown() {\n\tfmt.Println(\"Manager: Initiating shutdown for all active plugins...\")\n\n\tvar pluginsToStop []*Plugin\n\n\tpm.mu.RLock() // Acquire read lock to safely iterate and collect active plugins.\n\tfor _, p := range pm.plugins {\n\t\tif p.active.Load() { // Check if plugin is active without holding the manager's map lock for long.\n\t\t\tpluginsToStop = append(pluginsToStop, p)\n\t\t}\n\t}\n\tpm.mu.RUnlock() // Release read lock.\n\n\tvar wg sync.WaitGroup\n\tfor _, p := range pluginsToStop {\n\t\twg.Add(1)\n\t\tgo func(plugin *Plugin) {\n\t\t\tdefer wg.Done()\n\t\t\t// Call Deactivate, which will handle signaling the plugin's goroutine\n\t\t\t// and waiting for it to finish.\n\t\t\terr := pm.Deactivate(plugin.Name)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Manager: Error deactivating plugin '%s' during shutdown: %v\\n\", plugin.Name, err)\n\t\t\t}\n\t\t}(p)\n\t}\n\twg.Wait() // Wait for all deactivation goroutines to complete.\n\tfmt.Println(\"Manager: All active plugins have been shut down.\")\n}\n\n// GetPluginStatus returns a map showing the current active status of all registered plugins.\n// This serves as the in-memory state persistence.\nfunc (pm *PluginManager) GetPluginStatus() map[string]bool {\n\tpm.mu.RLock()\n\tdefer pm.mu.RUnlock()\n\n\tstatus := make(map[string]bool)\n\tfor name, p := range pm.plugins {\n\t\tstatus[name] = p.active.Load() // Get current status using atomic load.\n\t}\n\treturn status\n}\n\nfunc main() {\n\tmanager := NewPluginManager()\n\n\t// 1. Plugin Registration\n\tmanager.Register(\"plugin1\")\n\tmanager.Register(\"plugin2\")\n\tmanager.Register(\"plugin3\")\n\tmanager.Register(\"plugin4\") // This plugin will be activated later\n\n\t// 2. Plugin Activation\n\tfmt.Println(\"\\n--- Activating plugins ---\")\n\tmanager.Activate(\"plugin1\")\n\tmanager.Activate(\"plugin2\")\n\n\t// Demonstrate error handling for activation\n\tif err := manager.Activate(\"plugin1\"); err != nil {\n\t\tfmt.Printf(\"Attempted to activate already active plugin: %v\\n\", err)\n\t}\n\tif err := manager.Activate(\"nonexistent-plugin\"); err != nil {\n\t\tfmt.Printf(\"Attempted to activate non-existent plugin: %v\\n\", err)\n\t}\n\n\t// Simulate some work and check current state\n\tfmt.Println(\"\\n--- Simulating work (2 seconds) ---\")\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Current Plugin Status:\", manager.GetPluginStatus())\n\n\t// 3. Plugin Deactivation\n\tfmt.Println(\"\\n--- Deactivating plugin2 ---\")\n\tmanager.Deactivate(\"plugin2\")\n\n\t// Demonstrate error handling for deactivation\n\tif err := manager.Deactivate(\"plugin2\"); err != nil {\n\t\tfmt.Printf(\"Attempted to deactivate already inactive plugin: %v\\n\", err)\n\t}\n\n\t// Activate another plugin\n\tfmt.Println(\"\\n--- Activating plugin3 ---\")\n\tmanager.Activate(\"plugin3\")\n\n\tfmt.Println(\"\\n--- Simulating more work (1 second) ---\")\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"Current Plugin Status:\", manager.GetPluginStatus())\n\n\t// Demonstrate concurrent activation of plugin4\n\tfmt.Println(\"\\n--- Concurrent activation attempt for plugin4 ---\")\n\tvar wgConcurrent sync.WaitGroup\n\twgConcurrent.Add(1)\n\tgo func() {\n\t\tdefer wgConcurrent.Done()\n\t\tif err := manager.Activate(\"plugin4\"); err != nil {\n\t\t\tfmt.Printf(\"Concurrent Activate plugin4 error: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Manager: Concurrently activated plugin 'plugin4'.\")\n\t\t}\n\t}()\n\ttime.Sleep(50 * time.Millisecond) // Give the goroutine a chance to run\n\tfmt.Println(\"Current Plugin Status (mid-concurrent-op):\", manager.GetPluginStatus())\n\twgConcurrent.Wait() // Wait for concurrent activation to finish\n\tfmt.Println(\"Current Plugin Status (post-concurrent-op):\", manager.GetPluginStatus())\n\n\t// 4. Shutdown all active plugins\n\tfmt.Println(\"\\n--- Shutting down all active plugins ---\")\n\tmanager.Shutdown()\n\tfmt.Println(\"Final Plugin Status:\", manager.GetPluginStatus())\n\n\t// Verify all are inactive after shutdown\n\tfor name, active := range manager.GetPluginStatus() {\n\t\tif active {\n\t\t\tfmt.Printf(\"ERROR: Plugin '%s' is still active after shutdown.\\n\", name)\n\t\t}\n\t}\n\tfmt.Println(\"System shutdown complete and verified.\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[37;40m/tmp/go_synthesis__sjh9nn9/main.go:228\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    227: \tfmt.Println(\"\\n--- Activating plugin3 ---\")\n  > 228: \tmanager.Activate(\"plugin3\")\n    229: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis__sjh9nn9/main.go:219\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    218: \tfmt.Println(\"\\n--- Deactivating plugin2 ---\")\n  > 219: \tmanager.Deactivate(\"plugin2\")\n    220: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis__sjh9nn9/main.go:202\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    201: \tmanager.Activate(\"plugin1\")\n  > 202: \tmanager.Activate(\"plugin2\")\n    203: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis__sjh9nn9/main.go:201\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    200: \tfmt.Println(\"\\n--- Activating plugins ---\")\n  > 201: \tmanager.Activate(\"plugin1\")\n    202: \tmanager.Activate(\"plugin2\")\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis__sjh9nn9/main.go:197\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    196: \tmanager.Register(\"plugin3\")\n  > 197: \tmanager.Register(\"plugin4\") // This plugin will be activated later\n    198: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis__sjh9nn9/main.go:196\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    195: \tmanager.Register(\"plugin2\")\n  > 196: \tmanager.Register(\"plugin3\")\n    197: \tmanager.Register(\"plugin4\") // This plugin will be activated later\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis__sjh9nn9/main.go:195\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    194: \tmanager.Register(\"plugin1\")\n  > 195: \tmanager.Register(\"plugin2\")\n    196: \tmanager.Register(\"plugin3\")\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis__sjh9nn9/main.go:194\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    193: \t// 1. Plugin Registration\n  > 194: \tmanager.Register(\"plugin1\")\n    195: \tmanager.Register(\"plugin2\")\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 263\n  Nosec  : 0\n  Issues : \u001b[1;31m8\u001b[0m\n\n[gosec] 2025/12/01 12:57:16 Including rules: default\n[gosec] 2025/12/01 12:57:16 Excluding rules: default\n[gosec] 2025/12/01 12:57:16 Including analyzers: default\n[gosec] 2025/12/01 12:57:16 Excluding analyzers: default\n[gosec] 2025/12/01 12:57:16 Import directory: /tmp/go_synthesis__sjh9nn9\n[gosec] 2025/12/01 12:57:16 Checking package: main\n[gosec] 2025/12/01 12:57:16 Checking file: /tmp/go_synthesis__sjh9nn9/main.go"
                },
                {
                    "verifier": "errcheck",
                    "error": "main.go:194:18:\tmanager.Register(\"plugin1\")\nmain.go:195:18:\tmanager.Register(\"plugin2\")\nmain.go:196:18:\tmanager.Register(\"plugin3\")\nmain.go:197:18:\tmanager.Register(\"plugin4\") // This plugin will be activated later\nmain.go:201:18:\tmanager.Activate(\"plugin1\")\nmain.go:202:18:\tmanager.Activate(\"plugin2\")\nmain.go:219:20:\tmanager.Deactivate(\"plugin2\")\nmain.go:228:18:\tmanager.Activate(\"plugin3\")"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Plugin represents a single plugin with its lifecycle management.\ntype Plugin struct {\n\tName    string\n\tactive  atomic.Bool   // Status: true if active, false if inactive. Atomic for concurrent updates.\n\texitCh  chan struct{} // Channel to signal the plugin's goroutine to stop.\n\twg      sync.WaitGroup // Used to wait for the plugin's goroutine to finish.\n\tlogMu   sync.Mutex     // Protects fmt.Printf calls to prevent interleaved output from multiple plugins.\n}\n\n// Run simulates the plugin's work. It runs in its own goroutine when activated.\nfunc (p *Plugin) Run() {\n\tp.wg.Add(1)\n\tdefer p.wg.Done()\n\n\tp.active.Store(true) // Mark plugin as active\n\tp.logMu.Lock()\n\tfmt.Printf(\"[%s] Plugin started.\\n\", p.Name)\n\tp.logMu.Unlock()\n\n\tticker := time.NewTicker(500 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// Simulate periodic work\n\t\t\tp.logMu.Lock()\n\t\t\tfmt.Printf(\"[%s] Working...\\n\", p.Name)\n\t\t\tp.logMu.Unlock()\n\t\tcase <-p.exitCh: // Received shutdown signal\n\t\t\tp.logMu.Lock()\n\t\t\tfmt.Printf(\"[%s] Shutdown signal received.\\n\", p.Name)\n\t\t\tp.logMu.Unlock()\n\t\t\tp.active.Store(false) // Mark plugin as inactive\n\t\t\treturn // Exit the goroutine\n\t\t}\n\t}\n}\n\n// Stop signals the plugin's goroutine to shut down and waits for it to finish.\nfunc (p *Plugin) Stop() {\n\t// Attempt to close the channel only if it's not already closed.\n\t// This approach is not entirely safe for concurrent `Stop` calls if `exitCh`\n\t// can be nil or recreated. A safer pattern is to ensure `exitCh` is created\n\t// once per plugin activation cycle and only closed once.\n\t// The manager's Deactivate/Shutdown methods should guarantee single `Stop` calls for active plugins.\n\t// However, if external code calls `Stop` multiple times concurrently, a check is needed.\n\t// Here, the manager's logic ensures it's only called if active.\n\tselect {\n\tcase <-p.exitCh: // Check if the channel is already closed or a signal has been sent\n\t\t// This case means the channel is already closed or has received a signal.\n\t\t// No need to close again. This can happen if another goroutine signals it.\n\t\t// Or if Stop is called multiple times on the same plugin instance.\n\tdefault:\n\t\t// Channel is open, send shutdown signal by closing it.\n\t\t// Closing a closed channel panics. This check prevents that.\n\t\tclose(p.exitCh)\n\t}\n\tp.wg.Wait() // Wait for the plugin's Run() goroutine to complete its shutdown.\n\tp.logMu.Lock()\n\tfmt.Printf(\"[%s] Plugin stopped.\\n\", p.Name)\n\tp.logMu.Unlock()\n}\n\n// PluginManager manages the lifecycle of multiple plugins.\ntype PluginManager struct {\n\tplugins map[string]*Plugin // Stores registered plugins by name.\n\tmu      sync.RWMutex      // Protects concurrent access to the plugins map.\n}\n\n// NewPluginManager creates and returns a new PluginManager.\nfunc NewPluginManager() *PluginManager {\n\treturn &PluginManager{\n\t\tplugins: make(map[string]*Plugin),\n\t}\n}\n\n// Register adds a new plugin to the manager.\n// Returns an error if a plugin with the same name already exists.\nfunc (pm *PluginManager) Register(name string) error {\n\tpm.mu.Lock() // Acquire write lock to modify the plugins map.\n\tdefer pm.mu.Unlock()\n\n\tif _, exists := pm.plugins[name]; exists {\n\t\treturn fmt.Errorf(\"plugin '%s' already registered\", name)\n\t}\n\n\tp := &Plugin{\n\t\tName:   name,\n\t\t// exitCh is intentionally not initialized here. It will be created fresh on Activate\n\t\t// to ensure a clean channel for each activation cycle.\n\t}\n\tpm.plugins[name] = p\n\tfmt.Printf(\"Manager: Registered plugin '%s'.\\n\", name)\n\treturn nil\n}\n\n// Activate starts a registered plugin's work goroutine and marks it as active.\n// Returns an error if the plugin is not found or is already active.\nfunc (pm *PluginManager) Activate(name string) error {\n\tpm.mu.RLock() // Acquire read lock to safely access the plugins map.\n\tp, exists := pm.plugins[name]\n\tpm.mu.RUnlock() // Release read lock.\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"plugin '%s' not found\", name)\n\t}\n\n\t// Check active status using atomic load without manager's map lock.\n\tif p.active.Load() {\n\t\treturn fmt.Errorf(\"plugin '%s' is already active\", name)\n\t}\n\n\t// It's crucial to ensure `exitCh` is a fresh, unclosed channel for a new activation.\n\t// If a plugin was deactivated, its `exitCh` would have been closed.\n\t// Resetting it here guarantees a clean start.\n\tp.exitCh = make(chan struct{})\n\tgo p.Run() // Start the plugin's main work goroutine.\n\n\tfmt.Printf(\"Manager: Activated plugin '%s'.\\n\", name)\n\treturn nil\n}\n\n// Deactivate stops a running plugin and marks it as inactive.\n// Returns an error if the plugin is not found or is already inactive.\nfunc (pm *PluginManager) Deactivate(name string) error {\n\tpm.mu.RLock() // Acquire read lock to safely access the plugins map.\n\tp, exists := pm.plugins[name]\n\tpm.mu.RUnlock() // Release read lock.\n\n\tif !exists {\n\t\treturn fmt.Errorf(\"plugin '%s' not found\", name)\n\t}\n\n\t// Check active status using atomic load.\n\tif !p.active.Load() {\n\t\treturn fmt.Errorf(\"plugin '%s' is already inactive\", name)\n\t}\n\n\tp.Stop() // Signal the plugin to stop and wait for its goroutine to exit.\n\tfmt.Printf(\"Manager: Deactivated plugin '%s'.\\n\", name)\n\treturn nil\n}\n\n// Shutdown gracefully stops all currently active plugins managed by the system.\n// It iterates through active plugins, signals them to stop concurrently,\n// and waits for all of them to complete their shutdown.\nfunc (pm *PluginManager) Shutdown() {\n\tfmt.Println(\"Manager: Initiating shutdown for all active plugins...\")\n\n\tvar pluginsToStop []*Plugin\n\n\tpm.mu.RLock() // Acquire read lock to safely iterate and collect active plugins.\n\tfor _, p := range pm.plugins {\n\t\t// Only consider plugins that are marked as active *before* initiating shutdown.\n\t\t// This prevents attempting to stop plugins that might have just become inactive\n\t\t// due to external concurrent Deactivate calls, or plugins that were never active.\n\t\tif p.active.Load() {\n\t\t\tpluginsToStop = append(pluginsToStop, p)\n\t\t}\n\t}\n\tpm.mu.RUnlock() // Release read lock.\n\n\tvar wg sync.WaitGroup\n\tfor _, p := range pluginsToStop {\n\t\twg.Add(1)\n\t\tgo func(plugin *Plugin) {\n\t\t\tdefer wg.Done()\n\t\t\t// Call Deactivate, which will handle signaling the plugin's goroutine\n\t\t\t// and waiting for it to finish.\n\t\t\terr := pm.Deactivate(plugin.Name)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Manager: Error deactivating plugin '%s' during shutdown: %v\\n\", plugin.Name, err)\n\t\t\t}\n\t\t}(p)\n\t}\n\twg.Wait() // Wait for all deactivation goroutines to complete.\n\tfmt.Println(\"Manager: All active plugins have been shut down.\")\n}\n\n// GetPluginStatus returns a map showing the current active status of all registered plugins.\n// This serves as the in-memory state persistence.\nfunc (pm *PluginManager) GetPluginStatus() map[string]bool {\n\tpm.mu.RLock()\n\tdefer pm.mu.RUnlock()\n\n\tstatus := make(map[string]bool)\n\tfor name, p := range pm.plugins {\n\t\tstatus[name] = p.active.Load() // Get current status using atomic load.\n\t}\n\treturn status\n}\n\nfunc main() {\n\tmanager := NewPluginManager()\n\n\t// 1. Plugin Registration\n\tif err := manager.Register(\"plugin1\"); err != nil {\n\t\tfmt.Printf(\"Error registering plugin1: %v\\n\", err)\n\t}\n\tif err := manager.Register(\"plugin2\"); err != nil {\n\t\tfmt.Printf(\"Error registering plugin2: %v\\n\", err)\n\t}\n\tif err := manager.Register(\"plugin3\"); err != nil {\n\t\tfmt.Printf(\"Error registering plugin3: %v\\n\", err)\n\t}\n\tif err := manager.Register(\"plugin4\"); err != nil { // This plugin will be activated later\n\t\tfmt.Printf(\"Error registering plugin4: %v\\n\", err)\n\t}\n\n\t// 2. Plugin Activation\n\tfmt.Println(\"\\n--- Activating plugins ---\")\n\tif err := manager.Activate(\"plugin1\"); err != nil {\n\t\tfmt.Printf(\"Error activating plugin1: %v\\n\", err)\n\t}\n\tif err := manager.Activate(\"plugin2\"); err != nil {\n\t\tfmt.Printf(\"Error activating plugin2: %v\\n\", err)\n\t}\n\n\t// Demonstrate error handling for activation\n\tif err := manager.Activate(\"plugin1\"); err != nil {\n\t\tfmt.Printf(\"Attempted to activate already active plugin: %v\\n\", err)\n\t}\n\tif err := manager.Activate(\"nonexistent-plugin\"); err != nil {\n\t\tfmt.Printf(\"Attempted to activate non-existent plugin: %v\\n\", err)\n\t}\n\n\t// Simulate some work and check current state\n\tfmt.Println(\"\\n--- Simulating work (2 seconds) ---\")\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Current Plugin Status:\", manager.GetPluginStatus())\n\n\t// 3. Plugin Deactivation\n\tfmt.Println(\"\\n--- Deactivating plugin2 ---\")\n\tif err := manager.Deactivate(\"plugin2\"); err != nil {\n\t\tfmt.Printf(\"Error deactivating plugin2: %v\\n\", err)\n\t}\n\n\t// Demonstrate error handling for deactivation\n\tif err := manager.Deactivate(\"plugin2\"); err != nil {\n\t\tfmt.Printf(\"Attempted to deactivate already inactive plugin: %v\\n\", err)\n\t}\n\n\t// Activate another plugin\n\tfmt.Println(\"\\n--- Activating plugin3 ---\")\n\tif err := manager.Activate(\"plugin3\"); err != nil {\n\t\tfmt.Printf(\"Error activating plugin3: %v\\n\", err)\n\t}\n\n\tfmt.Println(\"\\n--- Simulating more work (1 second) ---\")\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"Current Plugin Status:\", manager.GetPluginStatus())\n\n\t// Demonstrate concurrent activation of plugin4\n\tfmt.Println(\"\\n--- Concurrent activation attempt for plugin4 ---\")\n\tvar wgConcurrent sync.WaitGroup\n\twgConcurrent.Add(1)\n\tgo func() {\n\t\tdefer wgConcurrent.Done()\n\t\tif err := manager.Activate(\"plugin4\"); err != nil {\n\t\t\tfmt.Printf(\"Concurrent Activate plugin4 error: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Manager: Concurrently activated plugin 'plugin4'.\")\n\t\t}\n\t}()\n\ttime.Sleep(50 * time.Millisecond) // Give the goroutine a chance to run\n\tfmt.Println(\"Current Plugin Status (mid-concurrent-op):\", manager.GetPluginStatus())\n\twgConcurrent.Wait() // Wait for concurrent activation to finish\n\tfmt.Println(\"Current Plugin Status (post-concurrent-op):\", manager.GetPluginStatus())\n\n\t// 4. Shutdown all active plugins\n\tfmt.Println(\"\\n--- Shutting down all active plugins ---\")\n\tmanager.Shutdown()\n\tfmt.Println(\"Final Plugin Status:\", manager.GetPluginStatus())\n\n\t// Verify all are inactive after shutdown\n\tfor name, active := range manager.GetPluginStatus() {\n\t\tif active {\n\t\t\tfmt.Printf(\"ERROR: Plugin '%s' is still active after shutdown.\\n\", name)\n\t\t}\n\t}\n\tfmt.Println(\"System shutdown complete and verified.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}