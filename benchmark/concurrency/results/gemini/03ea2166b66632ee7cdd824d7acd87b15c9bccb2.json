{
    "task": "03ea2166b66632ee7cdd824d7acd87b15c9bccb2.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// Container represents a single container instance.\ntype Container struct {\n\tID       string\n\tName     string\n\tRunning  bool\n\tExitCode int // Only relevant when Running is false. Default -1 when running.\n}\n\n// ContainerManager manages a collection of containers.\ntype ContainerManager struct {\n\tmu         sync.RWMutex\n\tcontainers map[string]*Container // Map from ID to Container\n}\n\n// NewContainerManager creates and returns a new ContainerManager.\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t}\n}\n\n// StartContainer creates and starts a new container.\n// It returns the ID of the newly started container.\nfunc (cm *ContainerManager) StartContainer(name string) string {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tid := uuid.NewString()\n\tcontainer := &Container{\n\t\tID:       id,\n\t\tName:     name,\n\t\tRunning:  true,\n\t\tExitCode: -1, // No exit code yet, as it's running\n\t}\n\tcm.containers[id] = container\n\tfmt.Printf(\"Started container: %s %s\\n\", container.ID[:8], container.Name) // Truncate ID for brevity\n\treturn id\n}\n\n// StopContainer stops a running container with the specified exit code.\n// It returns true if the container was found and stopped, false otherwise.\nfunc (cm *ContainerManager) StopContainer(id string, exitCode int) bool {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tif container, ok := cm.containers[id]; ok && container.Running {\n\t\tcontainer.Running = false\n\t\tcontainer.ExitCode = exitCode\n\t\tfmt.Printf(\"Stopped container: %s with exit code: %d\\n\", container.ID[:8], container.ExitCode) // Truncate ID for brevity\n\t\treturn true\n\t}\n\treturn false // Container not found or not running\n}\n\n// ListContainers lists all containers, optionally filtered by exit code.\n// If filterExitCode is nil, all containers are returned.\n// Otherwise, only containers that are not running and have the matching exit code are returned.\nfunc (cm *ContainerManager) ListContainers(filterExitCode *int) []*Container {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tvar result []*Container\n\tfor _, container := range cm.containers {\n\t\tif filterExitCode == nil {\n\t\t\t// No filter, include all containers\n\t\t\tresult = append(result, container)\n\t\t} else {\n\t\t\t// Filter by exit code\n\t\t\tif !container.Running && container.ExitCode == *filterExitCode {\n\t\t\t\tresult = append(result, container)\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\t// Initialize random seed for time.Sleep simulations\n\trand.Seed(time.Now().UnixNano())\n\n\tmanager := NewContainerManager()\n\tvar startWg sync.WaitGroup   // WaitGroup for starting containers\n\tvar stopWg sync.WaitGroup    // WaitGroup for stopping containers\n\tvar listingWg sync.WaitGroup // WaitGroup for listing goroutines\n\n\tconst numContainers = 10\n\t// Channel to pass container IDs from start operations to stop operations\n\tcontainerIDsChan := make(chan string, numContainers)\n\n\tfmt.Println(\"--- Starting Containers ---\")\n\t// Start 10 containers concurrently\n\tfor i := 0; i < numContainers; i++ {\n\t\tstartWg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer startWg.Done()\n\t\t\tname := fmt.Sprintf(\"container-%d\", i+1)\n\t\t\tid := manager.StartContainer(name)\n\t\t\tcontainerIDsChan <- id\n\t\t}(i)\n\t}\n\tstartWg.Wait() // Wait for all containers to be started\n\tclose(containerIDsChan) // Close the channel as no more IDs will be sent\n\n\t// Collect IDs into a slice to distribute for stopping\n\tidsToStop := make([]string, 0, numContainers)\n\tfor id := range containerIDsChan {\n\t\tidsToStop = append(idsToStop, id)\n\t}\n\n\tfmt.Println(\"\\n--- Stopping Containers & Concurrent Listing ---\")\n\t// Context to signal listing goroutines to stop gracefully\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // Ensure cancel is called if main exits early\n\n\t// Start listing goroutines\n\tnumListingGoroutines := 5\n\tfor i := 0; i < numListingGoroutines; i++ {\n\t\tlistingWg.Add(1)\n\t\tgo func(goroutineID int) {\n\t\t\tdefer listingWg.Done()\n\t\t\tfilter := goroutineID % 2 // Alternate filters: 0 or 1\n\t\t\tfilterPtr := &filter      // Pointer to the filter value\n\t\t\tticker := time.NewTicker(100 * time.Millisecond) // List every 100ms\n\t\t\tdefer ticker.Stop()\n\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t// Context was cancelled, time to stop this goroutine\n\t\t\t\t\treturn\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\t// It's time to list containers\n\t\t\t\t\tcontainers := manager.ListContainers(filterPtr)\n\t\t\t\t\t// Build a list of short IDs for printing\n\t\t\t\t\tvar containerIDsForPrint []string\n\t\t\t\t\tfor _, c := range containers {\n\t\t\t\t\t\tcontainerIDsForPrint = append(containerIDsForPrint, c.ID[:8])\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Printf(\"Listing containers with exit code %d (goroutine %d): %v\\n\", *filterPtr, goroutineID, containerIDsForPrint)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Stop 5 containers with exit code 0 and 5 with exit code 1 concurrently\n\tfor i, id := range idsToStop {\n\t\tstopWg.Add(1)\n\t\tgo func(id string, exitCode int) {\n\t\t\tdefer stopWg.Done()\n\t\t\t// Simulate some variable work before stopping\n\t\t\ttime.Sleep(time.Duration(rand.Intn(200)+50) * time.Millisecond)\n\t\t\tmanager.StopContainer(id, exitCode)\n\t\t}(id, i%2) // Assign exit code 0 or 1 based on index\n\t}\n\n\tstopWg.Wait() // Wait for all stop operations to complete\n\tcancel()      // Signal listing goroutines to stop\n\tlistingWg.Wait() // Wait for all listing goroutines to finish\n\n\tfmt.Println(\"\\n--- Final Checks ---\")\n\t// Final list of all containers to verify the overall state\n\tallContainers := manager.ListContainers(nil)\n\tfmt.Printf(\"Total containers managed: %d\\n\", len(allContainers))\n\n\trunningCount := 0\n\texit0Count := 0\n\texit1Count := 0\n\tfor _, c := range allContainers {\n\t\tif c.Running {\n\t\t\trunningCount++\n\t\t} else {\n\t\t\tif c.ExitCode == 0 {\n\t\t\t\texit0Count++\n\t\t\t} else if c.ExitCode == 1 {\n\t\t\t\texit1Count++\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"Running containers: %d\\n\", runningCount)\n\tfmt.Printf(\"Exited with code 0: %d\\n\", exit0Count)\n\tfmt.Printf(\"Exited with code 1: %d\\n\", exit1Count)\n\n\t// Final verification of filtered lists\n\tfiltered0 := manager.ListContainers(intPtr(0))\n\tfmt.Printf(\"Final list exit code 0: %d containers %v\\n\", len(filtered0), containerIDsToPrint(filtered0))\n\tfiltered1 := manager.ListContainers(intPtr(1))\n\tfmt.Printf(\"Final list exit code 1: %d containers %v\\n\", len(filtered1), containerIDsToPrint(filtered1))\n\n\tfmt.Println(\"\\nAll operations completed successfully!\")\n}\n\n// intPtr is a helper function to return a pointer to an integer literal.\nfunc intPtr(i int) *int {\n\treturn &i\n}\n\n// containerIDsToPrint is a helper function to extract and format short IDs from a slice of Containers.\nfunc containerIDsToPrint(containers []*Container) []string {\n\tvar ids []string\n\tfor _, c := range containers {\n\t\tids = append(ids, c.ID[:8]) // Truncate ID for brevity\n\t}\n\treturn ids\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_ak2d_aoo/main.go:163\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    162: \t\t\t// Simulate some variable work before stopping\n  > 163: \t\t\ttime.Sleep(time.Duration(rand.Intn(200)+50) * time.Millisecond)\n    164: \t\t\tmanager.StopContainer(id, exitCode)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 216\n  Nosec  : 0\n  Issues : \u001b[1;31m1\u001b[0m\n\n[gosec] 2025/12/01 12:17:41 Including rules: default\n[gosec] 2025/12/01 12:17:41 Excluding rules: default\n[gosec] 2025/12/01 12:17:41 Including analyzers: default\n[gosec] 2025/12/01 12:17:41 Excluding analyzers: default\n[gosec] 2025/12/01 12:17:41 Import directory: /tmp/go_synthesis_ak2d_aoo\n[gosec] 2025/12/01 12:17:42 Checking package: main\n[gosec] 2025/12/01 12:17:42 Checking file: /tmp/go_synthesis_ak2d_aoo/main.go"
                },
                {
                    "verifier": "staticcheck",
                    "error": "main.go:91:2: rand.Seed has been deprecated since Go 1.20 and an alternative has been available since Go 1.0: As of Go 1.20 there is no reason to call Seed with a random value. Programs that call Seed with a known value to get a specific sequence of results should use New(NewSource(seed)) to obtain a local random generator. (SA1019)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// Container represents a single container instance.\ntype Container struct {\n\tID       string\n\tName     string\n\tRunning  bool\n\tExitCode int // Only relevant when Running is false. Default -1 when running.\n}\n\n// ContainerManager manages a collection of containers.\ntype ContainerManager struct {\n\tmu         sync.RWMutex\n\tcontainers map[string]*Container // Map from ID to Container\n}\n\n// NewContainerManager creates and returns a new ContainerManager.\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t}\n}\n\n// StartContainer creates and starts a new container.\n// It returns the ID of the newly started container.\nfunc (cm *ContainerManager) StartContainer(name string) string {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tid := uuid.NewString()\n\tcontainer := &Container{\n\t\tID:       id,\n\t\tName:     name,\n\t\tRunning:  true,\n\t\tExitCode: -1, // No exit code yet, as it's running\n\t}\n\tcm.containers[id] = container\n\tfmt.Printf(\"Started container: %s %s\\n\", container.ID[:8], container.Name) // Truncate ID for brevity\n\treturn id\n}\n\n// StopContainer stops a running container with the specified exit code.\n// It returns true if the container was found and stopped, false otherwise.\nfunc (cm *ContainerManager) StopContainer(id string, exitCode int) bool {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tif container, ok := cm.containers[id]; ok && container.Running {\n\t\tcontainer.Running = false\n\t\tcontainer.ExitCode = exitCode\n\t\tfmt.Printf(\"Stopped container: %s with exit code: %d\\n\", container.ID[:8], container.ExitCode) // Truncate ID for brevity\n\t\treturn true\n\t}\n\treturn false // Container not found or not running\n}\n\n// ListContainers lists all containers, optionally filtered by exit code.\n// If filterExitCode is nil, all containers are returned.\n// Otherwise, only containers that are not running and have the matching exit code are returned.\nfunc (cm *ContainerManager) ListContainers(filterExitCode *int) []*Container {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tvar result []*Container\n\tfor _, container := range cm.containers {\n\t\tif filterExitCode == nil {\n\t\t\t// No filter, include all containers\n\t\t\tresult = append(result, container)\n\t\t} else {\n\t\t\t// Filter by exit code\n\t\t\tif !container.Running && container.ExitCode == *filterExitCode {\n\t\t\t\tresult = append(result, container)\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\t// As of Go 1.20, math/rand is automatically seeded with a non-deterministic value.\n\t// Calling rand.Seed(time.Now().UnixNano()) is no longer necessary and is deprecated.\n\t// For simulations like this, the default global rand source is sufficient.\n\n\tmanager := NewContainerManager()\n\tvar startWg sync.WaitGroup   // WaitGroup for starting containers\n\tvar stopWg sync.WaitGroup    // WaitGroup for stopping containers\n\tvar listingWg sync.WaitGroup // WaitGroup for listing goroutines\n\n\tconst numContainers = 10\n\t// Channel to pass container IDs from start operations to stop operations\n\tcontainerIDsChan := make(chan string, numContainers)\n\n\tfmt.Println(\"--- Starting Containers ---\")\n\t// Start 10 containers concurrently\n\tfor i := 0; i < numContainers; i++ {\n\t\tstartWg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer startWg.Done()\n\t\t\tname := fmt.Sprintf(\"container-%d\", i+1)\n\t\t\tid := manager.StartContainer(name)\n\t\t\tcontainerIDsChan <- id\n\t\t}(i)\n\t}\n\tstartWg.Wait() // Wait for all containers to be started\n\tclose(containerIDsChan) // Close the channel as no more IDs will be sent\n\n\t// Collect IDs into a slice to distribute for stopping\n\tidsToStop := make([]string, 0, numContainers)\n\tfor id := range containerIDsChan {\n\t\tidsToStop = append(idsToStop, id)\n\t}\n\n\tfmt.Println(\"\\n--- Stopping Containers & Concurrent Listing ---\")\n\t// Context to signal listing goroutines to stop gracefully\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // Ensure cancel is called if main exits early\n\n\t// Start listing goroutines\n\tnumListingGoroutines := 5\n\tfor i := 0; i < numListingGoroutines; i++ {\n\t\tlistingWg.Add(1)\n\t\tgo func(goroutineID int) {\n\t\t\tdefer listingWg.Done()\n\t\t\tfilter := goroutineID % 2 // Alternate filters: 0 or 1\n\t\t\tfilterPtr := &filter      // Pointer to the filter value\n\t\t\tticker := time.NewTicker(100 * time.Millisecond) // List every 100ms\n\t\t\tdefer ticker.Stop()\n\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t// Context was cancelled, time to stop this goroutine\n\t\t\t\t\treturn\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\t// It's time to list containers\n\t\t\t\t\tcontainers := manager.ListContainers(filterPtr)\n\t\t\t\t\t// Build a list of short IDs for printing\n\t\t\t\t\tvar containerIDsForPrint []string\n\t\t\t\t\tfor _, c := range containers {\n\t\t\t\t\t\tcontainerIDsForPrint = append(containerIDsForPrint, c.ID[:8])\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Printf(\"Listing containers with exit code %d (goroutine %d): %v\\n\", *filterPtr, goroutineID, containerIDsForPrint)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Stop 5 containers with exit code 0 and 5 with exit code 1 concurrently\n\tfor i, id := range idsToStop {\n\t\tstopWg.Add(1)\n\t\tgo func(id string, exitCode int) {\n\t\t\tdefer stopWg.Done()\n\t\t\t// Simulate some variable work before stopping\n\t\t\t// Using math/rand directly without seeding is fine as of Go 1.20+\n\t\t\ttime.Sleep(time.Duration(rand.Intn(200)+50) * time.Millisecond)\n\t\t\tmanager.StopContainer(id, exitCode)\n\t\t}(id, i%2) // Assign exit code 0 or 1 based on index\n\t}\n\n\tstopWg.Wait()    // Wait for all stop operations to complete\n\tcancel()         // Signal listing goroutines to stop\n\tlistingWg.Wait() // Wait for all listing goroutines to finish\n\n\tfmt.Println(\"\\n--- Final Checks ---\")\n\t// Final list of all containers to verify the overall state\n\tallContainers := manager.ListContainers(nil)\n\tfmt.Printf(\"Total containers managed: %d\\n\", len(allContainers))\n\n\trunningCount := 0\n\texit0Count := 0\n\texit1Count := 0\n\tfor _, c := range allContainers {\n\t\tif c.Running {\n\t\t\trunningCount++\n\t\t} else {\n\t\t\tif c.ExitCode == 0 {\n\t\t\t\texit0Count++\n\t\t\t} else if c.ExitCode == 1 {\n\t\t\t\texit1Count++\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"Running containers: %d\\n\", runningCount)\n\tfmt.Printf(\"Exited with code 0: %d\\n\", exit0Count)\n\tfmt.Printf(\"Exited with code 1: %d\\n\", exit1Count)\n\n\t// Final verification of filtered lists\n\tfiltered0 := manager.ListContainers(intPtr(0))\n\tfmt.Printf(\"Final list exit code 0: %d containers %v\\n\", len(filtered0), containerIDsToPrint(filtered0))\n\tfiltered1 := manager.ListContainers(intPtr(1))\n\tfmt.Printf(\"Final list exit code 1: %d containers %v\\n\", len(filtered1), containerIDsToPrint(filtered1))\n\n\tfmt.Println(\"\\nAll operations completed successfully!\")\n}\n\n// intPtr is a helper function to return a pointer to an integer literal.\nfunc intPtr(i int) *int {\n\treturn &i\n}\n\n// containerIDsToPrint is a helper function to extract and format short IDs from a slice of Containers.\nfunc containerIDsToPrint(containers []*Container) []string {\n\tvar ids []string\n\tfor _, c := range containers {\n\t\tids = append(ids, c.ID[:8]) // Truncate ID for brevity\n\t}\n\treturn ids\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_ak2d_aoo/main.go:165\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    164: \t\t\t// Using math/rand directly without seeding is fine as of Go 1.20+\n  > 165: \t\t\ttime.Sleep(time.Duration(rand.Intn(200)+50) * time.Millisecond)\n    166: \t\t\tmanager.StopContainer(id, exitCode)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 218\n  Nosec  : 0\n  Issues : \u001b[1;31m1\u001b[0m\n\n[gosec] 2025/12/01 12:17:54 Including rules: default\n[gosec] 2025/12/01 12:17:54 Excluding rules: default\n[gosec] 2025/12/01 12:17:54 Including analyzers: default\n[gosec] 2025/12/01 12:17:54 Excluding analyzers: default\n[gosec] 2025/12/01 12:17:54 Import directory: /tmp/go_synthesis_ak2d_aoo\n[gosec] 2025/12/01 12:17:55 Checking package: main\n[gosec] 2025/12/01 12:17:55 Checking file: /tmp/go_synthesis_ak2d_aoo/main.go"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// Container represents a single container instance.\ntype Container struct {\n\tID       string\n\tName     string\n\tRunning  bool\n\tExitCode int // Only relevant when Running is false. Default -1 when running.\n}\n\n// ContainerManager manages a collection of containers.\ntype ContainerManager struct {\n\tmu         sync.RWMutex\n\tcontainers map[string]*Container // Map from ID to Container\n}\n\n// NewContainerManager creates and returns a new ContainerManager.\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t}\n}\n\n// StartContainer creates and starts a new container.\n// It returns the ID of the newly started container.\nfunc (cm *ContainerManager) StartContainer(name string) string {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tid := uuid.NewString()\n\tcontainer := &Container{\n\t\tID:       id,\n\t\tName:     name,\n\t\tRunning:  true,\n\t\tExitCode: -1, // No exit code yet, as it's running\n\t}\n\tcm.containers[id] = container\n\tfmt.Printf(\"Started container: %s %s\\n\", container.ID[:8], container.Name) // Truncate ID for brevity\n\treturn id\n}\n\n// StopContainer stops a running container with the specified exit code.\n// It returns true if the container was found and stopped, false otherwise.\nfunc (cm *ContainerManager) StopContainer(id string, exitCode int) bool {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tif container, ok := cm.containers[id]; ok && container.Running {\n\t\tcontainer.Running = false\n\t\tcontainer.ExitCode = exitCode\n\t\tfmt.Printf(\"Stopped container: %s with exit code: %d\\n\", container.ID[:8], container.ExitCode) // Truncate ID for brevity\n\t\treturn true\n\t}\n\treturn false // Container not found or not running\n}\n\n// ListContainers lists all containers, optionally filtered by exit code.\n// If filterExitCode is nil, all containers are returned.\n// Otherwise, only containers that are not running and have the matching exit code are returned.\nfunc (cm *ContainerManager) ListContainers(filterExitCode *int) []*Container {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tvar result []*Container\n\tfor _, container := range cm.containers {\n\t\tif filterExitCode == nil {\n\t\t\t// No filter, include all containers\n\t\t\tresult = append(result, container)\n\t\t} else {\n\t\t\t// Filter by exit code\n\t\t\tif !container.Running && container.ExitCode == *filterExitCode {\n\t\t\t\tresult = append(result, container)\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\t// As of Go 1.20, math/rand is automatically seeded with a non-deterministic value.\n\t// Calling rand.Seed(time.Now().UnixNano()) is no longer necessary and is deprecated.\n\t// For simulations like this, the default global rand source is sufficient.\n\n\tmanager := NewContainerManager()\n\tvar startWg sync.WaitGroup   // WaitGroup for starting containers\n\tvar stopWg sync.WaitGroup    // WaitGroup for stopping containers\n\tvar listingWg sync.WaitGroup // WaitGroup for listing goroutines\n\n\tconst numContainers = 10\n\t// Channel to pass container IDs from start operations to stop operations\n\tcontainerIDsChan := make(chan string, numContainers)\n\n\tfmt.Println(\"--- Starting Containers ---\")\n\t// Start 10 containers concurrently\n\tfor i := 0; i < numContainers; i++ {\n\t\tstartWg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer startWg.Done()\n\t\t\tname := fmt.Sprintf(\"container-%d\", i+1)\n\t\t\tid := manager.StartContainer(name)\n\t\t\tcontainerIDsChan <- id\n\t\t}(i)\n\t}\n\tstartWg.Wait() // Wait for all containers to be started\n\tclose(containerIDsChan) // Close the channel as no more IDs will be sent\n\n\t// Collect IDs into a slice to distribute for stopping\n\tidsToStop := make([]string, 0, numContainers)\n\tfor id := range containerIDsChan {\n\t\tidsToStop = append(idsToStop, id)\n\t}\n\n\tfmt.Println(\"\\n--- Stopping Containers & Concurrent Listing ---\")\n\t// Context to signal listing goroutines to stop gracefully\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel() // Ensure cancel is called if main exits early\n\n\t// Start listing goroutines\n\tnumListingGoroutines := 5\n\tfor i := 0; i < numListingGoroutines; i++ {\n\t\tlistingWg.Add(1)\n\t\tgo func(goroutineID int) {\n\t\t\tdefer listingWg.Done()\n\t\t\tfilter := goroutineID % 2 // Alternate filters: 0 or 1\n\t\t\tfilterPtr := &filter      // Pointer to the filter value\n\t\t\tticker := time.NewTicker(100 * time.Millisecond) // List every 100ms\n\t\t\tdefer ticker.Stop()\n\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t// Context was cancelled, time to stop this goroutine\n\t\t\t\t\treturn\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\t// It's time to list containers\n\t\t\t\t\tcontainers := manager.ListContainers(filterPtr)\n\t\t\t\t\t// Build a list of short IDs for printing\n\t\t\t\t\tvar containerIDsForPrint []string\n\t\t\t\t\tfor _, c := range containers {\n\t\t\t\t\t\tcontainerIDsForPrint = append(containerIDsForPrint, c.ID[:8])\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Printf(\"Listing containers with exit code %d (goroutine %d): %v\\n\", *filterPtr, goroutineID, containerIDsForPrint)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Stop 5 containers with exit code 0 and 5 with exit code 1 concurrently\n\tfor i, id := range idsToStop {\n\t\tstopWg.Add(1)\n\t\tgo func(id string, exitCode int) {\n\t\t\tdefer stopWg.Done()\n\t\t\t// Simulate some variable work before stopping\n\t\t\t// Using math/rand directly without seeding is fine as of Go 1.20+\n\t\t\t// #nosec G404 -- This use of math/rand is for simulation delay, not security-sensitive data.\n\t\t\ttime.Sleep(time.Duration(rand.Intn(200)+50) * time.Millisecond)\n\t\t\tmanager.StopContainer(id, exitCode)\n\t\t}(id, i%2) // Assign exit code 0 or 1 based on index\n\t}\n\n\tstopWg.Wait()    // Wait for all stop operations to complete\n\tcancel()         // Signal listing goroutines to stop\n\tlistingWg.Wait() // Wait for all listing goroutines to finish\n\n\tfmt.Println(\"\\n--- Final Checks ---\")\n\t// Final list of all containers to verify the overall state\n\tallContainers := manager.ListContainers(nil)\n\tfmt.Printf(\"Total containers managed: %d\\n\", len(allContainers))\n\n\trunningCount := 0\n\texit0Count := 0\n\texit1Count := 0\n\tfor _, c := range allContainers {\n\t\tif c.Running {\n\t\t\trunningCount++\n\t\t} else {\n\t\t\tif c.ExitCode == 0 {\n\t\t\t\texit0Count++\n\t\t\t} else if c.ExitCode == 1 {\n\t\t\t\texit1Count++\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"Running containers: %d\\n\", runningCount)\n\tfmt.Printf(\"Exited with code 0: %d\\n\", exit0Count)\n\tfmt.Printf(\"Exited with code 1: %d\\n\", exit1Count)\n\n\t// Final verification of filtered lists\n\tfiltered0 := manager.ListContainers(intPtr(0))\n\tfmt.Printf(\"Final list exit code 0: %d containers %v\\n\", len(filtered0), containerIDsToPrint(filtered0))\n\tfiltered1 := manager.ListContainers(intPtr(1))\n\tfmt.Printf(\"Final list exit code 1: %d containers %v\\n\", len(filtered1), containerIDsToPrint(filtered1))\n\n\tfmt.Println(\"\\nAll operations completed successfully!\")\n}\n\n// intPtr is a helper function to return a pointer to an integer literal.\nfunc intPtr(i int) *int {\n\treturn &i\n}\n\n// containerIDsToPrint is a helper function to extract and format short IDs from a slice of Containers.\nfunc containerIDsToPrint(containers []*Container) []string {\n\tvar ids []string\n\tfor _, c := range containers {\n\t\tids = append(ids, c.ID[:8]) // Truncate ID for brevity\n\t}\n\treturn ids\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}