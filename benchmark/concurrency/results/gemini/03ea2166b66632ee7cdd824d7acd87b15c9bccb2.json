{
    "task": "03ea2166b66632ee7cdd824d7acd87b15c9bccb2.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// Container represents a single container managed by the system.\ntype Container struct {\n\tID        string\n\tName      string\n\tRunning   bool\n\tExitCode  int // Only relevant when Running is false. -1 when running.\n}\n\n// ContainerManager manages the lifecycle and state of multiple containers.\ntype ContainerManager struct {\n\tmu         sync.RWMutex\n\tcontainers map[string]*Container\n}\n\n// NewContainerManager initializes and returns a new ContainerManager.\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t}\n}\n\n// StartContainer creates and starts a new container with the given name.\n// It returns the unique ID of the newly started container.\nfunc (cm *ContainerManager) StartContainer(name string) string {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tid := uuid.NewString()\n\tcontainer := &Container{\n\t\tID:        id,\n\t\tName:      name,\n\t\tRunning:   true,\n\t\tExitCode:  -1, // Sentinel value: -1 indicates the container is running\n\t}\n\tcm.containers[id] = container\n\tfmt.Printf(\"Started container: %s %s\\n\", id, name)\n\treturn id\n}\n\n// StopContainer stops a running container identified by its ID and sets its exit code.\n// If the container is not found or already stopped, it prints a warning/error.\nfunc (cm *ContainerManager) StopContainer(id string, exitCode int) {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tcontainer, exists := cm.containers[id]\n\tif !exists {\n\t\tfmt.Printf(\"Error: Container %s not found for stopping.\\n\", id)\n\t\treturn\n\t}\n\tif !container.Running {\n\t\tfmt.Printf(\"Warning: Container %s is already stopped with exit code %d.\\n\", id, container.ExitCode)\n\t\treturn\n\t}\n\n\tcontainer.Running = false\n\tcontainer.ExitCode = exitCode\n\tfmt.Printf(\"Stopped container: %s with exit code: %d\\n\", id, exitCode)\n}\n\n// ListContainers lists all containers. If filterExitCode is provided (not nil),\n// it only returns containers that have exited with that specific exit code.\nfunc (cm *ContainerManager) ListContainers(filterExitCode *int) []*Container {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tvar result []*Container\n\tfor _, container := range cm.containers {\n\t\tif filterExitCode == nil {\n\t\t\t// No filter, include all containers\n\t\t\tresult = append(result, container)\n\t\t} else {\n\t\t\t// Filter by exit code: include only non-running containers with matching exit code\n\t\t\tif !container.Running && container.ExitCode == *filterExitCode {\n\t\t\t\tresult = append(result, container)\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n// containerIDsToStrings is a helper function to extract only the IDs from a slice of Containers\n// for cleaner printing in the example output.\nfunc containerIDsToStrings(containers []*Container) []string {\n\tids := make([]string, len(containers))\n\tfor i, c := range containers {\n\t\tids[i] = c.ID\n\t}\n\treturn ids\n}\n\n// listingGoroutine continuously lists containers based on exit codes until canceled by context.\nfunc listingGoroutine(manager *ContainerManager, ctx context.Context, goroutineID int) {\n\tdefer fmt.Printf(\"Listing goroutine %d stopped.\\n\", goroutineID)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\t// Context canceled, time to stop this goroutine\n\t\t\treturn\n\t\tdefault:\n\t\t\t// Perform listing operations\n\t\t\tfilter0 := 0\n\t\t\tfilter1 := 1\n\n\t\t\tcontainers0 := manager.ListContainers(&filter0)\n\t\t\tcontainers1 := manager.ListContainers(&filter1)\n\n\t\t\tfmt.Printf(\"Listing containers with exit code 0 (goroutine %d): %v\\n\", goroutineID, containerIDsToStrings(containers0))\n\t\t\tfmt.Printf(\"Listing containers with exit code 1 (goroutine %d): %v\\n\", goroutineID, containerIDsToStrings(containers1))\n\n\t\t\t// Add a small delay to prevent excessive CPU usage and make output more readable\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tmanager := NewContainerManager()\n\tconst numContainers = 10\n\tconst numListingGoroutines = 5\n\n\tvar wgStart sync.WaitGroup\n\tvar wgStop sync.WaitGroup\n\tvar wgListing sync.WaitGroup\n\n\t// Channel to pass container IDs from start operations to stop operations\n\tcontainerIDsToStop := make(chan string, numContainers)\n\n\tfmt.Println(\"--- Starting Containers Concurrently ---\")\n\tfor i := 0; i < numContainers; i++ {\n\t\twgStart.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wgStart.Done()\n\t\t\tid := manager.StartContainer(fmt.Sprintf(\"container-%d\", i))\n\t\t\tcontainerIDsToStop <- id // Send ID to channel for later stopping\n\t\t}(i)\n\t}\n\twgStart.Wait()          // Wait for all containers to be started\n\tclose(containerIDsToStop) // Close the channel as no more IDs will be sent\n\n\t// Collect all started container IDs into a slice\n\tvar ids []string\n\tfor id := range containerIDsToStop {\n\t\tids = append(ids, id)\n\t}\n\n\t// Create a context for signaling listing goroutines to stop gracefully\n\tstopListingCtx, stopListingCancel := context.WithCancel(context.Background())\n\tdefer stopListingCancel() // Ensure context is canceled when main exits\n\n\tfmt.Println(\"\\n--- Starting Continuous Listing Goroutines ---\")\n\tfor i := 0; i < numListingGoroutines; i++ {\n\t\twgListing.Add(1)\n\t\tgo listingGoroutine(manager, stopListingCtx, i+1)\n\t}\n\n\tfmt.Println(\"\\n--- Stopping Containers Concurrently (while listing) ---\")\n\t// Stop the first half of containers with exit code 0, and the second half with exit code 1\n\tfor i, id := range ids {\n\t\twgStop.Add(1)\n\t\texitCode := 0\n\t\tif i >= numContainers/2 {\n\t\t\texitCode = 1\n\t\t}\n\t\tgo func(id string, code int) {\n\t\t\tdefer wgStop.Done()\n\t\t\tmanager.StopContainer(id, code)\n\t\t}(id, exitCode)\n\t}\n\twgStop.Wait() // Wait for all stop operations to complete\n\n\tfmt.Println(\"\\n--- Signaling Listing Goroutines to Stop ---\")\n\tstopListingCancel() // Signal listing goroutines to gracefully exit\n\twgListing.Wait()    // Wait for all listing goroutines to finish\n\n\tfmt.Println(\"\\n--- Final Listing Check ---\")\n\tfilter0 := 0\n\tfilter1 := 1\n\tfinalContainers0 := manager.ListContainers(&filter0)\n\tfinalContainers1 := manager.ListContainers(&filter1)\n\n\tfmt.Printf(\"Final containers with exit code 0 (%d found): %v\\n\", len(finalContainers0), containerIDsToStrings(finalContainers0))\n\tfmt.Printf(\"Final containers with exit code 1 (%d found): %v\\n\", len(finalContainers1), containerIDsToStrings(finalContainers1))\n\tfmt.Printf(\"Total containers in system: %d\\n\", len(manager.ListContainers(nil)))\n\n\tfmt.Println(\"\\nAll operations completed successfully!\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}