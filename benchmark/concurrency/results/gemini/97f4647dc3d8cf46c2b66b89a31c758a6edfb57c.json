{
    "task": "97f4647dc3d8cf46c2b66b89a31c758a6edfb57c.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\n// WatcherEventType defines the type of event being delivered.\ntype WatcherEventType int\n\nconst (\n\tEventTypeData WatcherEventType = iota // Normal data event\n\tEventTypeError                        // Error event\n)\n\n// WatcherEvent represents an event delivered by the watcher.\ntype WatcherEvent struct {\n\tType    WatcherEventType\n\tPayload string // For EventTypeData\n\tErr     error  // For EventTypeError\n}\n\n// Watcher monitors for events and delivers them to consumers.\ntype Watcher struct {\n\tctx        context.Context\n\tcancel     context.CancelFunc\n\tresultChan chan WatcherEvent // Public channel for consumers\n\n\t// Internal channels for event sources (simulated)\n\t// In a real system, these would be populated by external event listeners or other goroutines.\n\teventSourceChan chan string\n\terrorSourceChan chan error\n\n\twg sync.WaitGroup // To track the background goroutines\n}\n\n// NewWatcher creates and initializes a new Watcher.\n// The resultChanSize determines the buffer size of the public result channel.\n// A size of 0 means an unbuffered channel, which will block sends if no receiver is ready.\nfunc NewWatcher(parentCtx context.Context, resultChanSize int) *Watcher {\n\tctx, cancel := context.WithCancel(parentCtx)\n\treturn &Watcher{\n\t\tctx:        ctx,\n\t\tcancel:     cancel,\n\t\tresultChan: make(chan WatcherEvent, resultChanSize),\n\t\t// Internal source channels are unbuffered to simulate immediate delivery\n\t\t// or blocking if the watcher's run loop isn't ready to consume.\n\t\teventSourceChan: make(chan string),\n\t\terrorSourceChan: make(chan error),\n\t}\n}\n\n// Start begins watching for events in a background goroutine.\nfunc (w *Watcher) Start() {\n\t// Add 1 for the main `run` goroutine\n\tw.wg.Add(1)\n\tgo w.run()\n\tlog.Println(\"Watcher: Started main `run` goroutine.\")\n\n\t// Add 1 for the `simulateSource` goroutine\n\tw.wg.Add(1)\n\tgo w.simulateSource()\n\tlog.Println(\"Watcher: Started `simulateSource` goroutine.\")\n}\n\n// run is the main event processing loop for the watcher.\n// It listens for events from internal sources and context cancellation.\nfunc (w *Watcher) run() {\n\tdefer w.wg.Done()\n\t// Close the public result channel when the watcher's main loop exits.\n\t// This signals to consumers that no more events will be sent.\n\tdefer close(w.resultChan)\n\n\tlog.Println(\"Watcher `run` goroutine started.\")\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase <-w.ctx.Done():\n\t\t\tlog.Println(\"Watcher `run`: Context cancelled. Shutting down.\")\n\t\t\tbreak loop // Exit the main loop\n\t\tcase eventData := <-w.eventSourceChan:\n\t\t\tlog.Printf(\"Watcher `run`: Received data event from source: %s\", eventData)\n\t\t\t// Attempt to send the data event to the result channel.\n\t\t\t// Use an inner select to ensure that if the result channel is blocking\n\t\t\t// and full, cancellation can still be handled promptly.\n\t\t\tselect {\n\t\t\tcase w.resultChan <- WatcherEvent{Type: EventTypeData, Payload: eventData}:\n\t\t\t\tlog.Printf(\"Watcher `run`: Successfully sent data event: %s\", eventData)\n\t\t\tcase <-w.ctx.Done():\n\t\t\t\tlog.Println(\"Watcher `run`: Context cancelled while trying to send data event. Exiting.\")\n\t\t\t\tbreak loop // Exit if context cancelled while trying to send\n\t\t\t}\n\t\tcase err := <-w.errorSourceChan:\n\t\t\tlog.Printf(\"Watcher `run`: Received error from source: %v\", err)\n\t\t\t// Attempt to send the error event to the result channel, with cancellation handling.\n\t\t\tselect {\n\t\t\tcase w.resultChan <- WatcherEvent{Type: EventTypeError, Err: err}:\n\t\t\t\tlog.Printf(\"Watcher `run`: Successfully sent error event: %v\", err)\n\t\t\tcase <-w.ctx.Done():\n\t\t\t\tlog.Println(\"Watcher `run`: Context cancelled while trying to send error event. Exiting.\")\n\t\t\t\tbreak loop // Exit if context cancelled while trying to send\n\t\t\t}\n\t\t}\n\t}\n\tlog.Println(\"Watcher `run` goroutine finished.\")\n}\n\n// simulateSource is a goroutine that simulates an external event source.\n// It generates periodic data events and occasional error events.\n// It respects the watcher's context for termination.\nfunc (w *Watcher) simulateSource() {\n\tdefer w.wg.Done()\n\t// Close internal source channels when simulation stops.\n\t// This signals to the `run` goroutine that no more events will arrive from this source.\n\tdefer close(w.eventSourceChan)\n\tdefer close(w.errorSourceChan)\n\n\tlog.Println(\"Watcher `simulateSource` goroutine started.\")\n\n\tticker := time.NewTicker(500 * time.Millisecond) // Simulate events every 500ms\n\tdefer ticker.Stop()\n\n\teventCounter := 0\n\tfor {\n\t\tselect {\n\t\tcase <-w.ctx.Done():\n\t\t\tlog.Println(\"Watcher `simulateSource`: Context cancelled. Shutting down.\")\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\teventCounter++\n\t\t\tif eventCounter%5 == 0 { // Simulate an error every 5 data events\n\t\t\t\tlog.Printf(\"Watcher `simulateSource`: Simulating an error: Error #%d\", eventCounter/5)\n\t\t\t\tselect {\n\t\t\t\tcase w.errorSourceChan <- fmt.Errorf(\"simulated error #%d\", eventCounter/5):\n\t\t\t\t\t// Sent successfully\n\t\t\t\tcase <-w.ctx.Done():\n\t\t\t\t\tlog.Println(\"Watcher `simulateSource`: Context cancelled while trying to send error. Exiting.\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlog.Printf(\"Watcher `simulateSource`: Simulating data event: Event-%d\", eventCounter)\n\t\t\t\tselect {\n\t\t\t\tcase w.eventSourceChan <- fmt.Sprintf(\"Event Data %d\", eventCounter):\n\t\t\t\t\t// Sent successfully\n\t\t\t\tcase <-w.ctx.Done():\n\t\t\t\t\tlog.Println(\"Watcher `simulateSource`: Context cancelled while trying to send data. Exiting.\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ResultChan returns a read-only channel for receiving WatcherEvents.\nfunc (w *Watcher) ResultChan() <-chan WatcherEvent {\n\treturn w.resultChan\n}\n\n// Stop cancels the watcher's context, signaling its background goroutines to terminate.\nfunc (w *Watcher) Stop() {\n\tlog.Println(\"Watcher: Received stop signal. Cancelling context.\")\n\tw.cancel() // This signals the context to be done.\n}\n\n// Wait waits for all of the watcher's background goroutines to finish.\n// This is primarily used in tests or for graceful shutdown to prevent goroutine leaks.\nfunc (w *Watcher) Wait() {\n\tlog.Println(\"Watcher: Waiting for all background goroutines to finish...\")\n\tw.wg.Wait()\n\tlog.Println(\"Watcher: All background goroutines finished.\")\n}\n\n// SimulateError allows injecting an error into the watcher's internal error channel for testing purposes.\n// It attempts to send the error without blocking the caller, respecting the watcher's context.\nfunc (w *Watcher) SimulateError(err error) {\n\tselect {\n\tcase w.errorSourceChan <- err:\n\t\tlog.Printf(\"Test: Successfully injected error: %v\", err)\n\tcase <-w.ctx.Done():\n\t\tlog.Println(\"Test: Cannot inject error, watcher context already done.\")\n\tdefault:\n\t\t// This 'default' case means the send would block because the channel is full\n\t\t// and nothing is reading. For an unbuffered channel, this means the receiver\n\t\t// isn't ready. This scenario is handled in the test setup.\n\t\tlog.Printf(\"Test: Failed to inject error '%v', errorSourceChan is blocked or full.\", err)\n\t}\n}\n\nfunc main() {\n\tlog.SetFlags(log.Ltime | log.Lshortfile)\n\tlog.Println(\"--- Starting Watcher Test Scenario: Cancellation with blocked result channel ---\")\n\n\t// 1. Create a watcher with a cancellable context\n\tparentCtx, parentCancel := context.WithCancel(context.Background())\n\tdefer parentCancel() // Ensure parent context is cancelled when main exits\n\n\t// Use an unbuffered channel (size 0) for the test scenario's result channel.\n\t// This ensures that attempting to send an event will immediately block if no consumer is reading,\n\t// allowing us to test cancellation under blocking conditions.\n\twatcher := NewWatcher(parentCtx, 0)\n\n\t// 2. Start the watcher\n\twatcher.Start()\n\n\t// 3. Simulate an error being sent to the internal error channel.\n\t// Since the result channel is unbuffered and nothing is reading from it yet,\n\t// the `watcher.run` goroutine will block when it tries to send this error\n\t// to `watcher.resultChan`.\n\ttestErr := errors.New(\"critical_test_error: this should trigger cancellation\")\n\twatcher.SimulateError(testErr)\n\n\t// Give a very brief moment for the injected error to be picked up by `watcher.run`\n\t// and for the send to `watcher.resultChan` to block.\n\ttime.Sleep(100 * time.Millisecond)\n\tlog.Println(\"Main: Watcher should now be blocked attempting to send the injected error to its result channel.\")\n\n\t// 4. Immediately call Stop() to cancel the context WITHOUT reading from the result channel.\n\tlog.Println(\"Main: Calling watcher.Stop() to cancel context.\")\n\twatcher.Stop()\n\n\t// 5. Verify that the watcher's background goroutines terminate within a reasonable timeout.\n\t// This confirms that the cancellation mechanism correctly unblocks the `run` goroutine\n\t// even when its result channel is full, preventing goroutine leaks.\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twatcher.Wait() // Wait for both `run` and `simulateSource` goroutines to finish\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\tlog.Println(\"Main: SUCCESS! Watcher goroutines terminated successfully as expected within timeout.\")\n\tcase <-time.After(2 * time.Second):\n\t\tlog.Fatal(\"Main: FAILURE! Watcher goroutines did NOT terminate within 2 seconds. Potential goroutine leak detected!\")\n\t}\n\n\tlog.Println(\"\\n--- Test Scenario Finished ---\")\n\n\t// --- Optional: Demonstrating normal watcher operation with a buffered channel and consumer ---\n\tlog.Println(\"\\n--- Demonstrating normal watcher operation with a consumer ---\")\n\tnormalWatcher := NewWatcher(parentCtx, 5) // Use a buffered result channel\n\tnormalWatcher.Start()\n\n\t// Consumer goroutine to read events\n\tgo func() {\n\t\tdefer log.Println(\"Consumer: Goroutine finished.\")\n\t\tlog.Println(\"Consumer: Started reading events.\")\n\t\tfor i := 0; i < 7; i++ { // Read a few events\n\t\t\tselect {\n\t\t\tcase event, ok := <-normalWatcher.ResultChan():\n\t\t\t\tif !ok {\n\t\t\t\t\tlog.Println(\"Consumer: Result channel closed by watcher.\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif event.Type == EventTypeData {\n\t\t\t\t\tlog.Printf(\"Consumer: Received DATA: '%s'\", event.Payload)\n\t\t\t\t} else {\n\t\t\t\t\tlog.Printf(\"Consumer: Received ERROR: '%v'\", event.Err)\n\t\t\t\t}\n\t\t\tcase <-time.After(3 * time.Second): // Timeout if no event for 3 seconds\n\t\t\t\tlog.Println(\"Consumer: Timeout waiting for event. Stopping watcher.\")\n\t\t\t\tnormalWatcher.Stop()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tlog.Println(\"Consumer: Read desired number of events. Signalling watcher to stop.\")\n\t\tnormalWatcher.Stop() // Stop the watcher after reading some events\n\t}()\n\n\tnormalWatcher.Wait() // Wait for the normal watcher to shut down gracefully\n\tlog.Println(\"Normal operation demonstration finished.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}