{
    "task": "task2.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"sync/atomic\"\n    \"time\"\n\n    \"golang.org/x/sync/singleflight\"\n)\n\n// --- Custom Errors ---\nvar (\n    ErrTableDeleted     = errors.New(\"table is marked as deleted\")\n    ErrLeaseNotFound    = errors.New(\"lease not found\")\n    ErrNegativeRefCount = errors.New(\"attempted to release a lease with non-positive refcount\")\n)\n\n// LeaseState represents a specific version of a table's metadata lease.\ntype LeaseState struct {\n    LeaseID   string // Unique identifier for this specific lease version\n    DbID      string\n    TableID   string // Canonical ID for the table (e.g., UUID from metadata store)\n    TableName string\n    Version   int64\n    RefCount  int64 // Atomic reference count\n}\n\n// LeaseStore simulates a backend store for leases.\ntype LeaseStore interface {\n    FetchLatestLease(dbID, tableName string) (*LeaseState, error)\n    NotifyLeaseCleanup(leaseID string) error // Notifies backend that a lease version can be cleaned up\n    NotifyTableDeleted(tableID string) error // Notifies backend that a table is marked deleted\n}\n\n// MockLeaseStore is a concrete implementation for testing.\ntype MockLeaseStore struct {\n    sync.Mutex\n    leases       map[string]*LeaseState // key: LeaseID\n    tableLatest  map[string]string      // key: dbID/tableName, value: LeaseID of latest\n    tableDeleted map[string]bool        // key: TableID\n    cleanupCount int\n    deleteCount  int\n}\n\nfunc NewMockLeaseStore() *MockLeaseStore {\n    return &MockLeaseStore{\n        leases:       make(map[string]*LeaseState),\n        tableLatest:  make(map[string]string),\n        tableDeleted: make(map[string]bool),\n    }\n}\n\nfunc (m *MockLeaseStore) FetchLatestLease(dbID, tableName string) (*LeaseState, error) {\n    m.Lock()\n    defer m.Unlock()\n\n    tableID := makeTableID(dbID, tableName)\n    if m.tableDeleted[tableID] {\n        return nil, ErrTableDeleted\n    }\n\n    key := makeCacheKey(dbID, tableName)\n    latestLeaseID, found := m.tableLatest[key]\n\n    if !found {\n        // Simulate creating a new lease if none exists\n        newVersion := int64(1)\n        leaseID := fmt.Sprintf(\"%s-%d-%d\", tableID, newVersion, time.Now().UnixNano())\n        lease := &LeaseState{\n            LeaseID:   leaseID,\n            DbID:      dbID,\n            TableID:   tableID,\n            TableName: tableName,\n            Version:   newVersion,\n            RefCount:  0, // RefCount starts at 0, Acquire increments it\n        }\n        m.leases[leaseID] = lease\n        m.tableLatest[key] = leaseID\n        return lease, nil\n    }\n\n    // Simulate fetching the existing latest lease\n    lease, found := m.leases[latestLeaseID]\n    if !found {\n        return nil, fmt.Errorf(\"lease store internal error: latest lease ID %s not found\", latestLeaseID)\n    }\n    return lease, nil\n}\n\n// BumpVersion simulates a new version being available in the backend for a table.\nfunc (m *MockLeaseStore) BumpVersion(dbID, tableName string) *LeaseState {\n    m.Lock()\n    defer m.Unlock()\n\n    tableID := makeTableID(dbID, tableName)\n    key := makeCacheKey(dbID, tableName)\n    \n    currentLeaseID, found := m.tableLatest[key]\n    var currentVersion int64 = 0\n    if found {\n        if l, ok := m.leases[currentLeaseID]; ok {\n            currentVersion = l.Version\n        }\n    }\n\n    newVersion := currentVersion + 1\n    newLeaseID := fmt.Sprintf(\"%s-%d-%d\", tableID, newVersion, time.Now().UnixNano())\n    newLease := &LeaseState{\n        LeaseID:   newLeaseID,\n        DbID:      dbID,\n        TableID:   tableID,\n        TableName: tableName,\n        Version:   newVersion,\n        RefCount:  0,\n    }\n    m.leases[newLeaseID] = newLease\n    m.tableLatest[key] = newLeaseID\n    log.Printf(\"MockLeaseStore: Bumped version for %s/%s to %d, new LeaseID: %s\", dbID, tableName, newVersion, newLeaseID)\n    return newLease\n}\n\nfunc (m *MockLeaseStore) NotifyLeaseCleanup(leaseID string) error {\n    m.Lock()\n    defer m.Unlock()\n    log.Printf(\"MockLeaseStore: Notifying cleanup for LeaseID: %s\", leaseID)\n    delete(m.leases, leaseID) // Remove from mock store's memory\n    m.cleanupCount++\n    return nil\n}\n\nfunc (m *MockLeaseStore) NotifyTableDeleted(tableID string) error {\n    m.Lock()\n    defer m.Unlock()\n    log.Printf(\"MockLeaseStore: Notifying table deletion for TableID: %s\", tableID)\n    m.tableDeleted[tableID] = true\n    m.deleteCount++\n    return nil\n}\n\n// TableState manages all lease versions for a given table ID.\ntype TableState struct {\n    sync.Mutex // Protects internal fields of this TableState\n    DbID               string\n    TableID            string\n    TableName          string\n    Leases             map[int64]*LeaseState // Version -> LeaseState\n    LatestVersion      int64\n    TableMarkedDeleted bool\n    CleaningUpLeases   map[string]struct{} // Set of LeaseIDs that have been marked for cleanup\n    // associatedCacheKeys maps dbID/tableName to indicate which tableNameCache keys point to this table's leases.\n    // Used for invalidation during table deletion.\n    associatedCacheKeys map[string]struct{}\n}\n\n// LeaseManager is the main entry point for the lease management system.\ntype LeaseManager struct {\n    sync.RWMutex // Protects tableStates and tableNameCache maps themselves (adding/removing map entries)\n    leaseStore     LeaseStore\n    tableStates    map[string]*TableState // TableID -> TableState\n    tableNameCache map[string]*LeaseState // dbID/tableName -> Latest active LeaseState\n    fetchGroup     singleflight.Group     // Prevents thundering herd on LeaseStore for same cacheKey\n}\n\n// NewLeaseManager creates a new LeaseManager instance.\nfunc NewLeaseManager(store LeaseStore) *LeaseManager {\n    return &LeaseManager{\n        leaseStore:     store,\n        tableStates:    make(map[string]*TableState),\n        tableNameCache: make(map[string]*LeaseState),\n    }\n}\n\n// makeCacheKey creates a key for tableNameCache, typically \"dbID/tableName\".\nfunc makeCacheKey(dbID, tableName string) string {\n    return dbID + \"/\" + tableName\n}\n\n// makeTableID creates the canonical TableID.\n// In a real system, this might be a UUID from a metadata store lookup.\n// For this mock, we derive it from DbID and TableName.\nfunc makeTableID(dbID, tableName string) string {\n    return fmt.Sprintf(\"%s:%s\", dbID, tableName)\n}\n\n// getTableState attempts to retrieve a TableState by its TableID.\n// It acquires the LeaseManager's RLock and, if found, the TableState's Lock.\nfunc (lm *LeaseManager) getTableState(tableID string) (*TableState, bool) {\n    lm.RWMutex.RLock()\n    ts, found := lm.tableStates[tableID]\n    lm.RWMutex.RUnlock()\n    if !found {\n        return nil, false\n    }\n    ts.Lock() // Lock the specific TableState's internal mutex\n    return ts, true\n}\n\n// getOrCreateTableState retrieves or creates a TableState.\n// It acquires the LeaseManager's Write Lock to potentially modify the tableStates map.\n// It returns the TableState with its internal mutex already locked.\nfunc (lm *LeaseManager) getOrCreateTableState(dbID, tableID, tableName string) *TableState {\n    lm.RWMutex.Lock() // Acquire write lock on manager to potentially modify tableStates map\n    ts, found := lm.tableStates[tableID]\n    if !found {\n        ts = &TableState{\n            DbID:                dbID,\n            TableID:             tableID,\n            TableName:           tableName,\n            Leases:              make(map[int64]*LeaseState),\n            CleaningUpLeases:    make(map[string]struct{}),\n            associatedCacheKeys: make(map[string]struct{}),\n        }\n        lm.tableStates[tableID] = ts\n    }\n    lm.RWMutex.Unlock() // Release manager write lock as soon as map modification is done\n\n    ts.Lock() // Lock the specific TableState's mutex\n    return ts\n}\n\n// AcquireByName acquires a lease for a given (dbID, tableName) pair.\n// It either returns a cached lease or fetches the latest from the LeaseStore.\nfunc (lm *LeaseManager) AcquireByName(dbID, tableName string) (*LeaseState, error) {\n    cacheKey := makeCacheKey(dbID, tableName)\n\n    // 1. Try to find in tableNameCache (read-only access to manager's cache map)\n    lm.RWMutex.RLock()\n    cachedLease, foundInCache := lm.tableNameCache[cacheKey]\n    lm.RWMutex.RUnlock()\n\n    if foundInCache {\n        // We have a cached lease, now check its validity with the TableState\n        ts, tsFound := lm.getTableState(cachedLease.TableID)\n        if tsFound {\n            defer ts.Unlock() // Ensure TableState mutex is released\n\n            if ts.TableMarkedDeleted {\n                log.Printf(\"AcquireByName: Cached lease %s for %s/%s is for a deleted table. Evicting and refetching.\",\n                    cachedLease.LeaseID, dbID, tableName)\n                // Invalidate this specific cache entry since it points to a deleted table\n                lm.RWMutex.Lock() // Acquire manager write lock to modify cache map\n                if currentCachedLease, stillPoints := lm.tableNameCache[cacheKey]; stillPoints && currentCachedLease == cachedLease {\n                    delete(lm.tableNameCache, cacheKey)\n                    delete(ts.associatedCacheKeys, cacheKey)\n                }\n                lm.RWMutex.Unlock()\n                goto fetchFromStore // Cache entry is stale due to deletion, fall through to fetch\n            }\n\n            if cachedLease.Version == ts.LatestVersion {\n                // Cache hit and valid, increment refcount and return\n                atomic.AddInt64(&cachedLease.RefCount, 1)\n                log.Printf(\"AcquireByName: Cache hit for %s/%s (LeaseID: %s, RefCount: %d)\",\n                    dbID, tableName, cachedLease.LeaseID, atomic.LoadInt64(&cachedLease.RefCount))\n                return cachedLease, nil\n            }\n            log.Printf(\"AcquireByName: Cached lease %s for %s/%s is outdated (version %d < latest %d). Evicting and refetching.\",\n                cachedLease.LeaseID, dbID, tableName, cachedLease.Version, ts.LatestVersion)\n            // Cache entry is stale due to new version, fall through to fetch (it will be overwritten)\n        } else {\n            // This case implies an inconsistency (cached lease refers to a TableID that doesn't have a TableState)\n            log.Printf(\"AcquireByName: Cached lease %s for %s/%s has no corresponding TableState. Evicting and refetching.\",\n                cachedLease.LeaseID, dbID, tableName)\n            lm.RWMutex.Lock() // Acquire manager write lock to modify cache map\n            if currentCachedLease, stillPoints := lm.tableNameCache[cacheKey]; stillPoints && currentCachedLease == cachedLease {\n                delete(lm.tableNameCache, cacheKey)\n            }\n            lm.RWMutex.Unlock()\n        }\n    }\n\nfetchFromStore:\n    // 2. Cache miss or stale entry, fetch from LeaseStore using singleflight to prevent duplicate fetches\n    v, err, _ := lm.fetchGroup.Do(cacheKey, func() (interface{}, error) {\n        fetchedLease, fetchErr := lm.leaseStore.FetchLatestLease(dbID, tableName)\n        if fetchErr != nil {\n            return nil, fetchErr\n        }\n        if fetchedLease == nil {\n            return nil, errors.New(\"LeaseStore returned nil lease with no error\")\n        }\n\n        // Get or create TableState for this lease's TableID. It will be locked upon return.\n        ts := lm.getOrCreateTableState(fetchedLease.DbID, fetchedLease.TableID, fetchedLease.TableName)\n        defer ts.Unlock() // Ensure TableState mutex is released\n\n        if ts.TableMarkedDeleted {\n            log.Printf(\"AcquireByName: Table %s/%s (%s) was marked deleted during fetch. Aborting acquisition.\",\n                dbID, tableName, fetchedLease.TableID)\n            return nil, ErrTableDeleted\n        }\n\n        // Add or update the lease in TableState's version list\n        ts.Leases[fetchedLease.Version] = fetchedLease\n        if fetchedLease.Version > ts.LatestVersion {\n            ts.LatestVersion = fetchedLease.Version\n        }\n\n        // Increment refcount for the newly acquired lease (atomically)\n        atomic.AddInt64(&fetchedLease.RefCount, 1)\n\n        // Update tableNameCache (requires manager write lock)\n        lm.RWMutex.Lock()\n        lm.tableNameCache[cacheKey] = fetchedLease\n        ts.associatedCacheKeys[cacheKey] = struct{}{} // Track this cache key for invalidation\n        lm.RWMutex.Unlock()\n\n        log.Printf(\"AcquireByName: Fetched new lease for %s/%s (LeaseID: %s, Version: %d, RefCount: %d)\",\n            dbID, tableName, fetchedLease.LeaseID, fetchedLease.Version, atomic.LoadInt64(&fetchedLease.RefCount))\n        return fetchedLease, nil\n    })\n\n    if err != nil {\n        return nil, err\n    }\n    return v.(*LeaseState), nil\n}\n\n// Release decrements the refcount of a lease. If refcount reaches zero,\n// it checks for cleanup conditions (obsolete version or deleted table) and triggers cleanup.\nfunc (lm *LeaseManager) Release(lease *LeaseState) error {\n    if lease == nil {\n        return nil\n    }\n\n    newCount := atomic.AddInt64(&lease.RefCount, -1)\n\n    if newCount > 0 {\n        log.Printf(\"Release: LeaseID %s refcount decremented to %d. Still in use.\", lease.LeaseID, newCount)\n        return nil // Lease still in use\n    }\n\n    if newCount < 0 {\n        // This indicates an over-release. Correct the refcount and return error.\n        atomic.AddInt64(&lease.RefCount, 1) // Increment back to 0\n        log.Printf(\"ERROR: Release: Negative refcount detected for LeaseID %s. Refcount reset to 0.\", lease.LeaseID)\n        return ErrNegativeRefCount\n    }\n\n    // Refcount is zero, proceed with cleanup checks\n    log.Printf(\"Release: LeaseID %s refcount reached zero. Checking for cleanup.\", lease.LeaseID)\n\n    ts, tsFound := lm.getTableState(lease.TableID)\n    if !tsFound {\n        log.Printf(\"ERROR: Release: TableState not found for LeaseID %s (TableID: %s). Cannot cleanup.\",\n            lease.LeaseID, lease.TableID)\n        return ErrLeaseNotFound\n    }\n    defer ts.Unlock() // Ensure TableState mutex is released\n\n    // Prevent duplicate cleanup calls if goroutine already started\n    if _, cleaningUp := ts.CleaningUpLeases[lease.LeaseID]; cleaningUp {\n        log.Printf(\"Release: LeaseID %s is already being cleaned up.\", lease.LeaseID)\n        return nil\n    }\n\n    // Determine if this lease should be cleaned up from internal structures and backend\n    shouldCleanupLease := false\n    if ts.TableMarkedDeleted {\n        log.Printf(\"Release: LeaseID %s marked for cleanup: Table %s is deleted.\", lease.LeaseID, lease.TableID)\n        shouldCleanupLease = true\n    } else if lease.Version < ts.LatestVersion {\n        log.Printf(\"Release: LeaseID %s marked for cleanup: Obsolete version (%d < latest %d) for Table %s.\",\n            lease.LeaseID, lease.Version, ts.LatestVersion, lease.TableID)\n        shouldCleanupLease = true\n    }\n\n    // Determine if this lease should be removed from tableNameCache\n    cacheKey := makeCacheKey(lease.DbID, lease.TableName)\n    shouldRemoveFromCache := false\n    lm.RWMutex.RLock() // Read lock to check current cache entry\n    currentCachedLease, cacheFound := lm.tableNameCache[cacheKey]\n    lm.RWMutex.RUnlock()\n\n    if cacheFound && currentCachedLease == lease {\n        if shouldCleanupLease {\n            shouldRemoveFromCache = true\n        } else {\n            // This lease is still the latest and table not deleted, but its refcount is zero.\n            // This state is fine. It can be re-acquired from cache or replaced by a newer version.\n            // Do not remove from cache yet.\n            log.Printf(\"Release: LeaseID %s is latest for Table %s, refcount 0. Keeping in cache for now.\", lease.LeaseID, lease.TableID)\n        }\n    }\n\n    if shouldCleanupLease {\n        // Remove from TableState's list of leases\n        delete(ts.Leases, lease.Version)\n        ts.CleaningUpLeases[lease.LeaseID] = struct{}{} // Mark as cleaning up to prevent future attempts\n\n        // Asynchronously notify LeaseStore for cleanup\n        go func(leaseID string) {\n            if err := lm.leaseStore.NotifyLeaseCleanup(leaseID); err != nil {\n                log.Printf(\"ERROR: LeaseStore.NotifyLeaseCleanup for %s failed: %v\", leaseID, err)\n            } else {\n                log.Printf(\"LeaseStore.NotifyLeaseCleanup for %s successful.\", leaseID)\n            }\n        }(lease.LeaseID)\n    }\n\n    if shouldRemoveFromCache {\n        // Need manager write lock to modify tableNameCache map\n        lm.RWMutex.Lock()\n        // Double-check under write lock, in case another acquire/release updated the cache\n        currentCachedLease, cacheFound = lm.tableNameCache[cacheKey]\n        if cacheFound && currentCachedLease == lease {\n            delete(lm.tableNameCache, cacheKey)\n            delete(ts.associatedCacheKeys, cacheKey) // Remove tracking from TableState\n            log.Printf(\"Release: Evicted LeaseID %s from tableNameCache (cacheKey: %s).\", lease.LeaseID, cacheKey)\n        }\n        lm.RWMutex.Unlock()\n    }\n\n    return nil\n}\n\n// MarkTableDeleted marks a table as deleted, initiating cleanup for eligible leases.\nfunc (lm *LeaseManager) MarkTableDeleted(dbID, tableName string) error {\n    tableID := makeTableID(dbID, tableName)\n\n    ts, tsFound := lm.getTableState(tableID)\n    if !tsFound {\n        log.Printf(\"MarkTableDeleted: TableState not found for TableID %s. It might not exist or already cleaned up.\", tableID)\n        return nil // Idempotent: if not found, it's effectively deleted from our perspective\n    }\n    defer ts.Unlock() // Ensure TableState mutex is released\n\n    if ts.TableMarkedDeleted {\n        log.Printf(\"MarkTableDeleted: Table %s already marked as deleted.\", tableID)\n        return nil // Idempotent\n    }\n\n    ts.TableMarkedDeleted = true\n    log.Printf(\"MarkTableDeleted: Table %s marked as deleted.\", tableID)\n\n    // Notify LeaseStore backend that the table is deleted\n    go func(tableID string) {\n        if err := lm.leaseStore.NotifyTableDeleted(tableID); err != nil {\n            log.Printf(\"ERROR: LeaseStore.NotifyTableDeleted for %s failed: %v\", tableID, err)\n        } else {\n            log.Printf(\"LeaseStore.NotifyTableDeleted for %s successful.\", tableID)\n        }\n    }(tableID)\n\n    // Invalidate associated cache entries\n    lm.RWMutex.Lock() // Need manager write lock to modify tableNameCache\n    for cacheKey := range ts.associatedCacheKeys {\n        if currentCachedLease, cacheFound := lm.tableNameCache[cacheKey]; cacheFound && currentCachedLease.TableID == tableID {\n            // Evict from cache if it points to a lease of this deleted table\n            delete(lm.tableNameCache, cacheKey)\n            log.Printf(\"MarkTableDeleted: Evicted cacheKey %s due to table deletion.\", cacheKey)\n        }\n    }\n    // Clear associatedCacheKeys for the table state as they are no longer valid for active cache entries\n    ts.associatedCacheKeys = make(map[string]struct{})\n    lm.RWMutex.Unlock()\n\n    // Now iterate through all leases for this table and clean up those with refcount 0\n    // Leases with positive refcount will be cleaned up upon their final Release.\n    for _, lease := range ts.Leases {\n        if atomic.LoadInt64(&lease.RefCount) == 0 {\n            if _, cleaningUp := ts.CleaningUpLeases[lease.LeaseID]; !cleaningUp {\n                log.Printf(\"MarkTableDeleted: Cleanup for LeaseID %s (refcount 0) due to table deletion.\", lease.LeaseID)\n                delete(ts.Leases, lease.Version)          // Remove from TableState's list\n                ts.CleaningUpLeases[lease.LeaseID] = struct{}{} // Mark as cleaning up\n                go func(leaseID string) {\n                    if err := lm.leaseStore.NotifyLeaseCleanup(leaseID); err != nil {\n                        log.Printf(\"ERROR: LeaseStore.NotifyLeaseCleanup for %s failed (from MarkTableDeleted): %v\", leaseID, err)\n                    } else {\n                        log.Printf(\"LeaseStore.NotifyLeaseCleanup for %s successful (from MarkTableDeleted).\", leaseID)\n                    }\n                }(lease.LeaseID)\n            }\n        }\n    }\n    return nil\n}\n\nfunc main() {\n    log.SetFlags(log.Ltime | log.Lshortfile)\n    fmt.Println(\"Starting Lease Management System Demo\")\n\n    mockStore := NewMockLeaseStore()\n    manager := NewLeaseManager(mockStore)\n\n    db1 := \"mydb1\"\n    tbl1 := \"mytable1\"\n    db2 := \"mydb2\"\n    tbl2 := \"mytable2\"\n    db3 := \"mydb3\"\n    tbl3 := \"mytable3\"\n\n    fmt.Println(\"\\n--- Scenario 1: Basic Acquire/Release ---\")\n    lease1a, err := manager.AcquireByName(db1, tbl1)\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 1a: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, RefCount: %d\\n\", lease1a.LeaseID, atomic.LoadInt64(&lease1a.RefCount))\n\n    lease1b, err := manager.AcquireByName(db1, tbl1) // Should return the same lease\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 1b: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, RefCount: %d\\n\", lease1b.LeaseID, atomic.LoadInt64(&lease1b.RefCount))\n    if lease1a.LeaseID != lease1b.LeaseID {\n        log.Fatal(\"Error: AcquireByName for same table returned different leases!\")\n    }\n\n    manager.Release(lease1a)\n    fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease1a.LeaseID, atomic.LoadInt64(&lease1a.RefCount))\n    manager.Release(lease1b) // Refcount should be 0, trigger cleanup check\n    fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease1b.LeaseID, atomic.LoadInt64(&lease1b.RefCount))\n\n    time.Sleep(100 * time.Millisecond) // Allow async cleanup to run\n    fmt.Printf(\"Cleanup notifications sent: %d\\n\", mockStore.cleanupCount)\n    // Lease for db1/tbl1 should be cleaned up as it was the only version and refcount hit 0.\n\n    fmt.Println(\"\\n--- Scenario 2: Version Bump and Obsolete Lease Cleanup ---\")\n    lease2a, err := manager.AcquireByName(db2, tbl2)\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 2a: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, Version: %d, RefCount: %d\\n\", lease2a.LeaseID, lease2a.Version, atomic.LoadInt64(&lease2a.RefCount))\n\n    // Simulate a backend version bump\n    mockStore.BumpVersion(db2, tbl2)\n\n    lease2b, err := manager.AcquireByName(db2, tbl2) // Should fetch new version\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 2b: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, Version: %d, RefCount: %d\\n\", lease2b.LeaseID, lease2b.Version, atomic.LoadInt64(&lease2b.RefCount))\n    if lease2a.LeaseID == lease2b.LeaseID {\n        log.Fatal(\"Error: AcquireByName after version bump returned same lease!\")\n    }\n\n    manager.Release(lease2a) // This lease is now obsolete and refcount hits 0\n    fmt.Printf(\"Released Lease: %s (obsolete), RefCount: %d\\n\", lease2a.LeaseID, atomic.LoadInt64(&lease2a.RefCount))\n\n    manager.Release(lease2b) // The new latest lease\n    fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease2b.LeaseID, atomic.LoadInt64(&lease2b.RefCount))\n\n    time.Sleep(100 * time.Millisecond) // Allow async cleanup to run\n    fmt.Printf(\"Cleanup notifications sent: %d (total)\\n\", mockStore.cleanupCount)\n\n    fmt.Println(\"\\n--- Scenario 3: Mark Table Deleted ---\")\n    lease3a, err := manager.AcquireByName(db3, tbl3)\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 3a: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, Version: %d, RefCount: %d\\n\", lease3a.LeaseID, lease3a.Version, atomic.LoadInt64(&lease3a.RefCount))\n\n    // Mark table db3/tbl3 as deleted\n    err = manager.MarkTableDeleted(db3, tbl3)\n    if err != nil {\n        log.Fatalf(\"Failed to mark table deleted: %v\", err)\n    }\n    fmt.Printf(\"Table %s/%s marked deleted.\\n\", db3, tbl3)\n\n    // Try to acquire lease for a deleted table\n    _, err = manager.AcquireByName(db3, tbl3)\n    if err == nil || err != ErrTableDeleted {\n        log.Fatalf(\"Expected ErrTableDeleted, got: %v\", err)\n    }\n    fmt.Printf(\"Attempt to acquire lease for deleted table %s/%s resulted in expected error: %v\\n\", db3, tbl3, err)\n\n    // Release the previously acquired lease for the now-deleted table\n    manager.Release(lease3a)\n    fmt.Printf(\"Released Lease: %s (deleted table), RefCount: %d\\n\", lease3a.LeaseID, atomic.LoadInt64(&lease3a.RefCount))\n\n    time.Sleep(100 * time.Millisecond) // Allow async cleanup to run\n    fmt.Printf(\"Cleanup notifications sent: %d (total)\\n\", mockStore.cleanupCount)\n    fmt.Printf(\"Table deletion notifications sent: %d\\n\", mockStore.deleteCount)\n\n    // Verify negative refcount prevention\n    fmt.Println(\"\\n--- Scenario 4: Negative Refcount Prevention ---\")\n    lease4a, err := manager.AcquireByName(\"db4\", \"tbl4\")\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 4a: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, RefCount: %d\\n\", lease4a.LeaseID, atomic.LoadInt64(&lease4a.RefCount))\n    manager.Release(lease4a)\n    fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease4a.LeaseID, atomic.LoadInt64(&lease4a.RefCount))\n    err = manager.Release(lease4a) // This should cause ErrNegativeRefCount\n    if err != ErrNegativeRefCount {\n        log.Fatalf(\"Expected ErrNegativeRefCount, got: %v\", err)\n    }\n    fmt.Printf(\"Attempt to over-release Lease: %s resulted in expected error: %v\\n\", lease4a.LeaseID, err)\n    fmt.Printf(\"Lease: %s RefCount after over-release attempt: %d\\n\", lease4a.LeaseID, atomic.LoadInt64(&lease4a.RefCount))\n\n\n    fmt.Println(\"\\nDemo Finished.\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[37;40m/tmp/go_synthesis_9vi4yjgq/main.go:585\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    584:     fmt.Printf(\"Acquired Lease: %s, RefCount: %d\\n\", lease4a.LeaseID, atomic.LoadInt64(&lease4a.RefCount))\n  > 585:     manager.Release(lease4a)\n    586:     fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease4a.LeaseID, atomic.LoadInt64(&lease4a.RefCount))\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_9vi4yjgq/main.go:571\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    570:     // Release the previously acquired lease for the now-deleted table\n  > 571:     manager.Release(lease3a)\n    572:     fmt.Printf(\"Released Lease: %s (deleted table), RefCount: %d\\n\", lease3a.LeaseID, atomic.LoadInt64(&lease3a.RefCount))\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_9vi4yjgq/main.go:543\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    542: \n  > 543:     manager.Release(lease2b) // The new latest lease\n    544:     fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease2b.LeaseID, atomic.LoadInt64(&lease2b.RefCount))\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_9vi4yjgq/main.go:540\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    539: \n  > 540:     manager.Release(lease2a) // This lease is now obsolete and refcount hits 0\n    541:     fmt.Printf(\"Released Lease: %s (obsolete), RefCount: %d\\n\", lease2a.LeaseID, atomic.LoadInt64(&lease2a.RefCount))\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_9vi4yjgq/main.go:514\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    513:     fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease1a.LeaseID, atomic.LoadInt64(&lease1a.RefCount))\n  > 514:     manager.Release(lease1b) // Refcount should be 0, trigger cleanup check\n    515:     fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease1b.LeaseID, atomic.LoadInt64(&lease1b.RefCount))\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_9vi4yjgq/main.go:512\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    511: \n  > 512:     manager.Release(lease1a)\n    513:     fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease1a.LeaseID, atomic.LoadInt64(&lease1a.RefCount))\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 596\n  Nosec  : 0\n  Issues : \u001b[1;31m6\u001b[0m\n\n[gosec] 2025/12/01 13:26:10 Including rules: default\n[gosec] 2025/12/01 13:26:10 Excluding rules: default\n[gosec] 2025/12/01 13:26:10 Including analyzers: default\n[gosec] 2025/12/01 13:26:10 Excluding analyzers: default\n[gosec] 2025/12/01 13:26:10 Import directory: /tmp/go_synthesis_9vi4yjgq\n[gosec] 2025/12/01 13:26:11 Checking package: main\n[gosec] 2025/12/01 13:26:11 Checking file: /tmp/go_synthesis_9vi4yjgq/main.go"
                },
                {
                    "verifier": "errcheck",
                    "error": "main.go:512:20:\tmanager.Release(lease1a)\nmain.go:514:20:\tmanager.Release(lease1b) // Refcount should be 0, trigger cleanup check\nmain.go:540:20:\tmanager.Release(lease2a) // This lease is now obsolete and refcount hits 0\nmain.go:543:20:\tmanager.Release(lease2b) // The new latest lease\nmain.go:571:20:\tmanager.Release(lease3a)\nmain.go:585:20:\tmanager.Release(lease4a)"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "/tmp/go_synthesis_9vi4yjgq/main.go:565:22: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error\n/tmp/go_synthesis_9vi4yjgq/main.go:588:8: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"sync/atomic\"\n    \"time\"\n\n    \"golang.org/x/sync/singleflight\"\n)\n\n// --- Custom Errors ---\nvar (\n    ErrTableDeleted     = errors.New(\"table is marked as deleted\")\n    ErrLeaseNotFound    = errors.New(\"lease not found\")\n    ErrNegativeRefCount = errors.New(\"attempted to release a lease with non-positive refcount\")\n)\n\n// LeaseState represents a specific version of a table's metadata lease.\ntype LeaseState struct {\n    LeaseID   string // Unique identifier for this specific lease version\n    DbID      string\n    TableID   string // Canonical ID for the table (e.g., UUID from metadata store)\n    TableName string\n    Version   int64\n    RefCount  int64 // Atomic reference count\n}\n\n// LeaseStore simulates a backend store for leases.\ntype LeaseStore interface {\n    FetchLatestLease(dbID, tableName string) (*LeaseState, error)\n    NotifyLeaseCleanup(leaseID string) error // Notifies backend that a lease version can be cleaned up\n    NotifyTableDeleted(tableID string) error // Notifies backend that a table is marked deleted\n}\n\n// MockLeaseStore is a concrete implementation for testing.\ntype MockLeaseStore struct {\n    sync.Mutex\n    leases       map[string]*LeaseState // key: LeaseID\n    tableLatest  map[string]string      // key: dbID/tableName, value: LeaseID of latest\n    tableDeleted map[string]bool        // key: TableID\n    cleanupCount int\n    deleteCount  int\n}\n\nfunc NewMockLeaseStore() *MockLeaseStore {\n    return &MockLeaseStore{\n        leases:       make(map[string]*LeaseState),\n        tableLatest:  make(map[string]string),\n        tableDeleted: make(map[string]bool),\n    }\n}\n\nfunc (m *MockLeaseStore) FetchLatestLease(dbID, tableName string) (*LeaseState, error) {\n    m.Lock()\n    defer m.Unlock()\n\n    tableID := makeTableID(dbID, tableName)\n    if m.tableDeleted[tableID] {\n        return nil, ErrTableDeleted\n    }\n\n    key := makeCacheKey(dbID, tableName)\n    latestLeaseID, found := m.tableLatest[key]\n\n    if !found {\n        // Simulate creating a new lease if none exists\n        newVersion := int64(1)\n        leaseID := fmt.Sprintf(\"%s-%d-%d\", tableID, newVersion, time.Now().UnixNano())\n        lease := &LeaseState{\n            LeaseID:   leaseID,\n            DbID:      dbID,\n            TableID:   tableID,\n            TableName: tableName,\n            Version:   newVersion,\n            RefCount:  0, // RefCount starts at 0, Acquire increments it\n        }\n        m.leases[leaseID] = lease\n        m.tableLatest[key] = leaseID\n        return lease, nil\n    }\n\n    // Simulate fetching the existing latest lease\n    lease, found := m.leases[latestLeaseID]\n    if !found {\n        return nil, fmt.Errorf(\"lease store internal error: latest lease ID %s not found\", latestLeaseID)\n    }\n    return lease, nil\n}\n\n// BumpVersion simulates a new version being available in the backend for a table.\nfunc (m *MockLeaseStore) BumpVersion(dbID, tableName string) *LeaseState {\n    m.Lock()\n    defer m.Unlock()\n\n    tableID := makeTableID(dbID, tableName)\n    key := makeCacheKey(dbID, tableName)\n    \n    currentLeaseID, found := m.tableLatest[key]\n    var currentVersion int64 = 0\n    if found {\n        if l, ok := m.leases[currentLeaseID]; ok {\n            currentVersion = l.Version\n        }\n    }\n\n    newVersion := currentVersion + 1\n    newLeaseID := fmt.Sprintf(\"%s-%d-%d\", tableID, newVersion, time.Now().UnixNano())\n    newLease := &LeaseState{\n        LeaseID:   newLeaseID,\n        DbID:      dbID,\n        TableID:   tableID,\n        TableName: tableName,\n        Version:   newVersion,\n        RefCount:  0,\n    }\n    m.leases[newLeaseID] = newLease\n    m.tableLatest[key] = newLeaseID\n    log.Printf(\"MockLeaseStore: Bumped version for %s/%s to %d, new LeaseID: %s\", dbID, tableName, newVersion, newLeaseID)\n    return newLease\n}\n\nfunc (m *MockLeaseStore) NotifyLeaseCleanup(leaseID string) error {\n    m.Lock()\n    defer m.Unlock()\n    log.Printf(\"MockLeaseStore: Notifying cleanup for LeaseID: %s\", leaseID)\n    delete(m.leases, leaseID) // Remove from mock store's memory\n    m.cleanupCount++\n    return nil\n}\n\nfunc (m *MockLeaseStore) NotifyTableDeleted(tableID string) error {\n    m.Lock()\n    defer m.Unlock()\n    log.Printf(\"MockLeaseStore: Notifying table deletion for TableID: %s\", tableID)\n    m.tableDeleted[tableID] = true\n    m.deleteCount++\n    return nil\n}\n\n// TableState manages all lease versions for a given table ID.\ntype TableState struct {\n    sync.Mutex // Protects internal fields of this TableState\n    DbID               string\n    TableID            string\n    TableName          string\n    Leases             map[int64]*LeaseState // Version -> LeaseState\n    LatestVersion      int64\n    TableMarkedDeleted bool\n    CleaningUpLeases   map[string]struct{} // Set of LeaseIDs that have been marked for cleanup\n    // associatedCacheKeys maps dbID/tableName to indicate which tableNameCache keys point to this table's leases.\n    // Used for invalidation during table deletion.\n    associatedCacheKeys map[string]struct{}\n}\n\n// LeaseManager is the main entry point for the lease management system.\ntype LeaseManager struct {\n    sync.RWMutex // Protects tableStates and tableNameCache maps themselves (adding/removing map entries)\n    leaseStore     LeaseStore\n    tableStates    map[string]*TableState // TableID -> TableState\n    tableNameCache map[string]*LeaseState // dbID/tableName -> Latest active LeaseState\n    fetchGroup     singleflight.Group     // Prevents thundering herd on LeaseStore for same cacheKey\n}\n\n// NewLeaseManager creates a new LeaseManager instance.\nfunc NewLeaseManager(store LeaseStore) *LeaseManager {\n    return &LeaseManager{\n        leaseStore:     store,\n        tableStates:    make(map[string]*TableState),\n        tableNameCache: make(map[string]*LeaseState),\n    }\n}\n\n// makeCacheKey creates a key for tableNameCache, typically \"dbID/tableName\".\nfunc makeCacheKey(dbID, tableName string) string {\n    return dbID + \"/\" + tableName\n}\n\n// makeTableID creates the canonical TableID.\n// In a real system, this might be a UUID from a metadata store lookup.\n// For this mock, we derive it from DbID and TableName.\nfunc makeTableID(dbID, tableName string) string {\n    return fmt.Sprintf(\"%s:%s\", dbID, tableName)\n}\n\n// getTableState attempts to retrieve a TableState by its TableID.\n// It acquires the LeaseManager's RLock and, if found, the TableState's Lock.\nfunc (lm *LeaseManager) getTableState(tableID string) (*TableState, bool) {\n    lm.RWMutex.RLock()\n    ts, found := lm.tableStates[tableID]\n    lm.RWMutex.RUnlock()\n    if !found {\n        return nil, false\n    }\n    ts.Lock() // Lock the specific TableState's internal mutex\n    return ts, true\n}\n\n// getOrCreateTableState retrieves or creates a TableState.\n// It acquires the LeaseManager's Write Lock to potentially modify the tableStates map.\n// It returns the TableState with its internal mutex already locked.\nfunc (lm *LeaseManager) getOrCreateTableState(dbID, tableID, tableName string) *TableState {\n    lm.RWMutex.Lock() // Acquire write lock on manager to potentially modify tableStates map\n    ts, found := lm.tableStates[tableID]\n    if !found {\n        ts = &TableState{\n            DbID:                dbID,\n            TableID:             tableID,\n            TableName:           tableName,\n            Leases:              make(map[int64]*LeaseState),\n            CleaningUpLeases:    make(map[string]struct{}),\n            associatedCacheKeys: make(map[string]struct{}),\n        }\n        lm.tableStates[tableID] = ts\n    }\n    lm.RWMutex.Unlock() // Release manager write lock as soon as map modification is done\n\n    ts.Lock() // Lock the specific TableState's mutex\n    return ts\n}\n\n// AcquireByName acquires a lease for a given (dbID, tableName) pair.\n// It either returns a cached lease or fetches the latest from the LeaseStore.\nfunc (lm *LeaseManager) AcquireByName(dbID, tableName string) (*LeaseState, error) {\n    cacheKey := makeCacheKey(dbID, tableName)\n\n    // 1. Try to find in tableNameCache (read-only access to manager's cache map)\n    lm.RWMutex.RLock()\n    cachedLease, foundInCache := lm.tableNameCache[cacheKey]\n    lm.RWMutex.RUnlock()\n\n    if foundInCache {\n        // We have a cached lease, now check its validity with the TableState\n        ts, tsFound := lm.getTableState(cachedLease.TableID)\n        if tsFound {\n            defer ts.Unlock() // Ensure TableState mutex is released\n\n            if ts.TableMarkedDeleted {\n                log.Printf(\"AcquireByName: Cached lease %s for %s/%s is for a deleted table. Evicting and refetching.\",\n                    cachedLease.LeaseID, dbID, tableName)\n                // Invalidate this specific cache entry since it points to a deleted table\n                lm.RWMutex.Lock() // Acquire manager write lock to modify cache map\n                if currentCachedLease, stillPoints := lm.tableNameCache[cacheKey]; stillPoints && currentCachedLease == cachedLease {\n                    delete(lm.tableNameCache, cacheKey)\n                    delete(ts.associatedCacheKeys, cacheKey)\n                }\n                lm.RWMutex.Unlock()\n                goto fetchFromStore // Cache entry is stale due to deletion, fall through to fetch\n            }\n\n            if cachedLease.Version == ts.LatestVersion {\n                // Cache hit and valid, increment refcount and return\n                atomic.AddInt64(&cachedLease.RefCount, 1)\n                log.Printf(\"AcquireByName: Cache hit for %s/%s (LeaseID: %s, RefCount: %d)\",\n                    dbID, tableName, cachedLease.LeaseID, atomic.LoadInt64(&cachedLease.RefCount))\n                return cachedLease, nil\n            }\n            log.Printf(\"AcquireByName: Cached lease %s for %s/%s is outdated (version %d < latest %d). Evicting and refetching.\",\n                cachedLease.LeaseID, dbID, tableName, cachedLease.Version, ts.LatestVersion)\n            // Cache entry is stale due to new version, fall through to fetch (it will be overwritten)\n        } else {\n            // This case implies an inconsistency (cached lease refers to a TableID that doesn't have a TableState)\n            log.Printf(\"AcquireByName: Cached lease %s for %s/%s has no corresponding TableState. Evicting and refetching.\",\n                cachedLease.LeaseID, dbID, tableName)\n            lm.RWMutex.Lock() // Acquire manager write lock to modify cache map\n            if currentCachedLease, stillPoints := lm.tableNameCache[cacheKey]; stillPoints && currentCachedLease == cachedLease {\n                delete(lm.tableNameCache, cacheKey)\n            }\n            lm.RWMutex.Unlock()\n        }\n    }\n\nfetchFromStore:\n    // 2. Cache miss or stale entry, fetch from LeaseStore using singleflight to prevent duplicate fetches\n    v, err, _ := lm.fetchGroup.Do(cacheKey, func() (interface{}, error) {\n        fetchedLease, fetchErr := lm.leaseStore.FetchLatestLease(dbID, tableName)\n        if fetchErr != nil {\n            return nil, fetchErr\n        }\n        if fetchedLease == nil {\n            return nil, errors.New(\"LeaseStore returned nil lease with no error\")\n        }\n\n        // Get or create TableState for this lease's TableID. It will be locked upon return.\n        ts := lm.getOrCreateTableState(fetchedLease.DbID, fetchedLease.TableID, fetchedLease.TableName)\n        defer ts.Unlock() // Ensure TableState mutex is released\n\n        if ts.TableMarkedDeleted {\n            log.Printf(\"AcquireByName: Table %s/%s (%s) was marked deleted during fetch. Aborting acquisition.\",\n                dbID, tableName, fetchedLease.TableID)\n            return nil, ErrTableDeleted\n        }\n\n        // Add or update the lease in TableState's version list\n        ts.Leases[fetchedLease.Version] = fetchedLease\n        if fetchedLease.Version > ts.LatestVersion {\n            ts.LatestVersion = fetchedLease.Version\n        }\n\n        // Increment refcount for the newly acquired lease (atomically)\n        atomic.AddInt64(&fetchedLease.RefCount, 1)\n\n        // Update tableNameCache (requires manager write lock)\n        lm.RWMutex.Lock()\n        lm.tableNameCache[cacheKey] = fetchedLease\n        ts.associatedCacheKeys[cacheKey] = struct{}{} // Track this cache key for invalidation\n        lm.RWMutex.Unlock()\n\n        log.Printf(\"AcquireByName: Fetched new lease for %s/%s (LeaseID: %s, Version: %d, RefCount: %d)\",\n            dbID, tableName, fetchedLease.LeaseID, fetchedLease.Version, atomic.LoadInt64(&fetchedLease.RefCount))\n        return fetchedLease, nil\n    })\n\n    if err != nil {\n        return nil, err\n    }\n    return v.(*LeaseState), nil\n}\n\n// Release decrements the refcount of a lease. If refcount reaches zero,\n// it checks for cleanup conditions (obsolete version or deleted table) and triggers cleanup.\nfunc (lm *LeaseManager) Release(lease *LeaseState) error {\n    if lease == nil {\n        return nil\n    }\n\n    newCount := atomic.AddInt64(&lease.RefCount, -1)\n\n    if newCount > 0 {\n        log.Printf(\"Release: LeaseID %s refcount decremented to %d. Still in use.\", lease.LeaseID, newCount)\n        return nil // Lease still in use\n    }\n\n    if newCount < 0 {\n        // This indicates an over-release. Correct the refcount and return error.\n        atomic.AddInt64(&lease.RefCount, 1) // Increment back to 0\n        log.Printf(\"ERROR: Release: Negative refcount detected for LeaseID %s. Refcount reset to 0.\", lease.LeaseID)\n        return ErrNegativeRefCount\n    }\n\n    // Refcount is zero, proceed with cleanup checks\n    log.Printf(\"Release: LeaseID %s refcount reached zero. Checking for cleanup.\", lease.LeaseID)\n\n    ts, tsFound := lm.getTableState(lease.TableID)\n    if !tsFound {\n        log.Printf(\"ERROR: Release: TableState not found for LeaseID %s (TableID: %s). Cannot cleanup.\",\n            lease.LeaseID, lease.TableID)\n        return ErrLeaseNotFound\n    }\n    defer ts.Unlock() // Ensure TableState mutex is released\n\n    // Prevent duplicate cleanup calls if goroutine already started\n    if _, cleaningUp := ts.CleaningUpLeases[lease.LeaseID]; cleaningUp {\n        log.Printf(\"Release: LeaseID %s is already being cleaned up.\", lease.LeaseID)\n        return nil\n    }\n\n    // Determine if this lease should be cleaned up from internal structures and backend\n    shouldCleanupLease := false\n    if ts.TableMarkedDeleted {\n        log.Printf(\"Release: LeaseID %s marked for cleanup: Table %s is deleted.\", lease.LeaseID, lease.TableID)\n        shouldCleanupLease = true\n    } else if lease.Version < ts.LatestVersion {\n        log.Printf(\"Release: LeaseID %s marked for cleanup: Obsolete version (%d < latest %d) for Table %s.\",\n            lease.LeaseID, lease.Version, ts.LatestVersion, lease.TableID)\n        shouldCleanupLease = true\n    }\n\n    // Determine if this lease should be removed from tableNameCache\n    cacheKey := makeCacheKey(lease.DbID, lease.TableName)\n    shouldRemoveFromCache := false\n    lm.RWMutex.RLock() // Read lock to check current cache entry\n    currentCachedLease, cacheFound := lm.tableNameCache[cacheKey]\n    lm.RWMutex.RUnlock()\n\n    if cacheFound && currentCachedLease == lease {\n        if shouldCleanupLease {\n            shouldRemoveFromCache = true\n        } else {\n            // This lease is still the latest and table not deleted, but its refcount is zero.\n            // This state is fine. It can be re-acquired from cache or replaced by a newer version.\n            // Do not remove from cache yet.\n            log.Printf(\"Release: LeaseID %s is latest for Table %s, refcount 0. Keeping in cache for now.\", lease.LeaseID, lease.TableID)\n        }\n    }\n\n    if shouldCleanupLease {\n        // Remove from TableState's list of leases\n        delete(ts.Leases, lease.Version)\n        ts.CleaningUpLeases[lease.LeaseID] = struct{}{} // Mark as cleaning up to prevent future attempts\n\n        // Asynchronously notify LeaseStore for cleanup\n        go func(leaseID string) {\n            if err := lm.leaseStore.NotifyLeaseCleanup(leaseID); err != nil {\n                log.Printf(\"ERROR: LeaseStore.NotifyLeaseCleanup for %s failed: %v\", leaseID, err)\n            } else {\n                log.Printf(\"LeaseStore.NotifyLeaseCleanup for %s successful.\", leaseID)\n            }\n        }(lease.LeaseID)\n    }\n\n    if shouldRemoveFromCache {\n        // Need manager write lock to modify tableNameCache map\n        lm.RWMutex.Lock()\n        // Double-check under write lock, in case another acquire/release updated the cache\n        currentCachedLease, cacheFound = lm.tableNameCache[cacheKey]\n        if cacheFound && currentCachedLease == lease {\n            delete(lm.tableNameCache, cacheKey)\n            delete(ts.associatedCacheKeys, cacheKey) // Remove tracking from TableState\n            log.Printf(\"Release: Evicted LeaseID %s from tableNameCache (cacheKey: %s).\", lease.LeaseID, cacheKey)\n        }\n        lm.RWMutex.Unlock()\n    }\n\n    return nil\n}\n\n// MarkTableDeleted marks a table as deleted, initiating cleanup for eligible leases.\nfunc (lm *LeaseManager) MarkTableDeleted(dbID, tableName string) error {\n    tableID := makeTableID(dbID, tableName)\n\n    ts, tsFound := lm.getTableState(tableID)\n    if !tsFound {\n        log.Printf(\"MarkTableDeleted: TableState not found for TableID %s. It might not exist or already cleaned up.\", tableID)\n        return nil // Idempotent: if not found, it's effectively deleted from our perspective\n    }\n    defer ts.Unlock() // Ensure TableState mutex is released\n\n    if ts.TableMarkedDeleted {\n        log.Printf(\"MarkTableDeleted: Table %s already marked as deleted.\", tableID)\n        return nil // Idempotent\n    }\n\n    ts.TableMarkedDeleted = true\n    log.Printf(\"MarkTableDeleted: Table %s marked as deleted.\", tableID)\n\n    // Notify LeaseStore backend that the table is deleted\n    go func(tableID string) {\n        if err := lm.leaseStore.NotifyTableDeleted(tableID); err != nil {\n            log.Printf(\"ERROR: LeaseStore.NotifyTableDeleted for %s failed: %v\", tableID, err)\n        } else {\n            log.Printf(\"LeaseStore.NotifyTableDeleted for %s successful.\", tableID)\n        }\n    }(tableID)\n\n    // Invalidate associated cache entries\n    lm.RWMutex.Lock() // Need manager write lock to modify tableNameCache\n    for cacheKey := range ts.associatedCacheKeys {\n        if currentCachedLease, cacheFound := lm.tableNameCache[cacheKey]; cacheFound && currentCachedLease.TableID == tableID {\n            // Evict from cache if it points to a lease of this deleted table\n            delete(lm.tableNameCache, cacheKey)\n            log.Printf(\"MarkTableDeleted: Evicted cacheKey %s due to table deletion.\", cacheKey)\n        }\n    }\n    // Clear associatedCacheKeys for the table state as they are no longer valid for active cache entries\n    ts.associatedCacheKeys = make(map[string]struct{})\n    lm.RWMutex.Unlock()\n\n    // Now iterate through all leases for this table and clean up those with refcount 0\n    // Leases with positive refcount will be cleaned up upon their final Release.\n    for _, lease := range ts.Leases {\n        if atomic.LoadInt64(&lease.RefCount) == 0 {\n            if _, cleaningUp := ts.CleaningUpLeases[lease.LeaseID]; !cleaningUp {\n                log.Printf(\"MarkTableDeleted: Cleanup for LeaseID %s (refcount 0) due to table deletion.\", lease.LeaseID)\n                delete(ts.Leases, lease.Version)          // Remove from TableState's list\n                ts.CleaningUpLeases[lease.LeaseID] = struct{}{} // Mark as cleaning up\n                go func(leaseID string) {\n                    if err := lm.leaseStore.NotifyLeaseCleanup(leaseID); err != nil {\n                        log.Printf(\"ERROR: LeaseStore.NotifyLeaseCleanup for %s failed (from MarkTableDeleted): %v\", leaseID, err)\n                    } else {\n                        log.Printf(\"LeaseStore.NotifyLeaseCleanup for %s successful (from MarkTableDeleted).\", leaseID)\n                    }\n                }(lease.LeaseID)\n            }\n        }\n    }\n    return nil\n}\n\nfunc main() {\n    log.SetFlags(log.Ltime | log.Lshortfile)\n    fmt.Println(\"Starting Lease Management System Demo\")\n\n    mockStore := NewMockLeaseStore()\n    manager := NewLeaseManager(mockStore)\n\n    db1 := \"mydb1\"\n    tbl1 := \"mytable1\"\n    db2 := \"mydb2\"\n    tbl2 := \"mytable2\"\n    db3 := \"mydb3\"\n    tbl3 := \"mytable3\"\n\n    fmt.Println(\"\\n--- Scenario 1: Basic Acquire/Release ---\")\n    lease1a, err := manager.AcquireByName(db1, tbl1)\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 1a: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, RefCount: %d\\n\", lease1a.LeaseID, atomic.LoadInt64(&lease1a.RefCount))\n\n    lease1b, err := manager.AcquireByName(db1, tbl1) // Should return the same lease\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 1b: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, RefCount: %d\\n\", lease1b.LeaseID, atomic.LoadInt64(&lease1b.RefCount))\n    if lease1a.LeaseID != lease1b.LeaseID {\n        log.Fatal(\"Error: AcquireByName for same table returned different leases!\")\n    }\n\n    if err = manager.Release(lease1a); err != nil {\n        log.Fatalf(\"Failed to release lease 1a: %v\", err)\n    }\n    fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease1a.LeaseID, atomic.LoadInt64(&lease1a.RefCount))\n    if err = manager.Release(lease1b); err != nil { // Refcount should be 0, trigger cleanup check\n        log.Fatalf(\"Failed to release lease 1b: %v\", err)\n    }\n    fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease1b.LeaseID, atomic.LoadInt64(&lease1b.RefCount))\n\n    time.Sleep(100 * time.Millisecond) // Allow async cleanup to run\n    fmt.Printf(\"Cleanup notifications sent: %d\\n\", mockStore.cleanupCount)\n    // Lease for db1/tbl1 should be cleaned up as it was the only version and refcount hit 0.\n\n    fmt.Println(\"\\n--- Scenario 2: Version Bump and Obsolete Lease Cleanup ---\")\n    lease2a, err := manager.AcquireByName(db2, tbl2)\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 2a: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, Version: %d, RefCount: %d\\n\", lease2a.LeaseID, lease2a.Version, atomic.LoadInt64(&lease2a.RefCount))\n\n    // Simulate a backend version bump\n    mockStore.BumpVersion(db2, tbl2)\n\n    lease2b, err := manager.AcquireByName(db2, tbl2) // Should fetch new version\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 2b: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, Version: %d, RefCount: %d\\n\", lease2b.LeaseID, lease2b.Version, atomic.LoadInt64(&lease2b.RefCount))\n    if lease2a.LeaseID == lease2b.LeaseID {\n        log.Fatal(\"Error: AcquireByName after version bump returned same lease!\")\n    }\n\n    if err = manager.Release(lease2a); err != nil { // This lease is now obsolete and refcount hits 0\n        log.Fatalf(\"Failed to release obsolete lease 2a: %v\", err)\n    }\n    fmt.Printf(\"Released Lease: %s (obsolete), RefCount: %d\\n\", lease2a.LeaseID, atomic.LoadInt64(&lease2a.RefCount))\n\n    if err = manager.Release(lease2b); err != nil { // The new latest lease\n        log.Fatalf(\"Failed to release lease 2b: %v\", err)\n    }\n    fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease2b.LeaseID, atomic.LoadInt64(&lease2b.RefCount))\n\n    time.Sleep(100 * time.Millisecond) // Allow async cleanup to run\n    fmt.Printf(\"Cleanup notifications sent: %d (total)\\n\", mockStore.cleanupCount)\n\n    fmt.Println(\"\\n--- Scenario 3: Mark Table Deleted ---\")\n    lease3a, err := manager.AcquireByName(db3, tbl3)\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 3a: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, Version: %d, RefCount: %d\\n\", lease3a.LeaseID, lease3a.Version, atomic.LoadInt64(&lease3a.RefCount))\n\n    // Mark table db3/tbl3 as deleted\n    err = manager.MarkTableDeleted(db3, tbl3)\n    if err != nil {\n        log.Fatalf(\"Failed to mark table deleted: %v\", err)\n    }\n    fmt.Printf(\"Table %s/%s marked deleted.\\n\", db3, tbl3)\n\n    // Try to acquire lease for a deleted table\n    _, err = manager.AcquireByName(db3, tbl3)\n    if err == nil || !errors.Is(err, ErrTableDeleted) { // FIX: Use errors.Is\n        log.Fatalf(\"Expected ErrTableDeleted, got: %v\", err)\n    }\n    fmt.Printf(\"Attempt to acquire lease for deleted table %s/%s resulted in expected error: %v\\n\", db3, tbl3, err)\n\n    // Release the previously acquired lease for the now-deleted table\n    if err = manager.Release(lease3a); err != nil {\n        log.Fatalf(\"Failed to release lease 3a: %v\", err)\n    }\n    fmt.Printf(\"Released Lease: %s (deleted table), RefCount: %d\\n\", lease3a.LeaseID, atomic.LoadInt64(&lease3a.RefCount))\n\n    time.Sleep(100 * time.Millisecond) // Allow async cleanup to run\n    fmt.Printf(\"Cleanup notifications sent: %d (total)\\n\", mockStore.cleanupCount)\n    fmt.Printf(\"Table deletion notifications sent: %d\\n\", mockStore.deleteCount)\n\n    // Verify negative refcount prevention\n    fmt.Println(\"\\n--- Scenario 4: Negative Refcount Prevention ---\")\n    lease4a, err := manager.AcquireByName(\"db4\", \"tbl4\")\n    if err != nil {\n        log.Fatalf(\"Failed to acquire lease 4a: %v\", err)\n    }\n    fmt.Printf(\"Acquired Lease: %s, RefCount: %d\\n\", lease4a.LeaseID, atomic.LoadInt64(&lease4a.RefCount))\n    if err = manager.Release(lease4a); err != nil {\n        log.Fatalf(\"Failed to release lease 4a: %v\", err)\n    }\n    fmt.Printf(\"Released Lease: %s, RefCount: %d\\n\", lease4a.LeaseID, atomic.LoadInt64(&lease4a.RefCount))\n    err = manager.Release(lease4a) // This should cause ErrNegativeRefCount\n    if !errors.Is(err, ErrNegativeRefCount) { // FIX: Use errors.Is\n        log.Fatalf(\"Expected ErrNegativeRefCount, got: %v\", err)\n    }\n    fmt.Printf(\"Attempt to over-release Lease: %s resulted in expected error: %v\\n\", lease4a.LeaseID, err)\n    fmt.Printf(\"Lease: %s RefCount after over-release attempt: %d\\n\", lease4a.LeaseID, atomic.LoadInt64(&lease4a.RefCount))\n\n\n    fmt.Println(\"\\nDemo Finished.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}