{
    "task": "7618fdd1d642e47cac70c03f637b0fd798a53a6e.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Broadcast represents an individual broadcast channel.\ntype Broadcast struct {\n\tkey      string\n\tstopCh   chan struct{}  // Signals the broadcast's goroutine to stop\n\twg       sync.WaitGroup // Waits for the broadcast's goroutine to finish\n\tlogger   *log.Logger\n\teventsCh chan string    // Simulates a channel for sending events to subscribers\n}\n\n// NewBroadcast creates and returns a new Broadcast instance.\nfunc NewBroadcast(key string, logger *log.Logger) *Broadcast {\n\treturn &Broadcast{\n\t\tkey:      key,\n\t\tstopCh:   make(chan struct{}),\n\t\tlogger:   logger,\n\t\teventsCh: make(chan string, 10), // Buffered channel for simulation\n\t}\n}\n\n// Run starts the broadcast's goroutine, simulating event sending.\nfunc (b *Broadcast) Run() {\n\tb.wg.Add(1)\n\tgo func() {\n\t\tdefer b.wg.Done()\n\t\tb.logger.Printf(\"Broadcast '%s' started.\", b.key)\n\n\t\tticker := time.NewTicker(500 * time.Millisecond) // Simulate sending events periodically\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\t// Simulate sending an event\n\t\t\t\tevent := fmt.Sprintf(\"Event from %s at %s\", b.key, time.Now().Format(\"15:04:05\"))\n\t\t\t\tselect {\n\t\t\t\tcase b.eventsCh <- event:\n\t\t\t\t\tb.logger.Printf(\"Broadcast '%s' sent event: %s\", b.key, event)\n\t\t\t\tdefault:\n\t\t\t\t\t// Channel full, simulate dropping event or backpressure\n\t\t\t\t\tb.logger.Printf(\"Broadcast '%s' events channel full, dropped event.\", b.key)\n\t\t\t\t}\n\t\t\tcase <-b.stopCh:\n\t\t\t\tb.logger.Printf(\"Broadcast '%s' stopping.\", b.key)\n\t\t\t\tclose(b.eventsCh) // Close the events channel to signal no more events\n\t\t\t\t// Drain any remaining events in eventsCh if necessary before exiting\n\t\t\t\t// For this simulation, we'll just exit.\n\t\t\t\tb.logger.Printf(\"Broadcast '%s' stopped.\", b.key)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// Stop signals the broadcast to terminate and waits for its goroutine to finish.\nfunc (b *Broadcast) Stop() {\n\tclose(b.stopCh)\n\tb.wg.Wait()\n}\n\n// BroadcastManager manages a collection of broadcast channels.\ntype BroadcastManager struct {\n\tchannels map[string]*Broadcast\n\tmu       sync.RWMutex // Protects the 'channels' map\n\n\tupdateCh chan struct{}  // Signals coalesce loop about configuration changes\n\tstopCh   chan struct{}  // Signals coalesce loop to stop\n\twg       sync.WaitGroup // Waits for the coalesce loop to finish\n\tlogger   *log.Logger\n}\n\n// NewBroadcastManager creates and returns a new BroadcastManager instance.\nfunc NewBroadcastManager(logger *log.Logger) *BroadcastManager {\n\treturn &BroadcastManager{\n\t\tchannels: make(map[string]*Broadcast),\n\t\tupdateCh: make(chan struct{}, 1), // Buffered to coalesce updates\n\t\tstopCh:   make(chan struct{}),\n\t\tlogger:   logger,\n\t}\n}\n\n// Run starts the background coalesce loop for the manager.\nfunc (bm *BroadcastManager) Run() {\n\tbm.wg.Add(1)\n\tgo func() {\n\t\tdefer bm.wg.Done()\n\t\tbm.logger.Println(\"BroadcastManager coalesce loop started.\")\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-bm.updateCh:\n\t\t\t\t// Process updates. In this simulation, we just log the current state.\n\t\t\t\tbm.mu.RLock()\n\t\t\t\tcount := len(bm.channels)\n\t\t\t\tbm.mu.RUnlock()\n\t\t\t\tbm.logger.Printf(\"BroadcastManager coalesce loop processing update. Active channels: %d\", count)\n\t\t\tcase <-bm.stopCh:\n\t\t\t\tbm.logger.Println(\"BroadcastManager coalesce loop stopping.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// signalUpdate sends a non-blocking signal to the coalesce loop.\n// If the buffer is full, it means an update is already pending, so we coalesce.\nfunc (bm *BroadcastManager) signalUpdate() {\n\tselect {\n\tcase bm.updateCh <- struct{}{}:\n\t\t// Signal sent successfully\n\tdefault:\n\t\t// Channel is full, a signal is already pending, no need to send another.\n\t}\n}\n\n// AddBroadcast creates, registers, and starts a new broadcast channel.\nfunc (bm *BroadcastManager) AddBroadcast(key string) {\n\tbm.mu.Lock()\n\tdefer bm.mu.Unlock()\n\n\tif _, ok := bm.channels[key]; ok {\n\t\tbm.logger.Printf(\"Broadcast '%s' already exists, skipping add.\", key)\n\t\treturn\n\t}\n\n\tb := NewBroadcast(key, bm.logger)\n\tbm.channels[key] = b\n\tb.Run() // Start the broadcast's event sending goroutine\n\n\tbm.logger.Printf(\"Added broadcast '%s'.\", key)\n\tbm.signalUpdate() // Notify coalesce loop about the change\n}\n\n// RemoveBroadcast stops and unregisters an existing broadcast channel.\nfunc (bm *BroadcastManager) RemoveBroadcast(key string) {\n\tbm.mu.Lock()\n\tdefer bm.mu.Unlock()\n\n\tb, ok := bm.channels[key]\n\tif !ok {\n\t\tbm.logger.Printf(\"Broadcast '%s' does not exist, skipping remove.\", key)\n\t\treturn\n\t}\n\n\tb.Stop() // Stop the broadcast gracefully\n\tdelete(bm.channels, key)\n\n\tbm.logger.Printf(\"Removed broadcast '%s'.\", key)\n\tbm.signalUpdate() // Notify coalesce loop about the change\n}\n\n// Stop gracefully shuts down the entire broadcast system.\n// It stops all active broadcasts, closes the update channel, and waits for the\n// background coalesce goroutine to finish.\nfunc (bm *BroadcastManager) Stop() {\n\tbm.logger.Println(\"BroadcastManager initiating graceful shutdown...\")\n\n\t// 1. Signal the coalesce loop to stop and wait for it to finish\n\tclose(bm.stopCh)\n\tbm.wg.Wait()\n\tbm.logger.Println(\"BroadcastManager coalesce loop stopped.\")\n\n\t// 2. Stop all active broadcasts\n\tbm.mu.Lock() // Lock to prevent any concurrent modification to the channels map\n\tfor key, b := range bm.channels {\n\t\tb.Stop()\n\t\tdelete(bm.channels, key) // Remove from map after stopping\n\t}\n\tbm.mu.Unlock()\n\tbm.logger.Println(\"All individual broadcasts stopped and removed from manager.\")\n\n\tbm.logger.Println(\"BroadcastManager shutdown complete.\")\n}\n\nfunc main() {\n\t// Set up a logger for consistent output formatting\n\tlogger := log.New(os.Stdout, \"[BROADCAST_SYSTEM] \", log.Ldate|log.Ltime|log.Lmicroseconds|log.Lshortfile)\n\n\tlogger.Println(\"--- Starting Broadcast System test scenario ---\")\n\n\t// 1. Start the broadcast manager\n\tmanager := NewBroadcastManager(logger)\n\tmanager.Run() // Start the manager's background coalesce loop\n\n\t// 2. Add multiple broadcast channels\n\tlogger.Println(\"Phase 1: Adding initial broadcast channels.\")\n\tmanager.AddBroadcast(\"channel-A\")\n\tmanager.AddBroadcast(\"channel-B\")\n\tmanager.AddBroadcast(\"channel-C\")\n\ttime.Sleep(1 * time.Second) // Allow some time for events to be sent and updates processed\n\n\t// 3. Concurrently add/remove broadcasts while the system is running\n\tlogger.Println(\"Phase 2: Starting concurrent add/remove operations.\")\n\tvar concurrentOpsWg sync.WaitGroup\n\tconcurrentOpsWg.Add(1)\n\tgo func() {\n\t\tdefer concurrentOpsWg.Done()\n\t\tmanager.AddBroadcast(\"channel-D\")\n\t\ttime.Sleep(250 * time.Millisecond)\n\t\tmanager.RemoveBroadcast(\"channel-A\")\n\t\ttime.Sleep(300 * time.Millisecond)\n\t\tmanager.AddBroadcast(\"channel-E\")\n\t\ttime.Sleep(250 * time.Millisecond)\n\t\tmanager.RemoveBroadcast(\"channel-B\")\n\t\ttime.Sleep(300 * time.Millisecond)\n\t\tmanager.AddBroadcast(\"channel-F\")\n\t\ttime.Sleep(250 * time.Millisecond)\n\t\tmanager.RemoveBroadcast(\"channel-C\")\n\t\tlogger.Println(\"Concurrent add/remove operations finished.\")\n\t}()\n\n\tconcurrentOpsWg.Wait()              // Wait for all concurrent add/remove operations to complete\n\ttime.Sleep(500 * time.Millisecond) // Give a little more time for final updates to propagate\n\n\t// 4. Call Stop() to gracefully shutdown the system\n\tlogger.Println(\"Phase 3: Initiating system shutdown with a timeout.\")\n\tstopDone := make(chan struct{})\n\n\tgo func() {\n\t\tmanager.Stop()\n\t\tclose(stopDone)\n\t}()\n\n\t// 5. Verify that Stop() completes without hanging (use a timeout)\n\tselect {\n\tcase <-stopDone:\n\t\tlogger.Println(\"SUCCESS: System shutdown completed within the allowed timeout.\")\n\tcase <-time.After(5 * time.Second): // 5-second timeout for graceful shutdown\n\t\tlogger.Println(\"ERROR: System shutdown timed out after 5 seconds! This indicates a potential deadlock or hang.\")\n\t\tlogger.Println(\"Test FAILED.\")\n\t\tos.Exit(1)\n\t}\n\n\t// 6. Ensure all resources are properly cleaned up\n\tmanager.mu.RLock()\n\tactiveChannelsCount := len(manager.channels)\n\tmanager.mu.RUnlock()\n\n\tif activeChannelsCount == 0 {\n\t\tlogger.Println(\"Verification: All broadcast channels successfully removed from manager's map.\")\n\t\tlogger.Println(\"Test PASSED.\")\n\t} else {\n\t\tlogger.Printf(\"Verification: ERROR: %d broadcast channels still remain in manager's map after shutdown.\", activeChannelsCount)\n\t\tlogger.Println(\"Test FAILED.\")\n\t\tos.Exit(1)\n\t}\n\n\tlogger.Println(\"--- Broadcast System test scenario finished ---\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}