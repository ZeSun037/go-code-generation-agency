{
    "task": "1cc699802557f67d4464de391b7350a527f9f445.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// NodeManager manages peer connections and background operations in a distributed system.\ntype NodeManager struct {\n\tmu                  sync.Mutex\n\tclosed              bool // Flag to indicate if the manager is shutting down\n\twg                  sync.WaitGroup\n\tctx                 context.Context    // Context for signaling goroutine cancellation\n\tcancel              context.CancelFunc // Function to cancel the context\n\toutgoingConnections int                // Simulated count of active outgoing connections\n}\n\n// NewNodeManager creates and initializes a new NodeManager.\nfunc NewNodeManager() *NodeManager {\n\tctx, cancel := context.WithCancel(context.Background())\n\treturn &NodeManager{\n\t\tctx:                 ctx,\n\t\tcancel:              cancel,\n\t\toutgoingConnections: 3, // Start with a few simulated connections\n\t}\n}\n\n// Start initiates the background goroutines for bootstrapping and managing connections.\nfunc (nm *NodeManager) Start() {\n\tnm.wg.Add(2) // We have two background goroutines to wait for\n\n\tgo nm.bootstrap()\n\tgo nm.manage()\n}\n\n// Shutdown gracefully stops the NodeManager and waits for all background goroutines to complete.\nfunc (nm *NodeManager) Shutdown() {\n\tfmt.Println(\"Manager: Initiating shutdown...\")\n\n\t// 1. Mark the manager as closed. This is used by goroutines to check state.\n\tnm.mu.Lock()\n\tnm.closed = true\n\tnm.mu.Unlock()\n\n\t// 2. Signal all goroutines to stop via context cancellation.\n\t// This closes nm.ctx.Done() channel, triggering select cases in goroutines.\n\tnm.cancel()\n\n\t// 3. Wait for all background goroutines to complete their tasks.\n\tnm.wg.Wait()\n\tfmt.Println(\"Manager: All background goroutines stopped.\")\n}\n\n// bootstrap periodically discovers and connects to seed nodes.\n// It runs in a loop with a 5-second interval and exits upon shutdown signal.\nfunc (nm *NodeManager) bootstrap() {\n\tdefer nm.wg.Done() // Signal WaitGroup when this goroutine exits\n\tfmt.Println(\"Bootstrap: Starting goroutine...\")\n\n\tticker := time.NewTicker(5 * time.Second)\n\tdefer ticker.Stop() // Ensure ticker is stopped when function exits\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// This case executes every 5 seconds.\n\t\t\t// Acquire lock to check shared state (though ctx.Done() is the primary exit).\n\t\t\tnm.mu.Lock()\n\t\t\tif nm.closed {\n\t\t\t\t// Manager is closed. Unlock and allow the select to process ctx.Done() in the next iteration.\n\t\t\t\tnm.mu.Unlock()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Println(\"Bootstrap: Discovering and connecting to seed nodes...\")\n\t\t\tnm.mu.Unlock()\n\n\t\tcase <-nm.ctx.Done():\n\t\t\t// Context cancelled, indicating shutdown. Exit immediately as there's no draining logic.\n\t\t\tfmt.Println(\"Bootstrap: Shutdown signal received. Exiting.\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// manage maintains connections to peer nodes.\n// It runs in a loop with a 3-second interval and exits when the manager is closed\n// AND all simulated outgoing connections have been gracefully terminated.\nfunc (nm *NodeManager) manage() {\n\tdefer nm.wg.Done() // Signal WaitGroup when this goroutine exits\n\tfmt.Println(\"Manage: Starting goroutine...\")\n\n\tticker := time.NewTicker(3 * time.Second)\n\tdefer ticker.Stop() // Ensure ticker is stopped when function exits\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t// This case executes every 3 seconds.\n\t\t\tnm.mu.Lock()\n\t\t\t// Check the exit condition: manager closed AND no outgoing connections left.\n\t\t\tif nm.closed && nm.outgoingConnections <= 0 {\n\t\t\t\tfmt.Println(\"Manage: Manager closed and no outgoing connections. Exiting.\")\n\t\t\t\tnm.mu.Unlock()\n\t\t\t\treturn // Clean exit\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Manage: Maintaining peer connections (active: %d)...\\n\", nm.outgoingConnections)\n\t\t\tif nm.outgoingConnections > 0 {\n\t\t\t\tnm.outgoingConnections-- // Simulate a connection being closed/drained\n\t\t\t\tfmt.Printf(\"Manage: Decreased connection count to %d.\\n\", nm.outgoingConnections)\n\t\t\t}\n\t\t\tnm.mu.Unlock()\n\n\t\tcase <-nm.ctx.Done():\n\t\t\t// Context cancelled. The manager is shutting down.\n\t\t\t// We don't exit immediately because there might still be active connections\n\t\t\t// that need to drain. The loop will continue via ticker.C until the\n\t\t\t// 'nm.closed && nm.outgoingConnections <= 0' condition is met.\n\t\t\tfmt.Println(\"Manage: Shutdown signal received. Draining connections...\")\n\n\t\t\t// Perform an immediate check after receiving the shutdown signal\n\t\t\t// for a quicker exit if connections are already drained.\n\t\t\tnm.mu.Lock()\n\t\t\tif nm.closed && nm.outgoingConnections <= 0 {\n\t\t\t\tfmt.Println(\"Manage: Immediate exit after shutdown signal: no outgoing connections. Exiting.\")\n\t\t\t\tnm.mu.Unlock()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnm.mu.Unlock()\n\t\t\t// If not ready to exit, the loop continues, and ticker.C will eventually trigger the check.\n\t\t}\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"Main: Starting Distributed Node Manager...\")\n\n\t// Create a new NodeManager instance\n\tnm := NewNodeManager()\n\n\t// Start its background operations\n\tnm.Start()\n\n\t// Let the manager run for a period (e.g., 10 seconds)\n\tfmt.Println(\"Main: Node Manager running for 10 seconds...\")\n\ttime.Sleep(10 * time.Second)\n\n\t// Initiate shutdown and wait for clean termination\n\tnm.Shutdown()\n\n\tfmt.Println(\"Main: Shutdown complete.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}