{
    "task": "9497e9678cdc64785847993c96ff2748e09ef9a1.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n)\n\n// LockManager manages distributed locks on string prefixes.\n// It allows multiple clients to acquire and release locks on different or the same prefixes.\n// It implements a waiting queue for contested locks and uses lease-based locking.\ntype LockManager struct {\n\tmu             sync.Mutex        // Protects the lockedPrefixes map and the condition variable\n\tlockedPrefixes map[string]string // Stores prefix -> leaseID for currently held locks\n\tcond           *sync.Cond        // Condition variable for clients to wait and be notified\n}\n\n// NewLockManager creates and returns a new LockManager instance.\nfunc NewLockManager() *LockManager {\n\tlm := &LockManager{\n\t\tlockedPrefixes: make(map[string]string),\n\t}\n\t// Initialize the condition variable with the mutex\n\tlm.cond = sync.NewCond(&lm.mu)\n\treturn lm\n}\n\n// Lock attempts to acquire a lock for the given prefix and leaseID.\n// If the lock is already held by another client, this function blocks until it becomes available.\n// If the lock is already held by the same leaseID, it returns immediately (idempotent).\nfunc (lm *LockManager) Lock(prefix string, leaseID string) {\n\tlm.mu.Lock() // Acquire the mutex to protect internal state\n\tdefer lm.mu.Unlock()\n\n\tfor {\n\t\t// Check if the requested prefix is currently locked by any client\n\t\tif heldLeaseID, ok := lm.lockedPrefixes[prefix]; !ok {\n\t\t\t// The lock is available; acquire it\n\t\t\tlm.lockedPrefixes[prefix] = leaseID\n\t\t\tlog.Printf(\"INFO: Lock acquired successfully: prefix='%s', leaseID='%s'\", prefix, leaseID)\n\t\t\treturn // Lock acquired, return\n\t\t} else if heldLeaseID == leaseID {\n\t\t\t// The lock is already held by this exact leaseID; it's an idempotent operation\n\t\t\tlog.Printf(\"WARN: Lock '%s' already held by leaseID '%s'. Idempotent acquisition confirmed.\", prefix, leaseID)\n\t\t\treturn // Already holding the lock, return\n\t\t} else {\n\t\t\t// The lock is held by a different leaseID; this client must wait\n\t\t\tlog.Printf(\"INFO: Lock '%s' held by '%s'. Client '%s' waiting...\", prefix, heldLeaseID, leaseID)\n\t\t\tlm.cond.Wait() // Release mutex, wait for a signal, then re-acquire mutex before returning\n\t\t}\n\t}\n}\n\n// Unlock releases a lock for the given prefix, if it's held by the provided leaseID.\n// It returns true if the lock was successfully released, false otherwise (e.g., not held by this leaseID\n// or the prefix was not locked).\nfunc (lm *LockManager) Unlock(prefix string, leaseID string) bool {\n\tlm.mu.Lock() // Acquire the mutex to protect internal state\n\tdefer lm.mu.Unlock()\n\n\t// Check if the prefix is locked and if the provided leaseID is the current holder\n\tif heldLeaseID, ok := lm.lockedPrefixes[prefix]; ok && heldLeaseID == leaseID {\n\t\t// The lock is held by the correct leaseID, release it\n\t\tdelete(lm.lockedPrefixes, prefix)\n\t\tlog.Printf(\"INFO: Lock released: prefix='%s', leaseID='%s'\", prefix, leaseID)\n\t\tlm.cond.Broadcast() // Notify all waiting goroutines that a lock *might* have become available\n\t\treturn true\n\t}\n\n\t// Lock was not held by this leaseID or not locked at all\n\tlog.Printf(\"WARN: Unlock failed: prefix='%s', leaseID='%s'. Either not locked or not held by this leaseID.\", prefix, leaseID)\n\treturn false\n}\n\nfunc main() {\n\t// Configure logging to include timestamps for better traceability\n\tlog.SetFlags(log.Ldate | log.Lmicroseconds | log.Lshortfile)\n\n\t// Create a new instance of the Distributed Lock Manager\n\tlm := NewLockManager()\n\tvar wg sync.WaitGroup // Used to wait for all goroutines to complete\n\n\tfmt.Println(\"--------------------------------------------------\")\n\tfmt.Println(\"Scenario 1: Basic Sequential Lock and Unlock\")\n\tfmt.Println(\"--------------------------------------------------\")\n\n\t// Client A acquires and then releases a lock\n\tclientA_lease1 := uuid.NewString() // Generate a unique lease ID for Client A\n\tprefix1 := \"resource-A\"\n\tlog.Printf(\"Client A (Lease %s) attempting to lock '%s'\", clientA_lease1, prefix1)\n\tlm.Lock(prefix1, clientA_lease1)\n\tfmt.Printf(\"Client A (Lease %s) has acquired lock on '%s'.\\n\", clientA_lease1, prefix1)\n\ttime.Sleep(100 * time.Millisecond) // Simulate Client A performing some work\n\tlm.Unlock(prefix1, clientA_lease1)\n\tfmt.Printf(\"Client A (Lease %s) has released lock on '%s'.\\n\", clientA_lease1, prefix1)\n\n\tfmt.Println(\"\\n--------------------------------------------------\")\n\tfmt.Println(\"Scenario 2: Concurrent Lock Acquisition with Waiting Queue\")\n\tfmt.Println(\"--------------------------------------------------\")\n\n\tprefix2 := \"resource-B\"\n\tprefix3 := \"resource-C\"\n\tclientA_lease2 := uuid.NewString() // Lease for Client A on resource-B\n\tclientB_lease2 := uuid.NewString() // Lease for Client B on resource-B\n\tclientC_lease3 := uuid.NewString() // Lease for Client C on resource-C\n\n\t// Client A: Acquires lock on 'resource-B', holds it, then releases it.\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Printf(\"Client A (Lease %s) attempting to lock '%s'\", clientA_lease2, prefix2)\n\t\tlm.Lock(prefix2, clientA_lease2)\n\t\tfmt.Printf(\"Client A (Lease %s) acquired lock on '%s'\\n\", clientA_lease2, prefix2)\n\t\ttime.Sleep(500 * time.Millisecond) // Simulate work for a duration\n\t\tlm.Unlock(prefix2, clientA_lease2)\n\t\tfmt.Printf(\"Client A (Lease %s) released lock on '%s'\\n\", clientA_lease2, prefix2)\n\t}()\n\n\t// Give Client A a moment to ensure it acquires the lock first\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Client B: Tries to acquire lock on 'resource-B'. Should wait until Client A releases it.\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Printf(\"Client B (Lease %s) attempting to lock '%s'\", clientB_lease2, prefix2)\n\t\tlm.Lock(prefix2, clientB_lease2)\n\t\tfmt.Printf(\"Client B (Lease %s) acquired lock on '%s' (was waiting)\\n\", clientB_lease2, prefix2)\n\t\ttime.Sleep(200 * time.Millisecond) // Simulate work\n\t\tlm.Unlock(prefix2, clientB_lease2)\n\t\tfmt.Printf(\"Client B (Lease %s) released lock on '%s'\\n\", clientB_lease2, prefix2)\n\t}()\n\n\t// Client C: Acquires lock on 'resource-C'. Should succeed immediately as it's a different prefix.\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Printf(\"Client C (Lease %s) attempting to lock '%s'\", clientC_lease3, prefix3)\n\t\tlm.Lock(prefix3, clientC_lease3)\n\t\tfmt.Printf(\"Client C (Lease %s) acquired lock on '%s' (immediately)\\n\", clientC_lease3, prefix3)\n\t\ttime.Sleep(300 * time.Millisecond) // Simulate work\n\t\tlm.Unlock(prefix3, clientC_lease3)\n\t\tfmt.Printf(\"Client C (Lease %s) released lock on '%s'\\n\", clientC_lease3, prefix3)\n\t}()\n\n\twg.Wait() // Wait for all goroutines in Scenario 2 to finish\n\tfmt.Println(\"All clients in Scenario 2 finished.\")\n\n\tfmt.Println(\"\\n--------------------------------------------------\")\n\tfmt.Println(\"Scenario 3: Prefix Overlap Edge Case\")\n\tfmt.Println(\"--------------------------------------------------\")\n\n\t// This scenario tests the requirement:\n\t// \"Handles the scenario where a client tries to acquire a lock on a prefix that is itself a prefix of existing keys in the system (e.g., acquiring lock on \"test\" when \"testa\" already exists as a key)\"\n\t// The problem states that the lock acquisition should complete successfully.\n\t// This implies that the existence of a *data key* 'testa' (not a locked prefix 'testa') should not prevent\n\t// locking the *lock prefix* 'test'. The lock manager treats 'test' and 'testa' as distinct lockable entities.\n\tfmt.Println(\"Simulating a conceptual data key 'testa' existing in the system.\")\n\tfmt.Println(\"Attempting to acquire locks on 'test' and 'testa' concurrently.\")\n\n\tprefixTest := \"test\"\n\tprefixTestA := \"testa\" // 'testa' is a key starting with 'test'\n\tclient1_leaseT := uuid.NewString()\n\tclient2_leaseTA := uuid.NewString()\n\n\t// Channels to signal completion of lock acquisitions for timeout checks\n\tdoneLockTest := make(chan struct{})\n\tdoneLockTestA := make(chan struct{})\n\n\t// Client 1: Attempts to acquire lock on \"test\"\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Printf(\"Client 1 (Lease %s) attempting to lock '%s'\", client1_leaseT, prefixTest)\n\t\tlm.Lock(prefixTest, client1_leaseT)\n\t\tfmt.Printf(\"Client 1 (Lease %s) acquired lock on '%s'\\n\", client1_leaseT, prefixTest)\n\t\tclose(doneLockTest) // Signal that 'test' lock was acquired\n\t\ttime.Sleep(600 * time.Millisecond) // Simulate holding the lock\n\t\tlm.Unlock(prefixTest, client1_leaseT)\n\t\tfmt.Printf(\"Client 1 (Lease %s) released lock on '%s'\\n\", client1_leaseT, prefixTest)\n\t}()\n\n\t// Client 2: Attempts to acquire lock on \"testa\"\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlog.Printf(\"Client 2 (Lease %s) attempting to lock '%s'\", client2_leaseTA, prefixTestA)\n\t\tlm.Lock(prefixTestA, client2_leaseTA)\n\t\tfmt.Printf(\"Client 2 (Lease %s) acquired lock on '%s'\\n\", client2_leaseTA, prefixTestA)\n\t\tclose(doneLockTestA) // Signal that 'testa' lock was acquired\n\t\ttime.Sleep(300 * time.Millisecond) // Simulate holding the lock\n\t\tlm.Unlock(prefixTestA, client2_leaseTA)\n\t\tfmt.Printf(\"Client 2 (Lease %s) released lock on '%s'\\n\", client2_leaseTA, prefixTestA)\n\t}()\n\n\t// Verify that lock acquisition for \"test\" completes within 5 seconds\n\tselect {\n\tcase <-doneLockTest:\n\t\tfmt.Println(\"Success: Lock acquisition for 'test' completed within timeout.\")\n\tcase <-time.After(5 * time.Second):\n\t\tfmt.Println(\"FAIL: Lock acquisition for 'test' timed out.\")\n\t}\n\n\t// Verify that lock acquisition for \"testa\" completes within 5 seconds\n\tselect {\n\tcase <-doneLockTestA:\n\t\tfmt.Println(\"Success: Lock acquisition for 'testa' completed within timeout.\")\n\tcase <-time.After(5 * time.Second):\n\t\tfmt.Println(\"FAIL: Lock acquisition for 'testa' timed out.\")\n\t}\n\n\twg.Wait() // Wait for all goroutines in Scenario 3 to finish\n\tfmt.Println(\"All clients in Scenario 3 finished.\")\n\tfmt.Println(\"--------------------------------------------------\")\n\tfmt.Println(\"All scenarios completed successfully.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}