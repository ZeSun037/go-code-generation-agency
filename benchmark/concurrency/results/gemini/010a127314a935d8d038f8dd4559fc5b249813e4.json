{
    "task": "010a127314a935d8d038f8dd4559fc5b249813e4.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"time\"\n)\n\n// ResourceUpdate represents a single update for a resource.\ntype ResourceUpdate struct {\n    Type  string\n    ID    string\n    Value float64\n}\n\n// ResourceMonitor manages resource updates and dynamic configuration.\ntype ResourceMonitor struct {\n    highPriorityQueue chan ResourceUpdate\n    lowPriorityQueue  chan ResourceUpdate\n    shutdownChan      chan struct{} // Signals workers to shut down\n    workerWG          sync.WaitGroup // Waits for workers to finish\n\n    // For dynamic configuration and worker pause/resume\n    mu             sync.RWMutex // Protects resourceTypes and globalUsage\n    resourceTypes  map[string]bool\n    globalUsage    map[string]map[string]float64 // usage[type][id] = value\n\n    // Worker coordination for reconfiguration.\n    // These channels are buffered to accommodate signals for all workers\n    // without Reconfigure() blocking if a worker is busy processing.\n    numWorkers    int // Total number of workers (HP + LP)\n    pauseReqCh    chan struct{} // Reconfigure sends N signals here to tell workers to pause\n    pausedAckCh   chan struct{} // Workers send N signals here to acknowledge pause\n    resumeReqCh   chan struct{} // Reconfigure sends N signals here to tell workers to resume\n}\n\nconst (\n    queueBufferSize        = 1000 // Buffer size for update queues\n    numHighPriorityWorkers = 5\n    numLowPriorityWorkers  = 5\n    totalWorkers           = numHighPriorityWorkers + numLowPriorityWorkers\n)\n\n// NewResourceMonitor creates and initializes a new ResourceMonitor.\nfunc NewResourceMonitor(initialResourceTypes []string) *ResourceMonitor {\n    m := &ResourceMonitor{\n        highPriorityQueue: make(chan ResourceUpdate, queueBufferSize),\n        lowPriorityQueue:  make(chan ResourceUpdate, queueBufferSize),\n        shutdownChan:      make(chan struct{}),\n        resourceTypes:     make(map[string]bool),\n        globalUsage:       make(map[string]map[string]float64),\n\n        numWorkers:    totalWorkers,\n        pauseReqCh:    make(chan struct{}, totalWorkers), // Buffered for N workers\n        pausedAckCh:   make(chan struct{}, totalWorkers), // Buffered for N workers\n        resumeReqCh:   make(chan struct{}, totalWorkers), // Buffered for N workers\n    }\n\n    m.mu.Lock()\n    for _, rt := range initialResourceTypes {\n        m.resourceTypes[rt] = true\n    }\n    m.mu.Unlock()\n\n    return m\n}\n\n// StartWorkers spawns the worker goroutines.\nfunc (m *ResourceMonitor) StartWorkers() {\n    for i := 0; i < numHighPriorityWorkers; i++ {\n        m.workerWG.Add(1)\n        go m.worker(i, m.highPriorityQueue, \"HighPriority\")\n    }\n    for i := 0; i < numLowPriorityWorkers; i++ {\n        m.workerWG.Add(1)\n        go m.worker(i+numHighPriorityWorkers, m.lowPriorityQueue, \"LowPriority\")\n    }\n    log.Printf(\"Started %d high-priority and %d low-priority workers.\", numHighPriorityWorkers, numLowPriorityWorkers)\n}\n\n// worker function processes updates from its assigned queue.\nfunc (m *ResourceMonitor) worker(id int, q <-chan ResourceUpdate, workerType string) {\n    defer m.workerWG.Done()\n    log.Printf(\"Worker %d (%s) started.\", id, workerType)\n\n    for {\n        select {\n        case <-m.shutdownChan:\n            log.Printf(\"Worker %d (%s) shutting down.\", id, workerType)\n            return\n\n        case <-m.pauseReqCh: // Received a pause request specific to this worker\n            log.Printf(\"Worker %d (%s) pausing...\", id, workerType)\n            m.pausedAckCh <- struct{}{} // Acknowledge pause\n            <-m.resumeReqCh             // Wait for specific resume request\n            log.Printf(\"Worker %d (%s) resuming.\", id, workerType)\n            // Continue the loop to immediately try to process updates or check signals again.\n\n        case update, ok := <-q:\n            if !ok { // Queue closed, worker should shut down\n                log.Printf(\"Worker %d (%s) queue closed, shutting down.\", id, workerType)\n                return\n            }\n            m.processUpdate(update)\n        }\n    }\n}\n\n// processUpdate handles a single resource update, checking against current configuration.\nfunc (m *ResourceMonitor) processUpdate(update ResourceUpdate) {\n    m.mu.RLock() // Use RLock for reading resourceTypes\n    isMonitored := m.resourceTypes[update.Type]\n    m.mu.RUnlock()\n\n    if !isMonitored {\n        // log.Printf(\"Worker received unmonitored type: %s, ID: %s\", update.Type, update.ID)\n        return // Ignore updates for unmonitored types\n    }\n\n    // Now, write to globalUsage. This requires a write lock for globalUsage.\n    // The RWMutex m.mu protects both resourceTypes and globalUsage.\n    // A single RWMutex for both is appropriate here as they are related.\n    m.mu.Lock() // Acquire write lock for globalUsage\n    if _, ok := m.globalUsage[update.Type]; !ok {\n        m.globalUsage[update.Type] = make(map[string]float64)\n    }\n    m.globalUsage[update.Type][update.ID] = update.Value\n    m.mu.Unlock()\n\n    // log.Printf(\"Processed: Type=%s, ID=%s, Value=%.2f\", update.Type, update.ID, update.Value)\n}\n\n// SubmitHighPriorityUpdate sends an update to the high priority queue.\nfunc (m *ResourceMonitor) SubmitHighPriorityUpdate(update ResourceUpdate) {\n    select {\n    case m.highPriorityQueue <- update:\n    default:\n        log.Printf(\"High priority queue is full, dropping update for %s:%s\", update.Type, update.ID)\n    }\n}\n\n// SubmitLowPriorityUpdate sends an update to the low priority queue.\nfunc (m *ResourceMonitor) SubmitLowPriorityUpdate(update ResourceUpdate) {\n    select {\n    case m.lowPriorityQueue <- update:\n    default:\n        log.Printf(\"Low priority queue is full, dropping update for %s:%s\", update.Type, update.ID)\n    }\n}\n\n// Reconfigure dynamically updates the list of monitored resource types.\n// It pauses all workers, updates the configuration, and then resumes them.\nfunc (m *ResourceMonitor) Reconfigure(newResourceTypes []string) {\n    log.Println(\"Initiating reconfiguration...\")\n\n    // 1. Signal all workers to pause by sending N signals to their respective pause channels.\n    // Using a select here makes it robust to shutdown signals potentially interfering.\n    for i := 0; i < m.numWorkers; i++ {\n        select {\n        case <-m.shutdownChan:\n            log.Println(\"Reconfigure aborted: Shutdown initiated during worker pause signaling.\")\n            // Drain any pending acknowledgements from workers that might have paused before shutdown.\n            for j := 0; j < i; j++ {\n                select {\n                case <-m.pausedAckCh:\n                case <-time.After(50 * time.Millisecond): // Don't block forever\n                    break\n                }\n            }\n            return\n        case m.pauseReqCh <- struct{}{}:\n        }\n    }\n\n    // 2. Wait for all workers to acknowledge pause by receiving N signals.\n    for i := 0; i < m.numWorkers; i++ {\n        select {\n        case <-m.shutdownChan:\n            log.Println(\"Reconfigure aborted: Shutdown initiated while waiting for workers to pause.\")\n            // At this point, some workers might be paused, some might still be processing.\n            // This is a complex recovery scenario. For this exercise, we assume\n            // Reconfigure completes without shutdown interruption during this phase.\n            return\n        case <-m.pausedAckCh:\n        }\n    }\n    log.Printf(\"All %d workers paused. Updating configuration...\", m.numWorkers)\n\n    // 3. Update configuration (critical section)\n    m.mu.Lock() // Acquire write lock for resourceTypes\n    m.resourceTypes = make(map[string]bool) // Clear and rebuild\n    for _, rt := range newResourceTypes {\n        m.resourceTypes[rt] = true\n    }\n    m.mu.Unlock()\n    log.Printf(\"Configuration updated. New types: %v\", newResourceTypes)\n\n    // 4. Signal all workers to resume by sending N signals.\n    for i := 0; i < m.numWorkers; i++ {\n        select {\n        case <-m.shutdownChan:\n            log.Println(\"Reconfigure aborted: Shutdown initiated during worker resume signaling.\")\n            // Similar to above, critical state. For robust production, ensure atomic Reconfigure or graceful handling.\n            return\n        case m.resumeReqCh <- struct{}{}:\n        }\n    }\n    log.Printf(\"All %d workers resumed.\", m.numWorkers)\n}\n\n// Shutdown gracefully stops all workers and cleans up.\nfunc (m *ResourceMonitor) Shutdown() {\n    log.Println(\"Initiating system shutdown...\")\n\n    // 1. Signal all workers to shut down by closing the shared channel.\n    close(m.shutdownChan)\n\n    // 2. Close input queues.\n    // This signals to workers reading from these channels that no more updates will come.\n    // If external producers are still trying to send, they might panic if not handling closed channels.\n    // For this example, producers (simulateUpdates) are stopped before shutdown.\n    close(m.highPriorityQueue)\n    close(m.lowPriorityQueue)\n\n    // 3. Wait for all workers to finish\n    m.workerWG.Wait()\n    log.Println(\"All workers shut down.\")\n\n    log.Println(\"Resource Monitor system shut down successfully.\")\n}\n\n// GetCurrentUsage provides a snapshot of the current resource usage.\nfunc (m *ResourceMonitor) GetCurrentUsage() map[string]map[string]float64 {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n\n    // Deep copy to prevent external modification of internal state\n    snapshot := make(map[string]map[string]float64)\n    for resType, ids := range m.globalUsage {\n        snapshot[resType] = make(map[string]float64)\n        for id, value := range ids {\n            snapshot[resType][id] = value\n        }\n    }\n    return snapshot\n}\n\n// printUsage periodically prints the current usage.\nfunc printUsage(monitor *ResourceMonitor, stop <-chan struct{}) {\n    ticker := time.NewTicker(3 * time.Second)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-stop:\n            fmt.Println(\"\\nUsage printer stopped.\")\n            return\n        case <-ticker.C:\n            usage := monitor.GetCurrentUsage()\n            if len(usage) == 0 {\n                fmt.Println(\"\\n--- Current Usage (Empty) ---\")\n                continue\n            }\n            fmt.Println(\"\\n--- Current Usage ---\")\n            for resType, ids := range usage {\n                fmt.Printf(\"  %s:\\n\", resType)\n                for id, value := range ids {\n                    fmt.Printf(\"    %s: %.2f\\n\", id, value)\n                }\n            }\n            fmt.Println(\"--------------------\")\n        }\n    }\n}\n\n// simulateUpdates sends updates to the monitor at a specified frequency.\nfunc simulateUpdates(monitor *ResourceMonitor, stop <-chan struct{}, name string, updateFreq time.Duration) {\n    defer fmt.Printf(\"Update simulator %s stopped.\\n\", name)\n    // A wider range of types to demonstrate filtering by Reconfigure\n    resourceTypes := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\", \"GPU\", \"Storage\", \"Bandwidth\", \"Processes\"}\n    resourceIDs := []string{\"server-01\", \"server-02\", \"desktop-A\", \"laptop-B\", \"router-X\", \"container-1\", \"pod-alpha\"}\n    r := 0.0 // Dummy value for demonstration\n\n    ticker := time.NewTicker(updateFreq)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-stop:\n            return\n        case <-ticker.C:\n            r += 0.1\n            if r > 100 {\n                r = 0.1\n            }\n\n            for _, rt := range resourceTypes {\n                for _, id := range resourceIDs {\n                    update := ResourceUpdate{\n                        Type:  rt,\n                        ID:    id,\n                        Value: r + float64(len(rt)+len(id)), // Just some varying value\n                    }\n                    if len(rt)%2 == 0 { // Example logic for priority (arbitrary)\n                        monitor.SubmitHighPriorityUpdate(update)\n                    } else {\n                        monitor.SubmitLowPriorityUpdate(update)\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunc main() {\n    log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)\n\n    initialMonitoredTypes := []string{\"CPU\", \"Memory\"}\n    monitor := NewResourceMonitor(initialMonitoredTypes)\n    monitor.StartWorkers()\n\n    // Start background goroutine to print usage\n    stopUsagePrinter := make(chan struct{})\n    go printUsage(monitor, stopUsagePrinter)\n\n    // Start background goroutine to simulate updates\n    stopUpdateSimulator := make(chan struct{})\n    go simulateUpdates(monitor, stopUpdateSimulator, \"General\", 50*time.Millisecond)\n\n    fmt.Println(\"System started with initial monitored types:\", initialMonitoredTypes)\n    fmt.Println(\"Workers are processing updates. Waiting 10 seconds before reconfiguration...\")\n    time.Sleep(10 * time.Second)\n\n    // Reconfiguration 1: Add Disk, Network; remove Memory\n    newConfig1 := []string{\"CPU\", \"Disk\", \"Network\"}\n    monitor.Reconfigure(newConfig1)\n    fmt.Println(\"\\n--- Reconfiguration 1 Applied ---\")\n    fmt.Println(\"New monitored types:\", newConfig1)\n    fmt.Println(\"Waiting 10 seconds after first reconfiguration...\")\n    time.Sleep(10 * time.Second)\n\n    // Reconfiguration 2: Add GPU, Storage; remove CPU, Disk\n    newConfig2 := []string{\"Network\", \"GPU\", \"Storage\"}\n    monitor.Reconfigure(newConfig2)\n    fmt.Println(\"\\n--- Reconfiguration 2 Applied ---\")\n    fmt.Println(\"New monitored types:\", newConfig2)\n    fmt.Println(\"Waiting 10 seconds after second reconfiguration...\")\n    time.Sleep(10 * time.Second)\n\n    // Shutdown sequence\n    fmt.Println(\"\\nInitiating shutdown in 5 seconds...\")\n    time.Sleep(5 * time.Second)\n    close(stopUpdateSimulator) // Stop update producers first\n    time.Sleep(1 * time.Second) // Give queues a moment to drain a bit\n    monitor.Shutdown()         // Then shut down the monitor\n    close(stopUsagePrinter)    // Stop the usage printer\n\n    fmt.Println(\"Main program exiting.\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "staticcheck",
                    "error": "main.go:168:21: ineffective break statement. Did you mean to break out of the outer loop? (SA4011)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"time\"\n)\n\n// ResourceUpdate represents a single update for a resource.\ntype ResourceUpdate struct {\n    Type  string\n    ID    string\n    Value float64\n}\n\n// ResourceMonitor manages resource updates and dynamic configuration.\ntype ResourceMonitor struct {\n    highPriorityQueue chan ResourceUpdate\n    lowPriorityQueue  chan ResourceUpdate\n    shutdownChan      chan struct{} // Signals workers to shut down\n    workerWG          sync.WaitGroup // Waits for workers to finish\n\n    // For dynamic configuration and worker pause/resume\n    mu             sync.RWMutex // Protects resourceTypes and globalUsage\n    resourceTypes  map[string]bool\n    globalUsage    map[string]map[string]float64 // usage[type][id] = value\n\n    // Worker coordination for reconfiguration.\n    // These channels are buffered to accommodate signals for all workers\n    // without Reconfigure() blocking if a worker is busy processing.\n    numWorkers    int // Total number of workers (HP + LP)\n    pauseReqCh    chan struct{} // Reconfigure sends N signals here to tell workers to pause\n    pausedAckCh   chan struct{} // Workers send N signals here to acknowledge pause\n    resumeReqCh   chan struct{} // Reconfigure sends N signals here to tell workers to resume\n}\n\nconst (\n    queueBufferSize        = 1000 // Buffer size for update queues\n    numHighPriorityWorkers = 5\n    numLowPriorityWorkers  = 5\n    totalWorkers           = numHighPriorityWorkers + numLowPriorityWorkers\n)\n\n// NewResourceMonitor creates and initializes a new ResourceMonitor.\nfunc NewResourceMonitor(initialResourceTypes []string) *ResourceMonitor {\n    m := &ResourceMonitor{\n        highPriorityQueue: make(chan ResourceUpdate, queueBufferSize),\n        lowPriorityQueue:  make(chan ResourceUpdate, queueBufferSize),\n        shutdownChan:      make(chan struct{}),\n        resourceTypes:     make(map[string]bool),\n        globalUsage:       make(map[string]map[string]float64),\n\n        numWorkers:    totalWorkers,\n        pauseReqCh:    make(chan struct{}, totalWorkers), // Buffered for N workers\n        pausedAckCh:   make(chan struct{}, totalWorkers), // Buffered for N workers\n        resumeReqCh:   make(chan struct{}, totalWorkers), // Buffered for N workers\n    }\n\n    m.mu.Lock()\n    for _, rt := range initialResourceTypes {\n        m.resourceTypes[rt] = true\n    }\n    m.mu.Unlock()\n\n    return m\n}\n\n// StartWorkers spawns the worker goroutines.\nfunc (m *ResourceMonitor) StartWorkers() {\n    for i := 0; i < numHighPriorityWorkers; i++ {\n        m.workerWG.Add(1)\n        go m.worker(i, m.highPriorityQueue, \"HighPriority\")\n    }\n    for i := 0; i < numLowPriorityWorkers; i++ {\n        m.workerWG.Add(1)\n        go m.worker(i+numHighPriorityWorkers, m.lowPriorityQueue, \"LowPriority\")\n    }\n    log.Printf(\"Started %d high-priority and %d low-priority workers.\", numHighPriorityWorkers, numLowPriorityWorkers)\n}\n\n// worker function processes updates from its assigned queue.\nfunc (m *ResourceMonitor) worker(id int, q <-chan ResourceUpdate, workerType string) {\n    defer m.workerWG.Done()\n    log.Printf(\"Worker %d (%s) started.\", id, workerType)\n\n    for {\n        select {\n        case <-m.shutdownChan:\n            log.Printf(\"Worker %d (%s) shutting down.\", id, workerType)\n            return\n\n        case <-m.pauseReqCh: // Received a pause request specific to this worker\n            log.Printf(\"Worker %d (%s) pausing...\", id, workerType)\n            m.pausedAckCh <- struct{}{} // Acknowledge pause\n            <-m.resumeReqCh             // Wait for specific resume request\n            log.Printf(\"Worker %d (%s) resuming.\", id, workerType)\n            // Continue the loop to immediately try to process updates or check signals again.\n\n        case update, ok := <-q:\n            if !ok { // Queue closed, worker should shut down\n                log.Printf(\"Worker %d (%s) queue closed, shutting down.\", id, workerType)\n                return\n            }\n            m.processUpdate(update)\n        }\n    }\n}\n\n// processUpdate handles a single resource update, checking against current configuration.\nfunc (m *ResourceMonitor) processUpdate(update ResourceUpdate) {\n    m.mu.RLock() // Use RLock for reading resourceTypes\n    isMonitored := m.resourceTypes[update.Type]\n    m.mu.RUnlock()\n\n    if !isMonitored {\n        // log.Printf(\"Worker received unmonitored type: %s, ID: %s\", update.Type, update.ID)\n        return // Ignore updates for unmonitored types\n    }\n\n    // Now, write to globalUsage. This requires a write lock for globalUsage.\n    // The RWMutex m.mu protects both resourceTypes and globalUsage.\n    // A single RWMutex for both is appropriate here as they are related.\n    m.mu.Lock() // Acquire write lock for globalUsage\n    if _, ok := m.globalUsage[update.Type]; !ok {\n        m.globalUsage[update.Type] = make(map[string]float64)\n    }\n    m.globalUsage[update.Type][update.ID] = update.Value\n    m.mu.Unlock()\n\n    // log.Printf(\"Processed: Type=%s, ID=%s, Value=%.2f\", update.Type, update.ID, update.Value)\n}\n\n// SubmitHighPriorityUpdate sends an update to the high priority queue.\nfunc (m *ResourceMonitor) SubmitHighPriorityUpdate(update ResourceUpdate) {\n    select {\n    case m.highPriorityQueue <- update:\n    default:\n        log.Printf(\"High priority queue is full, dropping update for %s:%s\", update.Type, update.ID)\n    }\n}\n\n// SubmitLowPriorityUpdate sends an update to the low priority queue.\nfunc (m *ResourceMonitor) SubmitLowPriorityUpdate(update ResourceUpdate) {\n    select {\n    case m.lowPriorityQueue <- update:\n    default:\n        log.Printf(\"Low priority queue is full, dropping update for %s:%s\", update.Type, update.ID)\n    }\n}\n\n// Reconfigure dynamically updates the list of monitored resource types.\n// It pauses all workers, updates the configuration, and then resumes them.\nfunc (m *ResourceMonitor) Reconfigure(newResourceTypes []string) {\n    log.Println(\"Initiating reconfiguration...\")\n\n    // 1. Signal all workers to pause by sending N signals to their respective pause channels.\n    // Using a select here makes it robust to shutdown signals potentially interfering.\n    for i := 0; i < m.numWorkers; i++ {\n        select {\n        case <-m.shutdownChan:\n            log.Println(\"Reconfigure aborted: Shutdown initiated during worker pause signaling.\")\n            // Drain any pending acknowledgements from workers that might have paused before shutdown.\n            drainAcks: // Label for the inner draining loop\n            for j := 0; j < i; j++ {\n                select {\n                case <-m.pausedAckCh:\n                case <-time.After(50 * time.Millisecond): // Don't block forever\n                    // If one ack times out, it's likely others might too, or the system is in an inconsistent state.\n                    // It's probably best to stop attempting to drain and just return.\n                    break drainAcks // Break out of the 'for j' loop\n                }\n            }\n            return\n        case m.pauseReqCh <- struct{}{}:\n        }\n    }\n\n    // 2. Wait for all workers to acknowledge pause by receiving N signals.\n    for i := 0; i < m.numWorkers; i++ {\n        select {\n        case <-m.shutdownChan:\n            log.Println(\"Reconfigure aborted: Shutdown initiated while waiting for workers to pause.\")\n            // At this point, some workers might be paused, some might still be processing.\n            // This is a complex recovery scenario. For this exercise, we assume\n            // Reconfigure completes without shutdown interruption during this phase.\n            return\n        case <-m.pausedAckCh:\n        }\n    }\n    log.Printf(\"All %d workers paused. Updating configuration...\", m.numWorkers)\n\n    // 3. Update configuration (critical section)\n    m.mu.Lock() // Acquire write lock for resourceTypes\n    m.resourceTypes = make(map[string]bool) // Clear and rebuild\n    for _, rt := range newResourceTypes {\n        m.resourceTypes[rt] = true\n    }\n    m.mu.Unlock()\n    log.Printf(\"Configuration updated. New types: %v\", newResourceTypes)\n\n    // 4. Signal all workers to resume by sending N signals.\n    for i := 0; i < m.numWorkers; i++ {\n        select {\n        case <-m.shutdownChan:\n            log.Println(\"Reconfigure aborted: Shutdown initiated during worker resume signaling.\")\n            // Similar to above, critical state. For robust production, ensure atomic Reconfigure or graceful handling.\n            return\n        case m.resumeReqCh <- struct{}{}:\n        }\n    }\n    log.Printf(\"All %d workers resumed.\", m.numWorkers)\n}\n\n// Shutdown gracefully stops all workers and cleans up.\nfunc (m *ResourceMonitor) Shutdown() {\n    log.Println(\"Initiating system shutdown...\")\n\n    // 1. Signal all workers to shut down by closing the shared channel.\n    close(m.shutdownChan)\n\n    // 2. Close input queues.\n    // This signals to workers reading from these channels that no more updates will come.\n    // If external producers are still trying to send, they might panic if not handling closed channels.\n    // For this example, producers (simulateUpdates) are stopped before shutdown.\n    close(m.highPriorityQueue)\n    close(m.lowPriorityQueue)\n\n    // 3. Wait for all workers to finish\n    m.workerWG.Wait()\n    log.Println(\"All workers shut down.\")\n\n    log.Println(\"Resource Monitor system shut down successfully.\")\n}\n\n// GetCurrentUsage provides a snapshot of the current resource usage.\nfunc (m *ResourceMonitor) GetCurrentUsage() map[string]map[string]float64 {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n\n    // Deep copy to prevent external modification of internal state\n    snapshot := make(map[string]map[string]float64)\n    for resType, ids := range m.globalUsage {\n        snapshot[resType] = make(map[string]float64)\n        for id, value := range ids {\n            snapshot[resType][id] = value\n        }\n    }\n    return snapshot\n}\n\n// printUsage periodically prints the current usage.\nfunc printUsage(monitor *ResourceMonitor, stop <-chan struct{}) {\n    ticker := time.NewTicker(3 * time.Second)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-stop:\n            fmt.Println(\"\\nUsage printer stopped.\")\n            return\n        case <-ticker.C:\n            usage := monitor.GetCurrentUsage()\n            if len(usage) == 0 {\n                fmt.Println(\"\\n--- Current Usage (Empty) ---\")\n                continue\n            }\n            fmt.Println(\"\\n--- Current Usage ---\")\n            for resType, ids := range usage {\n                fmt.Printf(\"  %s:\\n\", resType)\n                for id, value := range ids {\n                    fmt.Printf(\"    %s: %.2f\\n\", id, value)\n                }\n            }\n            fmt.Println(\"--------------------\")\n        }\n    }\n}\n\n// simulateUpdates sends updates to the monitor at a specified frequency.\nfunc simulateUpdates(monitor *ResourceMonitor, stop <-chan struct{}, name string, updateFreq time.Duration) {\n    defer fmt.Printf(\"Update simulator %s stopped.\\n\", name)\n    // A wider range of types to demonstrate filtering by Reconfigure\n    resourceTypes := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\", \"GPU\", \"Storage\", \"Bandwidth\", \"Processes\"}\n    resourceIDs := []string{\"server-01\", \"server-02\", \"desktop-A\", \"laptop-B\", \"router-X\", \"container-1\", \"pod-alpha\"}\n    r := 0.0 // Dummy value for demonstration\n\n    ticker := time.NewTicker(updateFreq)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-stop:\n            return\n        case <-ticker.C:\n            r += 0.1\n            if r > 100 {\n                r = 0.1\n            }\n\n            for _, rt := range resourceTypes {\n                for _, id := range resourceIDs {\n                    update := ResourceUpdate{\n                        Type:  rt,\n                        ID:    id,\n                        Value: r + float64(len(rt)+len(id)), // Just some varying value\n                    }\n                    if len(rt)%2 == 0 { // Example logic for priority (arbitrary)\n                        monitor.SubmitHighPriorityUpdate(update)\n                    } else {\n                        monitor.SubmitLowPriorityUpdate(update)\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunc main() {\n    log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)\n\n    initialMonitoredTypes := []string{\"CPU\", \"Memory\"}\n    monitor := NewResourceMonitor(initialMonitoredTypes)\n    monitor.StartWorkers()\n\n    // Start background goroutine to print usage\n    stopUsagePrinter := make(chan struct{})\n    go printUsage(monitor, stopUsagePrinter)\n\n    // Start background goroutine to simulate updates\n    stopUpdateSimulator := make(chan struct{})\n    go simulateUpdates(monitor, stopUpdateSimulator, \"General\", 50*time.Millisecond)\n\n    fmt.Println(\"System started with initial monitored types:\", initialMonitoredTypes)\n    fmt.Println(\"Workers are processing updates. Waiting 10 seconds before reconfiguration...\")\n    time.Sleep(10 * time.Second)\n\n    // Reconfiguration 1: Add Disk, Network; remove Memory\n    newConfig1 := []string{\"CPU\", \"Disk\", \"Network\"}\n    monitor.Reconfigure(newConfig1)\n    fmt.Println(\"\\n--- Reconfiguration 1 Applied ---\")\n    fmt.Println(\"New monitored types:\", newConfig1)\n    fmt.Println(\"Waiting 10 seconds after first reconfiguration...\")\n    time.Sleep(10 * time.Second)\n\n    // Reconfiguration 2: Add GPU, Storage; remove CPU, Disk\n    newConfig2 := []string{\"Network\", \"GPU\", \"Storage\"}\n    monitor.Reconfigure(newConfig2)\n    fmt.Println(\"\\n--- Reconfiguration 2 Applied ---\")\n    fmt.Println(\"New monitored types:\", newConfig2)\n    fmt.Println(\"Waiting 10 seconds after second reconfiguration...\")\n    time.Sleep(10 * time.Second)\n\n    // Shutdown sequence\n    fmt.Println(\"\\nInitiating shutdown in 5 seconds...\")\n    time.Sleep(5 * time.Second)\n    close(stopUpdateSimulator) // Stop update producers first\n    time.Sleep(1 * time.Second) // Give queues a moment to drain a bit\n    monitor.Shutdown()         // Then shut down the monitor\n    close(stopUsagePrinter)    // Stop the usage printer\n\n    fmt.Println(\"Main program exiting.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}