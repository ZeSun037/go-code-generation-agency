{
    "task": "91ff6f30b50a14158ec10cdd24836d775a336f52.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Event represents an event that can be broadcast.\ntype Event struct {\n\tID   int\n\tData string\n}\n\n// Receiver represents an entity that can receive and process events.\ntype Receiver struct {\n\tid       int\n\tevents   chan Event\n\twg       sync.WaitGroup // Waits for the event processing goroutine to finish.\n\tisClosed atomic.Bool    // Ensures the events channel is closed only once.\n}\n\n// NewReceiver creates a new Receiver with a unique ID and a buffered channel.\nfunc NewReceiver(id int) *Receiver {\n\treturn &Receiver{\n\t\tid:     id,\n\t\tevents: make(chan Event, 10), // Buffered channel to prevent blocking the broadcaster immediately.\n\t}\n}\n\n// Start begins the event processing loop for the receiver.\n// This method should be run in a separate goroutine.\nfunc (r *Receiver) Start() {\n\tr.wg.Add(1)\n\tdefer r.wg.Done()\n\n\tfor event := range r.events {\n\t\t// Simulate event processing time.\n\t\ttime.Sleep(time.Millisecond * time.Duration(rand.Intn(50)+10))\n\t\tfmt.Printf(\"Receiver %d processed event %d\\n\", r.id, event.ID)\n\t}\n}\n\n// Close gracefully stops the receiver by closing its event channel and waiting\n// for its processing goroutine to finish.\nfunc (r *Receiver) Close() {\n\tif r.isClosed.CompareAndSwap(false, true) {\n\t\tclose(r.events) // Signal the Start() goroutine to exit the range loop.\n\t\tr.wg.Wait()     // Wait for the Start() goroutine to complete all buffered events and terminate.\n\t}\n}\n\n// Broadcaster manages a collection of receivers and distributes events to them.\ntype Broadcaster struct {\n\treceivers map[*Receiver]struct{}\n\tmu        sync.RWMutex // Protects the receivers map.\n\n\t// Metrics\n\teventsDistributed atomic.Uint64 // Total count of events sent to receivers (excluding the original).\n}\n\n// NewBroadcaster creates and initializes a new Broadcaster instance.\nfunc NewBroadcaster() *Broadcaster {\n\treturn &Broadcaster{\n\t\treceivers: make(map[*Receiver]struct{}),\n\t}\n}\n\n// Register adds a receiver to the broadcaster's collection.\n// The receiver will start receiving events after registration.\nfunc (b *Broadcaster) Register(r *Receiver) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tif _, exists := b.receivers[r]; !exists {\n\t\tb.receivers[r] = struct{}{}\n\t\tfmt.Printf(\"Broadcaster: Receiver %d registered. Active: %d\\n\", r.id, len(b.receivers))\n\t}\n}\n\n// Unregister removes a receiver from the broadcaster's collection.\n// The receiver will no longer receive events and its resources will be cleaned up.\nfunc (b *Broadcaster) Unregister(r *Receiver) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tif _, exists := b.receivers[r]; exists {\n\t\tdelete(b.receivers, r)\n\t\tr.Close() // Close receiver's channel and wait for its goroutine to stop.\n\t\tfmt.Printf(\"Broadcaster: Receiver %d unregistered. Active: %d\\n\", r.id, len(b.receivers))\n\t}\n}\n\n// Broadcast sends an event to all currently registered receivers.\n// This operation is non-blocking for the broadcaster itself due to `select/default`\n// and buffered channels on receivers.\nfunc (b *Broadcaster) Broadcast(event Event) {\n\tb.mu.RLock() // Use RLock to allow concurrent reads/broadcasts.\n\tdefer b.mu.RUnlock()\n\n\tnumReceivers := len(b.receivers)\n\tif numReceivers > 0 {\n\t\t// Metrics: EventsDistributed: num_receivers - 1 (as per requirements).\n\t\t// If 3 receivers get an event, it counts as 2 additional distributions.\n\t\tb.eventsDistributed.Add(uint64(numReceivers - 1))\n\t}\n\n\tfor r := range b.receivers {\n\t\t// Attempt to send the event without blocking.\n\t\tselect {\n\t\tcase r.events <- event:\n\t\t\t// Event sent successfully.\n\t\tdefault:\n\t\t\t// Receiver's channel is full, event is dropped.\n\t\t\t// In a production system, this might log an error, use a retry mechanism, or a larger buffer.\n\t\t\tfmt.Printf(\"Broadcaster: Dropped event %d for receiver %d (channel full)\\n\", event.ID, r.id)\n\t\t}\n\t}\n}\n\n// GetMetrics returns the current metrics for the broadcaster.\nfunc (b *Broadcaster) GetMetrics() (eventsDistributed uint64, activeReceivers int) {\n\tb.mu.RLock()\n\tdefer b.mu.RUnlock()\n\treturn b.eventsDistributed.Load(), len(b.receivers)\n}\n\n// Close shuts down the broadcaster and all its registered receivers,\n// releasing all associated resources.\nfunc (b *Broadcaster) Close() {\n\tb.mu.Lock() // Acquire write lock to prevent any further operations during shutdown.\n\tdefer b.mu.Unlock()\n\n\tfmt.Println(\"Broadcaster: Closing...\")\n\tfor r := range b.receivers {\n\t\tr.Close() // Close each receiver's channel and wait for its goroutine to finish.\n\t}\n\t// Clear the map after all receivers are closed.\n\tb.receivers = make(map[*Receiver]struct{})\n\tfmt.Println(\"Broadcaster: All receivers closed. System shut down.\")\n}\n\nfunc main() {\n\t// Seed the random number generator for dynamic behavior.\n\trand.Seed(time.Now().UnixNano())\n\n\tbroadcaster := NewBroadcaster()\n\tvar mainWg sync.WaitGroup // To wait for all main goroutines (broadcaster, dynamic manager) to finish.\n\n\tconst initialReceivers = 5\n\tconst totalReceiversPool = 10 // A pool of potential receivers, some might be inactive initially.\n\tallReceivers := make([]*Receiver, totalReceiversPool)\n\tactiveReceiverIDs := make(map[int]struct{}) // Tracks IDs of receivers currently registered with the broadcaster.\n\n\t// Initialize the pool of all potential receivers.\n\tfor i := 0; i < totalReceiversPool; i++ {\n\t\tallReceivers[i] = NewReceiver(i)\n\t}\n\n\t// Register initial receivers and start their processing goroutines.\n\tfmt.Println(\"--- Initializing system ---\")\n\tfor i := 0; i < initialReceivers; i++ {\n\t\tbroadcaster.Register(allReceivers[i])\n\t\tgo allReceivers[i].Start() // Start the receiver's event processing loop.\n\t\tactiveReceiverIDs[allReceivers[i].id] = struct{}{}\n\t}\n\n\t// Goroutine for continuously broadcasting events.\n\tmainWg.Add(1)\n\tgo func() {\n\t\tdefer mainWg.Done()\n\t\tconst numEvents = 20 // Broadcast a total of 20 events.\n\t\tfmt.Printf(\"\\n--- Starting event broadcast of %d events ---\\n\", numEvents)\n\t\tfor i := 0; i < numEvents; i++ {\n\t\t\tevent := Event{ID: i, Data: fmt.Sprintf(\"event-%d\", i)}\n\t\t\tbroadcaster.Broadcast(event)\n\t\t\ttime.Sleep(time.Millisecond * time.Duration(rand.Intn(100)+50)) // Simulate event generation delay.\n\t\t}\n\t\tfmt.Println(\"--- Finished event broadcast ---\")\n\t}()\n\n\t// Goroutine for dynamic receiver management (adding and removing receivers).\n\tmainWg.Add(1)\n\tgo func() {\n\t\tdefer mainWg.Done()\n\t\tfmt.Println(\"\\n--- Starting dynamic receiver management ---\")\n\t\tticker := time.NewTicker(time.Millisecond * 500) // Perform an action every 500ms.\n\t\tdefer ticker.Stop()\n\t\t\n\t\tmaxDynamicOperations := 15 // Limit the number of dynamic ops for a finite test.\n\t\toperationCount := 0\n\n\t\tfor range ticker.C {\n\t\t\tif operationCount >= maxDynamicOperations {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\toperationCount++\n\n\t\t\t// Decide whether to add or remove a receiver.\n\t\t\tif rand.Float64() < 0.5 { // 50% chance to add.\n\t\t\t\t// Find an inactive receiver to add.\n\t\t\t\tfoundInactive := false\n\t\t\t\tfor _, r := range allReceivers {\n\t\t\t\t\tif _, isActive := activeReceiverIDs[r.id]; !isActive {\n\t\t\t\t\t\tbroadcaster.Register(r)\n\t\t\t\t\t\tgo r.Start()\n\t\t\t\t\t\tactiveReceiverIDs[r.id] = struct{}{}\n\t\t\t\t\t\tfoundInactive = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !foundInactive {\n\t\t\t\t\t// fmt.Println(\"Dynamic management: No inactive receivers available to add.\")\n\t\t\t\t}\n\t\t\t} else { // 50% chance to remove.\n\t\t\t\t// Find an active receiver to remove.\n\t\t\t\tif len(activeReceiverIDs) > 0 {\n\t\t\t\t\tvar receiverToRemove *Receiver\n\t\t\t\t\t// Collect active receiver IDs to pick a random one.\n\t\t\t\t\tactiveKeys := make([]int, 0, len(activeReceiverIDs))\n\t\t\t\t\tfor k := range activeReceiverIDs {\n\t\t\t\t\t\tactiveKeys = append(activeKeys, k)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif len(activeKeys) > 0 {\n\t\t\t\t\t\trandomID := activeKeys[rand.Intn(len(activeKeys))]\n\t\t\t\t\t\treceiverToRemove = allReceivers[randomID] // Assuming receiver ID maps directly to slice index.\n\t\t\t\t\t\t\n\t\t\t\t\t\tbroadcaster.Unregister(receiverToRemove)\n\t\t\t\t\t\tdelete(activeReceiverIDs, receiverToRemove.id)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// fmt.Println(\"Dynamic management: No active receivers to remove.\")\n\t\t\t\t\t// If no receivers are active, try to add one back to keep the system running.\n\t\t\t\t\tif rand.Float64() < 0.8 { // 80% chance to add one back if none are active.\n\t\t\t\t\t\tfor _, r := range allReceivers {\n\t\t\t\t\t\t\tif _, isActive := activeReceiverIDs[r.id]; !isActive {\n\t\t\t\t\t\t\t\tbroadcaster.Register(r)\n\t\t\t\t\t\t\t\tgo r.Start()\n\t\t\t\t\t\t\t\tactiveReceiverIDs[r.id] = struct{}{}\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Println(\"--- Finished dynamic receiver management ---\")\n\t}()\n\n\t// Wait for the event broadcasting and dynamic management goroutines to complete.\n\tmainWg.Wait()\n\n\tfmt.Println(\"\\n--- Finalizing system ---\")\n\t// Clean up all broadcaster resources and ensure all receivers are stopped.\n\tbroadcaster.Close()\n\n\t// Retrieve and print final metrics.\n\teventsDist, activeRecv := broadcaster.GetMetrics()\n\tfmt.Printf(\"\\n--- System Metrics ---\\n\")\n\tfmt.Printf(\"Total Events Distributed (excluding original): %d\\n\", eventsDist)\n\tfmt.Printf(\"Final Active Receivers: %d\\n\", activeRecv) // Should be 0 after Broadcaster.Close().\n\n\tfmt.Println(\"Program finished.\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:107\u001b[0m] - G115 (CWE-190): integer overflow conversion int -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    106: \t\t// If 3 receivers get an event, it counts as 2 additional distributions.\n  > 107: \t\tb.eventsDistributed.Add(uint64(numReceivers - 1))\n    108: \t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:237\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    236: \t\t\t\t\t// If no receivers are active, try to add one back to keep the system running.\n  > 237: \t\t\t\t\tif rand.Float64() < 0.8 { // 80% chance to add one back if none are active.\n    238: \t\t\t\t\t\tfor _, r := range allReceivers {\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:228\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    227: \t\t\t\t\tif len(activeKeys) > 0 {\n  > 228: \t\t\t\t\t\trandomID := activeKeys[rand.Intn(len(activeKeys))]\n    229: \t\t\t\t\t\treceiverToRemove = allReceivers[randomID] // Assuming receiver ID maps directly to slice index.\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:202\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    201: \t\t\t// Decide whether to add or remove a receiver.\n  > 202: \t\t\tif rand.Float64() < 0.5 { // 50% chance to add.\n    203: \t\t\t\t// Find an inactive receiver to add.\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:179\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    178: \t\t\tbroadcaster.Broadcast(event)\n  > 179: \t\t\ttime.Sleep(time.Millisecond * time.Duration(rand.Intn(100)+50)) // Simulate event generation delay.\n    180: \t\t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:41\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    40: \t\t// Simulate event processing time.\n  > 41: \t\ttime.Sleep(time.Millisecond * time.Duration(rand.Intn(50)+10))\n    42: \t\tfmt.Printf(\"Receiver %d processed event %d\\n\", r.id, event.ID)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 267\n  Nosec  : 0\n  Issues : \u001b[1;31m6\u001b[0m\n\n[gosec] 2025/12/01 13:15:25 Including rules: default\n[gosec] 2025/12/01 13:15:25 Excluding rules: default\n[gosec] 2025/12/01 13:15:25 Including analyzers: default\n[gosec] 2025/12/01 13:15:25 Excluding analyzers: default\n[gosec] 2025/12/01 13:15:25 Import directory: /tmp/go_synthesis_zac6ur44\n[gosec] 2025/12/01 13:15:26 Checking package: main\n[gosec] 2025/12/01 13:15:26 Checking file: /tmp/go_synthesis_zac6ur44/main.go"
                },
                {
                    "verifier": "staticcheck",
                    "error": "main.go:147:2: rand.Seed has been deprecated since Go 1.20 and an alternative has been available since Go 1.0: As of Go 1.20 there is no reason to call Seed with a random value. Programs that call Seed with a known value to get a specific sequence of results should use New(NewSource(seed)) to obtain a local random generator. (SA1019)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\" // Keep math/rand for rand.New, rand.NewSource\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Event represents an event that can be broadcast.\ntype Event struct {\n\tID   int\n\tData string\n}\n\n// Receiver represents an entity that can receive and process events.\ntype Receiver struct {\n\tid       int\n\tevents   chan Event\n\twg       sync.WaitGroup // Waits for the event processing goroutine to finish.\n\tisClosed atomic.Bool    // Ensures the events channel is closed only once.\n\trandom   *rand.Rand     // Local random number generator for processing delays.\n}\n\n// NewReceiver creates a new Receiver with a unique ID and a buffered channel.\nfunc NewReceiver(id int) *Receiver {\n\t// Each receiver gets its own random source for processing delays.\n\t// Adding the ID to the seed provides a more distinct seed for each receiver.\n\tr := rand.New(rand.NewSource(time.Now().UnixNano() + int64(id)))\n\treturn &Receiver{\n\t\tid:     id,\n\t\tevents: make(chan Event, 10), // Buffered channel to prevent blocking the broadcaster immediately.\n\t\trandom: r,\n\t}\n}\n\n// Start begins the event processing loop for the receiver.\n// This method should be run in a separate goroutine.\nfunc (r *Receiver) Start() {\n\tr.wg.Add(1)\n\tdefer r.wg.Done()\n\n\tfor event := range r.events {\n\t\t// Simulate event processing time using the receiver's local random generator.\n\t\ttime.Sleep(time.Millisecond * time.Duration(r.random.Intn(50)+10))\n\t\tfmt.Printf(\"Receiver %d processed event %d\\n\", r.id, event.ID)\n\t}\n}\n\n// Close gracefully stops the receiver by closing its event channel and waiting\n// for its processing goroutine to finish.\nfunc (r *Receiver) Close() {\n\tif r.isClosed.CompareAndSwap(false, true) {\n\t\tclose(r.events) // Signal the Start() goroutine to exit the range loop.\n\t\tr.wg.Wait()     // Wait for the Start() goroutine to complete all buffered events and terminate.\n\t}\n}\n\n// Broadcaster manages a collection of receivers and distributes events to them.\ntype Broadcaster struct {\n\treceivers map[*Receiver]struct{}\n\tmu        sync.RWMutex // Protects the receivers map.\n\n\t// Metrics\n\teventsDistributed atomic.Uint64 // Total count of events sent to receivers (excluding the original).\n}\n\n// NewBroadcaster creates and initializes a new Broadcaster instance.\nfunc NewBroadcaster() *Broadcaster {\n\treturn &Broadcaster{\n\t\treceivers: make(map[*Receiver]struct{}),\n\t}\n}\n\n// Register adds a receiver to the broadcaster's collection.\n// The receiver will start receiving events after registration.\nfunc (b *Broadcaster) Register(r *Receiver) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tif _, exists := b.receivers[r]; !exists {\n\t\tb.receivers[r] = struct{}{}\n\t\tfmt.Printf(\"Broadcaster: Receiver %d registered. Active: %d\\n\", r.id, len(b.receivers))\n\t}\n}\n\n// Unregister removes a receiver from the broadcaster's collection.\n// The receiver will no longer receive events and its resources will be cleaned up.\nfunc (b *Broadcaster) Unregister(r *Receiver) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tif _, exists := b.receivers[r]; exists {\n\t\tdelete(b.receivers, r)\n\t\tr.Close() // Close receiver's channel and wait for its goroutine to stop.\n\t\tfmt.Printf(\"Broadcaster: Receiver %d unregistered. Active: %d\\n\", r.id, len(b.receivers))\n\t}\n}\n\n// Broadcast sends an event to all currently registered receivers.\n// This operation is non-blocking for the broadcaster itself due to `select/default`\n// and buffered channels on receivers.\nfunc (b *Broadcaster) Broadcast(event Event) {\n\tb.mu.RLock() // Use RLock to allow concurrent reads/broadcasts.\n\tdefer b.mu.RUnlock()\n\n\tnumReceivers := len(b.receivers)\n\t// Metrics: EventsDistributed: num_receivers - 1 (as per requirements).\n\t// If 3 receivers get an event, it counts as 2 additional distributions.\n\t// Only add to metric if there's more than one receiver, to ensure positive value for (numReceivers - 1).\n\tif numReceivers > 1 {\n\t\tb.eventsDistributed.Add(uint64(numReceivers - 1))\n\t}\n\n\tfor r := range b.receivers {\n\t\t// Attempt to send the event without blocking.\n\t\tselect {\n\t\tcase r.events <- event:\n\t\t\t// Event sent successfully.\n\t\tdefault:\n\t\t\t// Receiver's channel is full, event is dropped.\n\t\t\t// In a production system, this might log an error, use a retry mechanism, or a larger buffer.\n\t\t\tfmt.Printf(\"Broadcaster: Dropped event %d for receiver %d (channel full)\\n\", event.ID, r.id)\n\t\t}\n\t}\n}\n\n// GetMetrics returns the current metrics for the broadcaster.\nfunc (b *Broadcaster) GetMetrics() (eventsDistributed uint64, activeReceivers int) {\n\tb.mu.RLock()\n\tdefer b.mu.RUnlock()\n\treturn b.eventsDistributed.Load(), len(b.receivers)\n}\n\n// Close shuts down the broadcaster and all its registered receivers,\n// releasing all associated resources.\nfunc (b *Broadcaster) Close() {\n\tb.mu.Lock() // Acquire write lock to prevent any further operations during shutdown.\n\tdefer b.mu.Unlock()\n\n\tfmt.Println(\"Broadcaster: Closing...\")\n\tfor r := range b.receivers {\n\t\tr.Close() // Close each receiver's channel and wait for its goroutine to finish.\n\t}\n\t// Clear the map after all receivers are closed.\n\tb.receivers = make(map[*Receiver]struct{})\n\tfmt.Println(\"Broadcaster: All receivers closed. System shut down.\")\n}\n\nfunc main() {\n\t// Create a local random number generator instance for main goroutines.\n\t// This replaces the deprecated global rand.Seed() and global rand functions.\n\tlocalRand := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\tbroadcaster := NewBroadcaster()\n\tvar mainWg sync.WaitGroup // To wait for all main goroutines (broadcaster, dynamic manager) to finish.\n\n\tconst initialReceivers = 5\n\tconst totalReceiversPool = 10 // A pool of potential receivers, some might be inactive initially.\n\tallReceivers := make([]*Receiver, totalReceiversPool)\n\tactiveReceiverIDs := make(map[int]struct{}) // Tracks IDs of receivers currently registered with the broadcaster.\n\n\t// Initialize the pool of all potential receivers.\n\tfor i := 0; i < totalReceucersPool; i++ {\n\t\tallReceivers[i] = NewReceiver(i)\n\t}\n\n\t// Register initial receivers and start their processing goroutines.\n\tfmt.Println(\"--- Initializing system ---\")\n\tfor i := 0; i < initialReceivers; i++ {\n\t\tbroadcaster.Register(allReceivers[i])\n\t\tgo allReceivers[i].Start() // Start the receiver's event processing loop.\n\t\tactiveReceiverIDs[allReceivers[i].id] = struct{}{}\n\t}\n\n\t// Goroutine for continuously broadcasting events.\n\tmainWg.Add(1)\n\tgo func(r *rand.Rand) { // Pass localRand to the closure\n\t\tdefer mainWg.Done()\n\t\tconst numEvents = 20 // Broadcast a total of 20 events.\n\t\tfmt.Printf(\"\\n--- Starting event broadcast of %d events ---\\n\", numEvents)\n\t\tfor i := 0; i < numEvents; i++ {\n\t\t\tevent := Event{ID: i, Data: fmt.Sprintf(\"event-%d\", i)}\n\t\t\tbroadcaster.Broadcast(event)\n\t\t\t// Simulate event generation delay using the local random generator.\n\t\t\ttime.Sleep(time.Millisecond * time.Duration(r.Intn(100)+50))\n\t\t}\n\t\tfmt.Println(\"--- Finished event broadcast ---\")\n\t}(localRand) // Pass localRand here\n\n\t// Goroutine for dynamic receiver management (adding and removing receivers).\n\tmainWg.Add(1)\n\tgo func(r *rand.Rand) { // Pass localRand to the closure\n\t\tdefer mainWg.Done()\n\t\tfmt.Println(\"\\n--- Starting dynamic receiver management ---\")\n\t\tticker := time.NewTicker(time.Millisecond * 500) // Perform an action every 500ms.\n\t\tdefer ticker.Stop()\n\n\t\tmaxDynamicOperations := 15 // Limit the number of dynamic ops for a finite test.\n\t\toperationCount := 0\n\n\t\tfor range ticker.C {\n\t\t\tif operationCount >= maxDynamicOperations {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\toperationCount++\n\n\t\t\t// Decide whether to add or remove a receiver using the local random generator.\n\t\t\tif r.Float64() < 0.5 { // 50% chance to add.\n\t\t\t\t// Find an inactive receiver to add.\n\t\t\t\tfoundInactive := false\n\t\t\t\tfor _, rec := range allReceivers {\n\t\t\t\t\tif _, isActive := activeReceiverIDs[rec.id]; !isActive {\n\t\t\t\t\t\tbroadcaster.Register(rec)\n\t\t\t\t\t\tgo rec.Start()\n\t\t\t\t\t\tactiveReceiverIDs[rec.id] = struct{}{}\n\t\t\t\t\t\tfoundInactive = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !foundInactive {\n\t\t\t\t\t// fmt.Println(\"Dynamic management: No inactive receivers available to add.\")\n\t\t\t\t}\n\t\t\t} else { // 50% chance to remove.\n\t\t\t\t// Find an active receiver to remove.\n\t\t\t\tif len(activeReceiverIDs) > 0 {\n\t\t\t\t\tvar receiverToRemove *Receiver\n\t\t\t\t\t// Collect active receiver IDs to pick a random one.\n\t\t\t\t\tactiveKeys := make([]int, 0, len(activeReceiverIDs))\n\t\t\t\t\tfor k := range activeReceiverIDs {\n\t\t\t\t\t\tactiveKeys = append(activeKeys, k)\n\t\t\t\t\t}\n\n\t\t\t\t\tif len(activeKeys) > 0 {\n\t\t\t\t\t\t// Pick a random active receiver ID using the local random generator.\n\t\t\t\t\t\trandomID := activeKeys[r.Intn(len(activeKeys))]\n\t\t\t\t\t\treceiverToRemove = allReceivers[randomID] // Assuming receiver ID maps directly to slice index.\n\n\t\t\t\t\t\tbroadcaster.Unregister(receiverToRemove)\n\t\t\t\t\t\tdelete(activeReceiverIDs, receiverToRemove.id)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// fmt.Println(\"Dynamic management: No active receivers to remove.\")\n\t\t\t\t\t// If no receivers are active, try to add one back to keep the system running.\n\t\t\t\t\tif r.Float64() < 0.8 { // 80% chance to add one back if none are active.\n\t\t\t\t\t\tfor _, rec := range allReceivers {\n\t\t\t\t\t\t\tif _, isActive := activeReceiverIDs[rec.id]; !isActive {\n\t\t\t\t\t\t\t\tbroadcaster.Register(rec)\n\t\t\t\t\t\t\t\tgo rec.Start()\n\t\t\t\t\t\t\t\tactiveReceiverIDs[rec.id] = struct{}{}\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Println(\"--- Finished dynamic receiver management ---\")\n\t}(localRand) // Pass localRand here\n\n\t// Wait for the event broadcasting and dynamic management goroutines to complete.\n\tmainWg.Wait()\n\n\tfmt.Println(\"\\n--- Finalizing system ---\")\n\t// Clean up all broadcaster resources and ensure all receivers are stopped.\n\tbroadcaster.Close()\n\n\t// Retrieve and print final metrics.\n\teventsDist, activeRecv := broadcaster.GetMetrics()\n\tfmt.Printf(\"\\n--- System Metrics ---\\n\")\n\tfmt.Printf(\"Total Events Distributed (excluding original): %d\\n\", eventsDist)\n\tfmt.Printf(\"Final Active Receivers: %d\\n\", activeRecv) // Should be 0 after Broadcaster.Close().\n\n\tfmt.Println(\"Program finished.\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:165:18: undefined: totalReceucersPool"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:165:18: undefined: totalReceucersPool\n\n\nGolang errors in file: [/tmp/go_synthesis_zac6ur44/main.go]:\n\n  > [line 165 : column 18] - undefined: totalReceucersPool\n\n\n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:154\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    153: \t// This replaces the deprecated global rand.Seed() and global rand functions.\n  > 154: \tlocalRand := rand.New(rand.NewSource(time.Now().UnixNano()))\n    155: \n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:30\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    29: \t// Adding the ID to the seed provides a more distinct seed for each receiver.\n  > 30: \tr := rand.New(rand.NewSource(time.Now().UnixNano() + int64(id)))\n    31: \treturn &Receiver{\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 276\n  Nosec  : 0\n  Issues : \u001b[1;31m2\u001b[0m\n\n[gosec] 2025/12/01 13:15:53 Including rules: default\n[gosec] 2025/12/01 13:15:53 Excluding rules: default\n[gosec] 2025/12/01 13:15:53 Including analyzers: default\n[gosec] 2025/12/01 13:15:53 Excluding analyzers: default\n[gosec] 2025/12/01 13:15:53 Import directory: /tmp/go_synthesis_zac6ur44\n[gosec] 2025/12/01 13:15:53 Checking package: main\n[gosec] 2025/12/01 13:15:53 Checking file: /tmp/go_synthesis_zac6ur44/main.go\n[gosec] 2025/12/01 13:15:53 Panic when running SSA analyzer on package: main. Panic: runtime error: invalid memory address or nil pointer dereference\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xecea40?, 0x1998730?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*Program).packageLevelMember(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/source.go:187\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0004b2510, 0xc000577c00, {0x11e2648?, 0xc000d11700}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:820 +0x1b2b\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0004b2510, 0xc000577c00, {0x11e2648, 0xc000d11700})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0004b2510, 0xc000577c00, {0x11e2678?, 0xc000d61dd0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:764 +0x170e\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0004b2510, 0xc000577c00, {0x11e2678, 0xc000d61dd0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).cond(0xc0004b2510?, 0xc000577c00, {0x11e2678?, 0xc000d61dd0?}, 0xc000810210, 0xc000810370)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:215 +0x430\ngolang.org/x/tools/go/ssa.(*builder).forStmtGo122(0xc0004b2510, 0xc000577c00, 0xc000d52100, 0x0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1961 +0xde9\ngolang.org/x/tools/go/ssa.(*builder).forStmt(0xc0004b2510, 0xc000577c00, 0xc000d52100, 0x0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1814 +0xba\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc0004b2510, 0xc000577c00, {0x11e3000?, 0xc000d52100?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2788 +0x4b4\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc0004b2510, 0xc000577c00, {0x11e2eb0?, 0xc000d54780?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc0004b2510, 0xc000577c00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000577c00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc0004b2510)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc000fa3480)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc00018c240?, 0xc000d78de0?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc0004b8000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc000b9b860)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc00028e680, 0xc000b9b860)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc00028e680, {0x0, 0x0, 0x0}, {0xc000206b20, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 13:15:53 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_zac6ur44/main.go:165:18: undefined: totalReceucersPool\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:165:18: undefined: totalReceucersPool /tmp/go_synthesis_zac6ur44/main.go:165:18: undefined: totalReceucersPool]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:165:18: undefined: totalReceucersPool\n/tmp/go_synthesis_zac6ur44/main.go:165:18: undefined: totalReceucersPool\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:165:18: undefined: totalReceucersPool (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Event represents an event that can be broadcast.\ntype Event struct {\n\tID   int\n\tData string\n}\n\n// Receiver represents an entity that can receive and process events.\ntype Receiver struct {\n\tid       int\n\tevents   chan Event\n\twg       sync.WaitGroup // Waits for the event processing goroutine to finish.\n\tisClosed atomic.Bool    // Ensures the events channel is closed only once.\n\trandom   *rand.Rand     // Local random number generator for processing delays.\n}\n\n// NewReceiver creates a new Receiver with a unique ID and a buffered channel.\nfunc NewReceiver(id int) *Receiver {\n\t// Each receiver gets its own random source for processing delays.\n\t// Adding the ID to the seed provides a more distinct seed for each receiver.\n\t// Using math/rand for simulation is acceptable as per problem context.\n\tr := rand.New(rand.NewSource(time.Now().UnixNano() + int64(id)))\n\treturn &Receiver{\n\t\tid:     id,\n\t\tevents: make(chan Event, 10), // Buffered channel to prevent blocking the broadcaster immediately.\n\t\trandom: r,\n\t}\n}\n\n// Start begins the event processing loop for the receiver.\n// This method should be run in a separate goroutine.\nfunc (r *Receiver) Start() {\n\tr.wg.Add(1)\n\tdefer r.wg.Done()\n\n\tfor event := range r.events {\n\t\t// Simulate event processing time using the receiver's local random generator.\n\t\ttime.Sleep(time.Millisecond * time.Duration(r.random.Intn(50)+10))\n\t\tfmt.Printf(\"Receiver %d processed event %d\\n\", r.id, event.ID)\n\t}\n}\n\n// Close gracefully stops the receiver by closing its event channel and waiting\n// for its processing goroutine to finish.\nfunc (r *Receiver) Close() {\n\tif r.isClosed.CompareAndSwap(false, true) {\n\t\tclose(r.events) // Signal the Start() goroutine to exit the range loop.\n\t\tr.wg.Wait()     // Wait for the Start() goroutine to complete all buffered events and terminate.\n\t}\n}\n\n// Broadcaster manages a collection of receivers and distributes events to them.\ntype Broadcaster struct {\n\treceivers map[*Receiver]struct{}\n\tmu        sync.RWMutex // Protects the receivers map.\n\n\t// Metrics\n\teventsDistributed atomic.Uint64 // Total count of events sent to receivers (excluding the original).\n}\n\n// NewBroadcaster creates and initializes a new Broadcaster instance.\nfunc NewBroadcaster() *Broadcaster {\n\treturn &Broadcaster{\n\t\treceivers: make(map[*Receiver]struct{}),\n\t}\n}\n\n// Register adds a receiver to the broadcaster's collection.\n// The receiver will start receiving events after registration.\nfunc (b *Broadcaster) Register(r *Receiver) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tif _, exists := b.receivers[r]; !exists {\n\t\tb.receivers[r] = struct{}{}\n\t\tfmt.Printf(\"Broadcaster: Receiver %d registered. Active: %d\\n\", r.id, len(b.receivers))\n\t}\n}\n\n// Unregister removes a receiver from the broadcaster's collection.\n// The receiver will no longer receive events and its resources will be cleaned up.\nfunc (b *Broadcaster) Unregister(r *Receiver) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\n\tif _, exists := b.receivers[r]; exists {\n\t\tdelete(b.receivers, r)\n\t\tr.Close() // Close receiver's channel and wait for its goroutine to stop.\n\t\tfmt.Printf(\"Broadcaster: Receiver %d unregistered. Active: %d\\n\", r.id, len(b.receivers))\n\t}\n}\n\n// Broadcast sends an event to all currently registered receivers.\n// This operation is non-blocking for the broadcaster itself due to `select/default`\n// and buffered channels on receivers.\nfunc (b *Broadcaster) Broadcast(event Event) {\n\tb.mu.RLock() // Use RLock to allow concurrent reads/broadcasts.\n\tdefer b.mu.RUnlock()\n\n\tnumReceivers := len(b.receivers)\n\t// Metrics: EventsDistributed: num_receivers - 1 (as per requirements).\n\t// If 3 receivers get an event, it counts as 2 additional distributions.\n\t// Only add to metric if there's more than one receiver, to ensure positive value for (numReceivers - 1).\n\tif numReceivers > 1 {\n\t\tb.eventsDistributed.Add(uint64(numReceivers - 1))\n\t}\n\n\tfor r := range b.receivers {\n\t\t// Attempt to send the event without blocking.\n\t\tselect {\n\t\tcase r.events <- event:\n\t\t\t// Event sent successfully.\n\t\tdefault:\n\t\t\t// Receiver's channel is full, event is dropped.\n\t\t\t// In a production system, this might log an error, use a retry mechanism, or a larger buffer.\n\t\t\tfmt.Printf(\"Broadcaster: Dropped event %d for receiver %d (channel full)\\n\", event.ID, r.id)\n\t\t}\n\t}\n}\n\n// GetMetrics returns the current metrics for the broadcaster.\nfunc (b *Broadcaster) GetMetrics() (eventsDistributed uint64, activeReceivers int) {\n\tb.mu.RLock()\n\tdefer b.mu.RUnlock()\n\treturn b.eventsDistributed.Load(), len(b.receivers)\n}\n\n// Close shuts down the broadcaster and all its registered receivers,\n// releasing all associated resources.\nfunc (b *Broadcaster) Close() {\n\tb.mu.Lock() // Acquire write lock to prevent any further operations during shutdown.\n\tdefer b.mu.Unlock()\n\n\tfmt.Println(\"Broadcaster: Closing...\")\n\tfor r := range b.receivers {\n\t\tr.Close() // Close each receiver's channel and wait for its goroutine to finish.\n\t}\n\t// Clear the map after all receivers are closed.\n\tb.receivers = make(map[*Receiver]struct{})\n\tfmt.Println(\"Broadcaster: All receivers closed. System shut down.\")\n}\n\nfunc main() {\n\t// Create a local random number generator instance for main goroutines.\n\t// This replaces the deprecated global rand.Seed() and global rand functions.\n\t// Using math/rand for simulation is acceptable as per problem context.\n\tlocalRand := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\tbroadcaster := NewBroadcaster()\n\tvar mainWg sync.WaitGroup // To wait for all main goroutines (broadcaster, dynamic manager) to finish.\n\n\tconst initialReceivers = 5\n\tconst totalReceiversPool = 10 // A pool of potential receivers, some might be inactive initially.\n\tallReceivers := make([]*Receiver, totalReceiversPool)\n\tactiveReceiverIDs := make(map[int]struct{}) // Tracks IDs of receivers currently registered with the broadcaster.\n\n\t// Initialize the pool of all potential receivers.\n\tfor i := 0; i < totalReceiversPool; i++ { // Fixed typo: totalReceucersPool -> totalReceiversPool\n\t\tallReceivers[i] = NewReceiver(i)\n\t}\n\n\t// Register initial receivers and start their processing goroutines.\n\tfmt.Println(\"--- Initializing system ---\")\n\tfor i := 0; i < initialReceivers; i++ {\n\t\tbroadcaster.Register(allReceivers[i])\n\t\tgo allReceivers[i].Start() // Start the receiver's event processing loop.\n\t\tactiveReceiverIDs[allReceivers[i].id] = struct{}{}\n\t}\n\n\t// Goroutine for continuously broadcasting events.\n\tmainWg.Add(1)\n\tgo func(r *rand.Rand) { // Pass localRand to the closure\n\t\tdefer mainWg.Done()\n\t\tconst numEvents = 20 // Broadcast a total of 20 events.\n\t\tfmt.Printf(\"\\n--- Starting event broadcast of %d events ---\\n\", numEvents)\n\t\tfor i := 0; i < numEvents; i++ {\n\t\t\tevent := Event{ID: i, Data: fmt.Sprintf(\"event-%d\", i)}\n\t\t\tbroadcaster.Broadcast(event)\n\t\t\t// Simulate event generation delay using the local random generator.\n\t\t\ttime.Sleep(time.Millisecond * time.Duration(r.Intn(100)+50))\n\t\t}\n\t\tfmt.Println(\"--- Finished event broadcast ---\")\n\t}(localRand) // Pass localRand here\n\n\t// Goroutine for dynamic receiver management (adding and removing receivers).\n\tmainWg.Add(1)\n\tgo func(r *rand.Rand) { // Pass localRand to the closure\n\t\tdefer mainWg.Done()\n\t\tfmt.Println(\"\\n--- Starting dynamic receiver management ---\")\n\t\tticker := time.NewTicker(time.Millisecond * 500) // Perform an action every 500ms.\n\t\tdefer ticker.Stop()\n\n\t\tmaxDynamicOperations := 15 // Limit the number of dynamic ops for a finite test.\n\t\toperationCount := 0\n\n\t\tfor range ticker.C {\n\t\t\tif operationCount >= maxDynamicOperations {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\toperationCount++\n\n\t\t\t// Decide whether to add or remove a receiver using the local random generator.\n\t\t\tif r.Float64() < 0.5 { // 50% chance to add.\n\t\t\t\t// Find an inactive receiver to add.\n\t\t\t\tfoundInactive := false\n\t\t\t\tfor _, rec := range allReceivers {\n\t\t\t\t\tif _, isActive := activeReceiverIDs[rec.id]; !isActive {\n\t\t\t\t\t\tbroadcaster.Register(rec)\n\t\t\t\t\t\tgo rec.Start()\n\t\t\t\t\t\tactiveReceiverIDs[rec.id] = struct{}{}\n\t\t\t\t\t\tfoundInactive = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !foundInactive {\n\t\t\t\t\t// fmt.Println(\"Dynamic management: No inactive receivers available to add.\")\n\t\t\t\t}\n\t\t\t} else { // 50% chance to remove.\n\t\t\t\t// Find an active receiver to remove.\n\t\t\t\tif len(activeReceiverIDs) > 0 {\n\t\t\t\t\tvar receiverToRemove *Receiver\n\t\t\t\t\t// Collect active receiver IDs to pick a random one.\n\t\t\t\t\tactiveKeys := make([]int, 0, len(activeReceiverIDs))\n\t\t\t\t\tfor k := range activeReceiverIDs {\n\t\t\t\t\t\tactiveKeys = append(activeKeys, k)\n\t\t\t\t\t}\n\n\t\t\t\t\tif len(activeKeys) > 0 {\n\t\t\t\t\t\t// Pick a random active receiver ID using the local random generator.\n\t\t\t\t\t\trandomID := activeKeys[r.Intn(len(activeKeys))]\n\t\t\t\t\t\treceiverToRemove = allReceivers[randomID] // Assuming receiver ID maps directly to slice index.\n\n\t\t\t\t\t\tbroadcaster.Unregister(receiverToRemove)\n\t\t\t\t\t\tdelete(activeReceiverIDs, receiverToRemove.id)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// fmt.Println(\"Dynamic management: No active receivers to remove.\")\n\t\t\t\t\t// If no receivers are active, try to add one back to keep the system running.\n\t\t\t\t\tif r.Float64() < 0.8 { // 80% chance to add one back if none are active.\n\t\t\t\t\t\tfor _, rec := range allReceivers {\n\t\t\t\t\t\t\tif _, isActive := activeReceiverIDs[rec.id]; !isActive {\n\t\t\t\t\t\t\t\tbroadcaster.Register(rec)\n\t\t\t\t\t\t\t\tgo rec.Start()\n\t\t\t\t\t\t\t\tactiveReceiverIDs[rec.id] = struct{}{}\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Println(\"--- Finished dynamic receiver management ---\")\n\t}(localRand) // Pass localRand here\n\n\t// Wait for the event broadcasting and dynamic management goroutines to complete.\n\tmainWg.Wait()\n\n\tfmt.Println(\"\\n--- Finalizing system ---\")\n\t// Clean up all broadcaster resources and ensure all receivers are stopped.\n\tbroadcaster.Close()\n\n\t// Retrieve and print final metrics.\n\teventsDist, activeRecv := broadcaster.GetMetrics()\n\tfmt.Printf(\"\\n--- System Metrics ---\\n\")\n\tfmt.Printf(\"Total Events Distributed (excluding original): %d\\n\", eventsDist)\n\tfmt.Printf(\"Final Active Receivers: %d\\n\", activeRecv) // Should be 0 after Broadcaster.Close().\n\n\tfmt.Println(\"Program finished.\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:114\u001b[0m] - G115 (CWE-190): integer overflow conversion int -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    113: \tif numReceivers > 1 {\n  > 114: \t\tb.eventsDistributed.Add(uint64(numReceivers - 1))\n    115: \t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:156\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    155: \t// Using math/rand for simulation is acceptable as per problem context.\n  > 156: \tlocalRand := rand.New(rand.NewSource(time.Now().UnixNano()))\n    157: \n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_zac6ur44/main.go:31\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    30: \t// Using math/rand for simulation is acceptable as per problem context.\n  > 31: \tr := rand.New(rand.NewSource(time.Now().UnixNano() + int64(id)))\n    32: \treturn &Receiver{\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 278\n  Nosec  : 0\n  Issues : \u001b[1;31m3\u001b[0m\n\n[gosec] 2025/12/01 13:16:08 Including rules: default\n[gosec] 2025/12/01 13:16:08 Excluding rules: default\n[gosec] 2025/12/01 13:16:08 Including analyzers: default\n[gosec] 2025/12/01 13:16:08 Excluding analyzers: default\n[gosec] 2025/12/01 13:16:08 Import directory: /tmp/go_synthesis_zac6ur44\n[gosec] 2025/12/01 13:16:08 Checking package: main\n[gosec] 2025/12/01 13:16:08 Checking file: /tmp/go_synthesis_zac6ur44/main.go"
                }
            ]
        }
    ],
    "passed": false
}