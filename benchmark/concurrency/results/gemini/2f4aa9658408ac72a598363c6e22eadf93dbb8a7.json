{
    "task": "2f4aa9658408ac72a598363c6e22eadf93dbb8a7.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// ProgressUpdate represents a single progress update for a file download.\ntype ProgressUpdate struct {\n\tID      string // File ID\n\tCurrent int    // Current progress value\n\tTotal   int    // Total size (target progress)\n}\n\n// downloadFile simulates downloading a file.\n// It sends progress updates through the progressChan.\nfunc downloadFile(id string, totalSize int, progressChan chan<- ProgressUpdate, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\n\tfmt.Printf(\"Starting download for File %s (Total: %d)\\n\", id, totalSize)\n\tfor i := 0; i <= totalSize; i++ {\n\t\t// Simulate work\n\t\ttime.Sleep(time.Millisecond * 10) // Slower simulation to make updates visible\n\n\t\t// Send progress update\n\t\tprogressChan <- ProgressUpdate{\n\t\t\tID:      id,\n\t\t\tCurrent: i,\n\t\t\tTotal:   totalSize,\n\t\t}\n\t}\n\tfmt.Printf(\"File %s download complete.\\n\", id)\n}\n\n// monitorProgress receives and processes progress updates.\n// It tracks the latest progress for each file and validates monotonicity.\nfunc monitorProgress(progressChan <-chan ProgressUpdate, donePrinting chan<- struct{}) {\n\t// fileStates stores the latest progress and total for each file.\n\t// No mutex needed as this map is only accessed by this single goroutine.\n\tfileStates := make(map[string]struct {\n\t\tCurrent int\n\t\tTotal   int\n\t})\n\n\t// previousProgress is used solely for monotonicity validation.\n\tpreviousProgress := make(map[string]int)\n\n\tfmt.Println(\"Progress Monitor started.\")\n\tfmt.Println(\"Starting downloads...\")\n\n\tfor update := range progressChan {\n\t\t// Monotonicity check\n\t\tif prev, ok := previousProgress[update.ID]; ok && update.Current < prev {\n\t\t\tfmt.Printf(\"ERROR: Non-monotonic progress for File %s: received %d, previous was %d\\n\", update.ID, update.Current, prev)\n\t\t\t// This indicates a logical error in the progress reporting, but we continue processing.\n\t\t}\n\t\tpreviousProgress[update.ID] = update.Current\n\n\t\t// Update the latest progress for the file\n\t\tfileStates[update.ID] = struct {\n\t\t\tCurrent int\n\t\t\tTotal   int\n\t\t}{\n\t\t\tCurrent: update.Current,\n\t\t\tTotal:   update.Total,\n\t\t}\n\n\t\t// Print intermittent progress.\n\t\t// To match the example output's spirit and avoid excessive logging for larger `totalSize`,\n\t\t// we print at 10% increments and at the final total.\n\t\tif update.Total > 0 && (update.Current%(update.Total/10) == 0 || update.Current == update.Total) {\n\t\t    fmt.Printf(\"File %s: progress %d/%d\\n\", update.ID, update.Current, update.Total)\n\t\t} else if update.Total == 0 && update.Current == 0 { // Handle totalSize 0 case gracefully for initial print\n\t\t    fmt.Printf(\"File %s: progress %d/%d\\n\", update.ID, update.Current, update.Total)\n\t\t}\n\t}\n\n\tfmt.Println(\"All downloads completed successfully\")\n\tfmt.Println(\"Final state:\")\n\tfor id, state := range fileStates {\n\t\tfmt.Printf(\"  File %s: %d/%d\\n\", id, state.Current, state.Total)\n\t}\n\tclose(donePrinting) // Signal that the monitor has finished processing and printing\n}\n\nfunc main() {\n\t// Channel for progress updates from downloaders to monitor\n\tprogressChan := make(chan ProgressUpdate)\n\n\t// WaitGroup to wait for all download goroutines to finish\n\tvar wg sync.WaitGroup\n\n\t// Channel to signal when the monitor has finished all its processing and printing\n\tdonePrinting := make(chan struct{})\n\n\t// Start the progress monitor goroutine\n\tgo monitorProgress(progressChan, donePrinting)\n\n\t// Define download tasks. Each should have at least 100 progress increments.\n\tdownloads := []struct {\n\t\tID        string\n\t\tTotalSize int\n\t}{\n\t\t{ID: \"A\", TotalSize: 100},\n\t\t{ID: \"B\", TotalSize: 150},\n\t\t{ID: \"C\", TotalSize: 120},\n\t\t{ID: \"D\", TotalSize: 110}, // At least 3 downloads, each with >= 100 increments\n\t}\n\n\t// Start concurrent download simulations\n\tfor _, dl := range downloads {\n\t\twg.Add(1)\n\t\tgo downloadFile(dl.ID, dl.TotalSize, progressChan, &wg)\n\t}\n\n\t// Wait for all download goroutines to complete their work\n\twg.Wait()\n\n\t// Close the progress channel. This signals to the monitor goroutine\n\t// that no more updates will be sent, allowing its 'range' loop to terminate.\n\tclose(progressChan)\n\n\t// Wait for the monitor goroutine to finish processing all updates and print the final state.\n\t<-donePrinting\n\n\tfmt.Println(\"Program finished cleanly.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}