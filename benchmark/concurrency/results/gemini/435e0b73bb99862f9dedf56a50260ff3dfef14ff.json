{
    "task": "435e0b73bb99862f9dedf56a50260ff3dfef14ff.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Event is a simple struct containing event data.\ntype Event struct {\n\tType string\n\tData interface{}\n}\n\n// Watcher interface defines methods for receiving and stopping events.\ntype Watcher interface {\n\tResultChan() <-chan Event // Returns a read-only channel for events\n\tStop()                    // Stops the watcher from receiving events\n}\n\n// muxWatcher implements the Watcher interface.\ntype muxWatcher struct {\n\tid          int\n\tresultChan  chan Event    // Public buffered channel for consumers to receive events\n\tstopOnce    sync.Once     // Ensures Stop() logic runs only once\n\tstopSignal  chan struct{} // To signal the internal goroutine to stop and close resultChan\n\tstopped     atomic.Bool   // To prevent multiple attempts to notify Mux for removal\n\tmuxStopChan chan<- int    // Channel to send its ID back to Mux for removal\n\twg          sync.WaitGroup// To wait for the internal `run` goroutine to finish\n}\n\n// newMuxWatcher creates and starts a new muxWatcher.\nfunc newMuxWatcher(id int, muxStopChan chan<- int) *muxWatcher {\n\tw := &muxWatcher{\n\t\tid:          id,\n\t\tresultChan:  make(chan Event, 100), // Buffered channel for events\n\t\tstopSignal:  make(chan struct{}),\n\t\tmuxStopChan: muxStopChan,\n\t}\n\tw.wg.Add(1)\n\tgo w.run() // Start the goroutine that will close resultChan when stopped\n\treturn w\n}\n\n// run is the internal goroutine for muxWatcher.\n// It waits for a stop signal, then closes the resultChan and attempts to notify the Mux for removal.\nfunc (w *muxWatcher) run() {\n\tdefer w.wg.Done()\n\t<-w.stopSignal // Wait for stop signal\n\tclose(w.resultChan) // Close the result channel to signal no more events will be sent\n\n\t// Attempt to notify Mux for removal. Use select with default to be non-blocking.\n\t// This prevents the watcher from blocking if Mux's `stopWatcher` channel is not being read\n\t// (e.g., Mux is shutting down or busy).\n\tif !w.stopped.Load() {\n\t\tselect {\n\t\tcase w.muxStopChan <- w.id:\n\t\t\tw.stopped.Store(true)\n\t\tdefault:\n\t\t\t// Mux's stop channel is likely not being read or is closed.\n\t\t\t// This is fine, Mux will eventually clean up or is already shutting down.\n\t\t}\n\t}\n}\n\n// ResultChan returns the read-only channel for receiving events.\nfunc (w *muxWatcher) ResultChan() <-chan Event {\n\treturn w.resultChan\n}\n\n// Stop gracefully stops the watcher from receiving new events.\n// It is safe to call multiple times.\nfunc (w *muxWatcher) Stop() {\n\tw.stopOnce.Do(func() {\n\t\tclose(w.stopSignal) // Signal the `run` goroutine to stop and close resultChan\n\t\tw.wg.Wait()         // Wait for `run` goroutine to finish its cleanup\n\t})\n}\n\n// Mux (Multiplexer) is the central component for distributing events.\ntype Mux struct {\n\tmu            sync.RWMutex\n\twatchers      map[int]*muxWatcher // Active watchers by ID\n\tnextWatcherID int                 // Counter for unique watcher IDs\n\tstopWatcher   chan int            // Watchers send their ID here when they stop\n\tstopMux       chan struct{}       // Signal to stop Mux's internal goroutine\n\tmuxWg         sync.WaitGroup      // WaitGroup for Mux's internal goroutine\n\tbroadcastWg   sync.WaitGroup      // WaitGroup for individual broadcast goroutines\n}\n\n// NewMux creates and initializes a new Mux.\nfunc NewMux() *Mux {\n\tm := &Mux{\n\t\twatchers:      make(map[int]*muxWatcher),\n\t\tnextWatcherID: 0,\n\t\tstopWatcher:   make(chan int), // Unbuffered channel for watcher removal signals\n\t\tstopMux:       make(chan struct{}),\n\t}\n\tm.muxWg.Add(1)\n\tgo m.runMux() // Start Mux's internal goroutine for cleanup\n\treturn m\n}\n\n// runMux handles watcher cleanup and Mux shutdown.\nfunc (m *Mux) runMux() {\n\tdefer m.muxWg.Done()\n\tfor {\n\t\tselect {\n\t\tcase id := <-m.stopWatcher:\n\t\t\t// A watcher has signaled it has stopped and wants to be removed.\n\t\t\tm.mu.Lock()\n\t\t\tif _, exists := m.watchers[id]; exists {\n\t\t\t\tdelete(m.watchers, id)\n\t\t\t\tfmt.Printf(\"Mux: Watcher %d removed from active list.\\n\", id)\n\t\t\t}\n\t\t\tm.mu.Unlock()\n\t\tcase <-m.stopMux:\n\t\t\t// Mux is shutting down. Stop all remaining active watchers.\n\t\t\tm.mu.Lock()\n\t\t\tfor _, w := range m.watchers {\n\t\t\t\tw.Stop() // This will signal the watcher to close its resultChan\n\t\t\t}\n\t\t\tm.watchers = nil // Clear the map\n\t\t\tm.mu.Unlock()\n\t\t\treturn // Exit runMux goroutine\n\t\t}\n\t}\n}\n\n// Watch creates and registers a new watcher with the Mux.\nfunc (m *Mux) Watch() Watcher {\n\tm.mu.Lock()\n\tid := m.nextWatcherID\n\tm.nextWatcherID++\n\tm.mu.Unlock()\n\n\twatcher := newMuxWatcher(id, m.stopWatcher)\n\n\tm.mu.Lock()\n\tm.watchers[id] = watcher\n\tm.mu.Unlock()\n\tfmt.Printf(\"Mux: Watcher %d created and added.\\n\", id)\n\treturn watcher\n}\n\n// Broadcast sends an event to all currently active watchers.\n// Each send to a watcher is done in a separate goroutine to prevent a slow\n// watcher from blocking the Mux or other watchers.\nfunc (m *Mux) Broadcast(event Event) {\n\tm.mu.RLock()\n\t// Create a copy of the active watchers to avoid holding the RLock\n\t// during sends and to avoid iterator invalidation issues if a watcher stops concurrently.\n\tactiveWatchers := make([]*muxWatcher, 0, len(m.watchers))\n\tfor _, w := range m.watchers {\n\t\tactiveWatchers = append(activeWatchers, w)\n\t}\n\tm.mu.RUnlock()\n\n\tfor _, w := range activeWatchers {\n\t\tm.broadcastWg.Add(1) // Increment for each broadcast goroutine\n\t\tgo func(watcher *muxWatcher, ev Event) {\n\t\t\tdefer m.broadcastWg.Done()\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t// This recover handles panics if `watcher.resultChan` is closed\n\t\t\t\t\t// by `watcher.Stop()` in a race condition with Mux.Broadcast.\n\t\t\t\t\t// This is expected and means the watcher was stopped just before the send.\n\t\t\t\t\t// fmt.Printf(\"Broadcast: Recovered from panic sending to watcher %d: %v\\n\", watcher.id, r)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\t// Attempt to send the event with a timeout.\n\t\t\t// This prevents a single slow consumer from infinitely blocking the broadcast goroutine.\n\t\t\tselect {\n\t\t\tcase watcher.resultChan <- ev:\n\t\t\t\t// Event sent successfully\n\t\t\tcase <-time.After(50 * time.Millisecond): // Timeout for sending\n\t\t\t\t// If the channel is full or the receiver is not ready within the timeout,\n\t\t\t\t// the event is dropped for this specific watcher.\n\t\t\t\t// fmt.Printf(\"Broadcast: Dropped event for watcher %d due to timeout.\\n\", watcher.id)\n\t\t\t}\n\t\t}(w, event)\n\t}\n}\n\n// Close gracefully shuts down the Mux and all its watchers.\nfunc (m *Mux) Close() {\n\tfmt.Println(\"Mux: Initiating shutdown...\")\n\tclose(m.stopMux)     // Signal Mux's runMux goroutine to stop\n\tm.muxWg.Wait()       // Wait for runMux to finish cleanup (stops all remaining watchers)\n\n\t// Wait for all in-flight broadcast goroutines to complete.\n\t// Any broadcast to a watcher that just stopped will recover from panic gracefully.\n\tm.broadcastWg.Wait()\n\tfmt.Println(\"Mux: All resources cleaned up. Shutdown complete.\")\n}\n\nfunc main() {\n\tfmt.Println(\"Starting Event Distribution System Demo...\")\n\n\t// 1. Creating a Mux\n\tmux := NewMux()\n\n\t// 2. Starting multiple watchers (at least 3)\n\twatcher1 := mux.Watch()\n\twatcher2 := mux.Watch()\n\twatcher3 := mux.Watch()\n\n\t// Goroutines to receive and print events from watchers\n\tvar wg sync.WaitGroup\n\tstartWatcherGoroutine := func(id int, w Watcher) {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor event := range w.ResultChan() {\n\t\t\t\tfmt.Printf(\"Watcher %d received: Type=%s, Data=%v\\n\", id, event.Type, event.Data)\n\t\t\t}\n\t\t\tfmt.Printf(\"Watcher %d: Result channel closed, exiting.\\n\", id)\n\t\t}()\n\t}\n\n\tstartWatcherGoroutine(1, watcher1)\n\tstartWatcherGoroutine(2, watcher2)\n\tstartWatcherGoroutine(3, watcher3)\n\n\t// Give some time for watchers to start their goroutines and get ready\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// 3. Broadcasting several events\n\tfmt.Println(\"\\nBroadcasting initial events...\")\n\tmux.Broadcast(Event{Type: \"UserCreated\", Data: \"Alice\"})\n\tmux.Broadcast(Event{Type: \"ProductViewed\", Data: 101})\n\ttime.Sleep(200 * time.Millisecond) // Allow time for events to be processed\n\n\t// 4. Having some watchers stop while events are being broadcast\n\tfmt.Println(\"\\nWatcher 2 stopping...\")\n\twatcher2.Stop() // Watcher 2 stops\n\ttime.Sleep(100 * time.Millisecond) // Give time for stop signal to propagate\n\n\tfmt.Println(\"\\nBroadcasting more events after Watcher 2 stopped...\")\n\tmux.Broadcast(Event{Type: \"OrderPlaced\", Data: map[string]interface{}{\"ID\": \"ORD001\", \"Amount\": 99.99}})\n\tmux.Broadcast(Event{Type: \"UserLoggedIn\", Data: \"Bob\"})\n\ttime.Sleep(200 * time.Millisecond)\n\n\t// 5. Continuing to broadcast events after some watchers have stopped\n\tfmt.Println(\"\\nWatcher 1 stopping...\")\n\twatcher1.Stop() // Watcher 1 stops\n\ttime.Sleep(100 * time.Millisecond)\n\n\tfmt.Println(\"\\nBroadcasting final events after Watcher 1 stopped...\")\n\tmux.Broadcast(Event{Type: \"ServiceUpdate\", Data: \"Version 2.0\"})\n\tmux.Broadcast(Event{Type: \"AppNotification\", Data: \"New Feature Available\"})\n\ttime.Sleep(200 * time.Millisecond)\n\n\t// Demonstrate stopping a watcher multiple times (should be safe)\n\tfmt.Println(\"\\nAttempting to stop watcher 3 multiple times...\")\n\twatcher3.Stop()\n\twatcher3.Stop() // Second stop, should be safe\n\ttime.Sleep(100 * time.Millisecond)\n\n\t// Wait for all watcher goroutines to complete their reading loop\n\tfmt.Println(\"\\nWaiting for all watcher goroutines to complete...\")\n\twg.Wait()\n\n\t// 6. Properly cleaning up all resources\n\tmux.Close()\n\n\tfmt.Println(\"Event Distribution System Demo Finished.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}