{
    "task": "2938dce794be7559ba73b4e9630015020a7fa937.txt",
    "provider": "gemini",
    "model": "gemini-2.5-flash",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Plugin represents a single plugin with its metadata and activation state.\ntype Plugin struct {\n\tName           string\n\tImplements     []string\n\tactivated      bool        // Tracks if the plugin has been activated. Protected by activationOnce.\n\tactivationOnce sync.Once   // Ensures the activation logic runs only once.\n\tmanager        *PluginManager // Reference to the PluginManager to call handlers during activation.\n}\n\n// PluginManager manages the registration, activation, and retrieval of plugins,\n// along with the registration of handlers for specific plugin types.\ntype PluginManager struct {\n\tmu       sync.RWMutex                      // Protects the plugins and handlers maps.\n\tplugins  map[string]*Plugin                // Stores plugins by name.\n\thandlers map[string][]func(pluginName string) // Stores handlers by plugin type.\n}\n\n// NewPluginManager creates and returns a new, initialized PluginManager.\nfunc NewPluginManager() *PluginManager {\n\treturn &PluginManager{\n\t\tplugins:  make(map[string]*Plugin),\n\t\thandlers: make(map[string][]func(pluginName string)),\n\t}\n}\n\n// RegisterPlugin registers a new plugin with the manager.\n// If a plugin with the same name already exists, a warning is printed, and the registration is skipped.\nfunc (pm *PluginManager) RegisterPlugin(name string, implements []string) {\n\tpm.mu.Lock()\n\tdefer pm.mu.Unlock()\n\n\tif _, exists := pm.plugins[name]; exists {\n\t\tfmt.Printf(\"Warning: Plugin '%s' already registered. Skipping.\\n\", name)\n\t\treturn\n\t}\n\n\tplugin := &Plugin{\n\t\tName:       name,\n\t\tImplements: implements,\n\t\tmanager:    pm, // Provide a reference to the manager for handler invocation during activation.\n\t}\n\tpm.plugins[name] = plugin\n\tfmt.Printf(\"Registered plugin: '%s' (types: %v)\\n\", name, implements)\n}\n\n// GetPlugin retrieves a plugin by its name and verifies it implements the requiredType.\n// If the plugin has not been activated yet, it triggers a simulated activation process.\n// The activation process is guaranteed to run only once, even with concurrent calls.\nfunc (pm *PluginManager) GetPlugin(name, requiredType string) (*Plugin, error) {\n\t// Acquire a read lock to safely retrieve the plugin from the map.\n\tpm.mu.RLock()\n\tplugin, exists := pm.plugins[name]\n\tpm.mu.RUnlock()\n\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"plugin '%s' not found\", name)\n\t}\n\n\t// Check if the plugin implements the required type.\n\timplementsType := false\n\tfor _, t := range plugin.Implements {\n\t\tif t == requiredType {\n\t\t\timplementsType = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !implementsType {\n\t\treturn nil, fmt.Errorf(\"plugin '%s' does not implement type '%s'\", name, requiredType)\n\t}\n\n\t// Trigger the plugin's activation logic. This method uses sync.Once\n\t// to ensure the provided function body (the activation process)\n\t// is executed exactly once, even if called concurrently.\n\tplugin.activationOnce.Do(func() {\n\t\tfmt.Printf(\"Activating plugin: '%s'...\\n\", plugin.Name)\n\t\ttime.Sleep(50 * time.Millisecond) // Simulate I/O or initialization delay.\n\t\tplugin.activated = true\n\t\tfmt.Printf(\"Plugin '%s' activated.\\n\", plugin.Name)\n\n\t\t// After activation, iterate through all types the plugin implements\n\t\t// and call any registered handlers for those types.\n\t\t// Acquire a read lock on the manager to safely access the handlers map.\n\t\tpm.mu.RLock()\n\t\tdefer pm.mu.RUnlock()\n\n\t\tfor _, pType := range plugin.Implements {\n\t\t\tif typeHandlers, ok := pm.handlers[pType]; ok {\n\t\t\t\t// Call each handler in a new goroutine to avoid blocking the activation process\n\t\t\t\t// and to prevent potential deadlocks if handlers acquire locks.\n\t\t\t\tfor _, handler := range typeHandlers {\n\t\t\t\t\tgo handler(plugin.Name)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\treturn plugin, nil\n}\n\n// GetAllPlugins retrieves all plugins that implement the specified requiredType.\n// This method does not trigger plugin activation.\nfunc (pm *PluginManager) GetAllPlugins(requiredType string) []*Plugin {\n\tpm.mu.RLock()\n\tdefer pm.mu.RUnlock()\n\n\tvar matchingPlugins []*Plugin\n\tfor _, plugin := range pm.plugins {\n\t\tfor _, t := range plugin.Implements {\n\t\t\tif t == requiredType {\n\t\t\t\tmatchingPlugins = append(matchingPlugins, plugin)\n\t\t\t\tbreak // Found the type, move to the next plugin.\n\t\t\t}\n\t\t}\n\t}\n\treturn matchingPlugins\n}\n\n// RegisterHandler registers a callback handler for a specific plugin type.\n// After registration, the handler is immediately invoked for all plugins\n// of that type that are already activated. It will also be called for\n// any future plugins of that type upon their activation.\nfunc (pm *PluginManager) RegisterHandler(pluginType string, handler func(pluginName string)) {\n\t// 1. Add the new handler to the manager's handlers map.\n\tpm.mu.Lock()\n\tpm.handlers[pluginType] = append(pm.handlers[pluginType], handler)\n\tpm.mu.Unlock()\n\n\tfmt.Printf(\"Registered handler for type: '%s'\\n\", pluginType)\n\n\t// 2. Identify all plugins that are already activated and implement the given type.\n\tvar alreadyActivePlugins []*Plugin\n\tpm.mu.RLock() // Acquire a read lock to safely iterate the plugins map.\n\tfor _, plugin := range pm.plugins {\n\t\t// The 'activated' field is set once within plugin.activationOnce.Do.\n\t\t// Reading it after `plugin.activationOnce.Do` has completed is safe without further locks.\n\t\tif plugin.activated {\n\t\t\tfor _, pType := range plugin.Implements {\n\t\t\t\tif pType == pluginType {\n\t\t\t\t\talreadyActivePlugins = append(alreadyActivePlugins, plugin)\n\t\t\t\t\tbreak // Found the type, move to the next plugin.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpm.mu.RUnlock() // Release the read lock after collecting the relevant plugins.\n\n\t// 3. Invoke the newly registered handler for each identified already-activated plugin.\n\t// These calls are made outside the PluginManager's locks to avoid blocking\n\t// the manager for potentially slow handler executions.\n\tfor _, plugin := range alreadyActivePlugins {\n\t\tgo handler(plugin.Name)\n\t}\n}\n\nfunc main() {\n\tmanager := NewPluginManager()\n\n\t// 1. Register several plugins with different types.\n\tfmt.Println(\"--- Registering plugins ---\")\n\tmanager.RegisterPlugin(\"pluginAlpha\", []string{\"storage\", \"cache\"})\n\tmanager.RegisterPlugin(\"pluginBeta\", []string{\"network\"})\n\tmanager.RegisterPlugin(\"pluginGamma\", []string{\"logging\", \"storage\"})\n\tmanager.RegisterPlugin(\"pluginDelta\", []string{\"network\", \"data-processing\"})\n\ttime.Sleep(100 * time.Millisecond) // Allow prints to settle\n\n\t// 2. Register a handler for \"storage\" before any \"storage\" plugins are activated.\n\tfmt.Println(\"\\n--- Registering initial handler for 'storage' ---\")\n\tmanager.RegisterHandler(\"storage\", func(name string) {\n\t\tfmt.Printf(\"[Storage Handler 1] Plugin '%s' was activated.\\n\", name)\n\t})\n\ttime.Sleep(100 * time.Millisecond) // Allow prints to settle\n\n\t// 3. Concurrent access and activation attempts for various plugins.\n\tfmt.Println(\"\\n--- Concurrent activation attempts ---\")\n\tvar wg sync.WaitGroup\n\tconst concurrentAccesses = 5\n\n\t// Attempt to access \"pluginAlpha\" (storage) multiple times concurrently.\n\t// This should trigger its activation once, and then subsequent calls should get the activated plugin.\n\tfor i := 0; i < concurrentAccesses; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\t_, err := manager.GetPlugin(\"pluginAlpha\", \"storage\")\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Goroutine %d: Error getting pluginAlpha: %v\\n\", id, err)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"Goroutine %d: Successfully accessed pluginAlpha.\\n\", id)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Access \"pluginBeta\" (network) once to activate it.\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\t_, err := manager.GetPlugin(\"pluginBeta\", \"network\")\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error getting pluginBeta: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"Successfully accessed pluginBeta.\")\n\t\t}\n\t}()\n\n\twg.Wait()\n\ttime.Sleep(200 * time.Millisecond) // Give time for activation and handler goroutines to complete.\n\n\t// 4. Register another handler for \"storage\" after \"pluginAlpha\" is active.\n\t// This handler should be invoked for \"pluginAlpha\" immediately.\n\t// \"pluginGamma\" is a storage plugin but not yet activated.\n\tfmt.Println(\"\\n--- Registering a SECOND handler for 'storage' ---\")\n\tmanager.RegisterHandler(\"storage\", func(name string) {\n\t\tfmt.Printf(\"[Storage Handler 2] Plugin '%s' received new handler.\\n\", name)\n\t})\n\ttime.Sleep(200 * time.Millisecond) // Allow new handler to run for already-active plugins.\n\n\t// Now activate \"pluginGamma\" (storage) and observe both \"storage\" handlers being called.\n\tfmt.Println(\"\\n--- Accessing pluginGamma (storage) to activate it ---\")\n\t_, err := manager.GetPlugin(\"pluginGamma\", \"storage\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error getting pluginGamma: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(\"Successfully accessed pluginGamma.\")\n\t}\n\ttime.Sleep(200 * time.Millisecond) // Give time for activation and handler goroutines.\n\n\t// Register a handler for \"network\" after \"pluginBeta\" is active.\n\t// This handler should be invoked for \"pluginBeta\" immediately.\n\tfmt.Println(\"\\n--- Registering handler for 'network' ---\")\n\tmanager.RegisterHandler(\"network\", func(name string) {\n\t\tfmt.Printf(\"[Network Handler] Plugin '%s' was activated.\\n\", name)\n\t})\n\ttime.Sleep(200 * time.Millisecond) // Give time for new handler to run for already-active plugins.\n\n\t// 5. Retrieve plugins by type.\n\tfmt.Println(\"\\n--- Retrieving all 'storage' plugins ---\")\n\tstoragePlugins := manager.GetAllPlugins(\"storage\")\n\tfor _, p := range storagePlugins {\n\t\tfmt.Printf(\"Found storage plugin: '%s' (Activated: %t)\\n\", p.Name, p.activated)\n\t}\n\n\tfmt.Println(\"\\n--- Retrieving all 'network' plugins ---\")\n\tnetworkPlugins := manager.GetAllPlugins(\"network\")\n\tfor _, p := range networkPlugins {\n\t\tfmt.Printf(\"Found network plugin: '%s' (Activated: %t)\\n\", p.Name, p.activated)\n\t}\n\n\t// Activate \"pluginDelta\" (network) and observe its handler being called.\n\tfmt.Println(\"\\n--- Accessing pluginDelta (network) to activate it ---\")\n\t_, err = manager.GetPlugin(\"pluginDelta\", \"network\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error getting pluginDelta: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(\"Successfully accessed pluginDelta.\")\n\t}\n\ttime.Sleep(200 * time.Millisecond) // Give time for activation and handler goroutines.\n\n\tfmt.Println(\"\\n--- Final check of all 'network' plugins ---\")\n\tnetworkPlugins = manager.GetAllPlugins(\"network\")\n\tfor _, p := range networkPlugins {\n\t\tfmt.Printf(\"Found network plugin: '%s' (Activated: %t)\\n\", p.Name, p.activated)\n\t}\n\n\t// Demonstration of error cases:\n\tfmt.Println(\"\\n--- Attempting to get pluginAlpha as 'network' type (incorrect type) ---\")\n\t_, err = manager.GetPlugin(\"pluginAlpha\", \"network\")\n\tif err != nil {\n\t\tfmt.Printf(\"Expected error: %v\\n\", err)\n\t}\n\n\tfmt.Println(\"\\n--- Attempting to get a non-existent plugin ---\")\n\t_, err = manager.GetPlugin(\"nonExistentPlugin\", \"anyType\")\n\tif err != nil {\n\t\tfmt.Printf(\"Expected error: %v\\n\", err)\n\t}\n\n\tfmt.Println(\"\\n--- Demonstration complete ---\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}