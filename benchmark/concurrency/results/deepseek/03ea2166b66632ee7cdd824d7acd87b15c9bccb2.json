{
    "task": "03ea2166b66632ee7cdd824d7acd87b15c9bccb2.txt",
    "provider": "deepseek",
    "model": "deepseek/DeepSeek-R1-0528",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Container struct {\n\tID       string\n\tName     string\n\tRunning  bool\n\tExitCode int\n}\n\ntype ContainerManager struct {\n\tsync.RWMutex\n\tcontainers map[string]*Container\n\tnextID     int64\n}\n\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t}\n}\n\nfunc (m *ContainerManager) StartContainer(name string) string {\n\tid := atomic.AddInt64(&m.nextID, 1)\n\tidStr := fmt.Sprintf(\"%d\", id)\n\tc := &Container{\n\t\tID:      idStr,\n\t\tName:    name,\n\t\tRunning: true,\n\t\tExitCode: -1,\n\t}\n\tm.Lock()\n\tm.containers[idStr] = c\n\tm.Unlock()\n\treturn idStr\n}\n\nfunc (m *ContainerManager) StopContainer(id string, exitCode int) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\tc, exists := m.containers[id]\n\tif !exists {\n\t\treturn fmt.Errorf(\"container not found\")\n\t}\n\tif !c.Running {\n\t\treturn fmt.Errorf(\"container already stopped\")\n\t}\n\tc.Running = false\n\tc.ExitCode = exitCode\n\treturn nil\n}\n\nfunc (m *ContainerManager) ListContainers(filterExitCode *int) []string {\n\tm.RLock()\n\tdefer m.RUnlock()\n\tvar ids []string\n\tfor _, c := range m.containers {\n\t\tif filterExitCode == nil {\n\t\t\tids = append(ids, c.ID)\n\t\t} else {\n\t\t\tif !c.Running && c.ExitCode == *filterExitCode {\n\t\t\t\tids = append(ids, c.ID)\n\t\t\t}\n\t\t}\n\t}\n\treturn ids\n}\n\nfunc ptr(i int) *int {\n\treturn &i\n}\n\nfunc main() {\n\tmanager := NewContainerManager()\n\tvar wgStart, wgStop, wgListing sync.WaitGroup\n\tcontainerIDs := make([]string, 10)\n\n\tfor i := 0; i < 10; i++ {\n\t\twgStart.Add(1)\n\t\tgo func(idx int) {\n\t\t\tdefer wgStart.Done()\n\t\t\tname := fmt.Sprintf(\"container-%d\", idx)\n\t\t\tid := manager.StartContainer(name)\n\t\t\tcontainerIDs[idx] = id\n\t\t\tfmt.Printf(\"Started container: %s %s\\n\", id, name)\n\t\t}(i)\n\t}\n\twgStart.Wait()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tfor i := 0; i < 5; i++ {\n\t\twgListing.Add(1)\n\t\tgo func() {\n\t\t\tdefer wgListing.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t\tlist0 := manager.ListContainers(ptr(0))\n\t\t\t\t\tlist1 := manager.ListContainers(ptr(1))\n\t\t\t\t\tfmt.Printf(\"Listing containers with exit code 0: %v\\n\", list0)\n\t\t\t\t\tfmt.Printf(\"Listing containers with exit code 1: %v\\n\", list1)\n\t\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\twgStop.Add(1)\n\t\texitCode := 0\n\t\tif i >= 5 {\n\t\t\texitCode = 1\n\t\t}\n\t\tgo func(id string, code int) {\n\t\t\tdefer wgStop.Done()\n\t\t\tif err := manager.StopContainer(id, code); err == nil {\n\t\t\t\tfmt.Printf(\"Stopped container: %s with exit code: %d\\n\", id, code)\n\t\t\t}\n\t\t}(containerIDs[i], exitCode)\n\t}\n\n\twgStop.Wait()\n\tcancel()\n\twgListing.Wait()\n\n\tfmt.Println(\"All operations completed successfully!\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}