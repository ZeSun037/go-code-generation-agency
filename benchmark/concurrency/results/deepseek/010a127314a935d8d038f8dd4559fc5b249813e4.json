{
    "task": "010a127314a935d8d038f8dd4559fc5b249813e4.txt",
    "provider": "deepseek",
    "model": "deepseek/DeepSeek-V3-0324",
    "rounds": [
        {
            "code": "Here's the complete Go implementation for the resource monitoring system:\n\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ResourceUpdate struct {\n\tType       string\n\tIdentifier string\n\tValue      float64\n}\n\ntype ResourceMonitor struct {\n\thighPriorityQueue chan ResourceUpdate\n\tlowPriorityQueue  chan ResourceUpdate\n\tworkersWG         sync.WaitGroup\n\tshutdownChan      chan struct{}\n\treconfigChan      chan struct{}\n\tconfigMutex       sync.RWMutex\n\tactiveWorkers     int\n\tmonitoredTypes    map[string]bool\n}\n\nfunc NewResourceMonitor(initialTypes []string) *ResourceMonitor {\n\tmonitoredTypes := make(map[string]bool)\n\tfor _, t := range initialTypes {\n\t\tmonitoredTypes[t] = true\n\t}\n\n\treturn &ResourceMonitor{\n\t\thighPriorityQueue: make(chan ResourceUpdate, 1000),\n\t\tlowPriorityQueue:  make(chan ResourceUpdate, 1000),\n\t\tshutdownChan:      make(chan struct{}),\n\t\treconfigChan:      make(chan struct{}),\n\t\tmonitoredTypes:    monitoredTypes,\n\t}\n}\n\nfunc (rm *ResourceMonitor) Start(workersPerQueue int) {\n\trm.activeWorkers = workersPerQueue * 2 // for both queues\n\n\tfor i := 0; i < workersPerQueue; i++ {\n\t\trm.workersWG.Add(1)\n\t\tgo rm.worker(\"high\", rm.highPriorityQueue)\n\t}\n\n\tfor i := 0; i < workersPerQueue; i++ {\n\t\trm.workersWG.Add(1)\n\t\tgo rm.worker(\"low\", rm.lowPriorityQueue)\n\t}\n}\n\nfunc (rm *ResourceMonitor) worker(queueType string, queue chan ResourceUpdate) {\n\tdefer rm.workersWG.Done()\n\n\tfor {\n\t\tselect {\n\t\tcase <-rm.shutdownChan:\n\t\t\treturn\n\t\tcase update := <-queue:\n\t\t\trm.configMutex.RLock()\n\t\t\tshouldProcess := rm.monitoredTypes[update.Type]\n\t\t\trm.configMutex.RUnlock()\n\n\t\t\tif shouldProcess {\n\t\t\t\trm.processUpdate(update, queueType)\n\t\t\t}\n\t\tcase <-rm.reconfigChan:\n\t\t\t// Just continue with new config\n\t\t}\n\t}\n}\n\nfunc (rm *ResourceMonitor) processUpdate(update ResourceUpdate, queueType string) {\n\t// Simulate processing time\n\ttime.Sleep(time.Duration(rand.Intn(50)) * time.Millisecond)\n\tfmt.Printf(\"[%s] Processed %s %s: %.2f\\n\", queueType, update.Type, update.Identifier, update.Value)\n}\n\nfunc (rm *ResourceMonitor) SubmitUpdate(update ResourceUpdate, highPriority bool) {\n\tif highPriority {\n\t\trm.highPriorityQueue <- update\n\t} else {\n\t\trm.lowPriorityQueue <- update\n\t}\n}\n\nfunc (rm *ResourceMonitor) Reconfigure(newTypes []string) {\n\trm.reconfigChan <- struct{}{} // Signal workers to pause\n\trm.configMutex.Lock()\n\tdefer rm.configMutex.Unlock()\n\n\trm.monitoredTypes = make(map[string]bool)\n\tfor _, t := range newTypes {\n\t\trm.monitoredTypes[t] = true\n\t}\n}\n\nfunc (rm *ResourceMonitor) Shutdown() {\n\tclose(rm.shutdownChan)\n\trm.workersWG.Wait()\n\tclose(rm.highPriorityQueue)\n\tclose(rm.lowPriorityQueue)\n}\n\nfunc main() {\n\t// Initialize with some resource types\n\tinitialTypes := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\"}\n\tmonitor := NewResourceMonitor(initialTypes)\n\n\t// Start with 5 workers per queue\n\tmonitor.Start(5)\n\n\t// Simulate updates\n\tgo func() {\n\t\tresources := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\", \"GPU\", \"IO\"}\n\t\tids := []string{\"node1\", \"node2\", \"node3\"}\n\n\t\tfor i := 0; i < 50; i++ {\n\t\t\tupdate := ResourceUpdate{\n\t\t\t\tType:       resources[rand.Intn(len(resources))],\n\t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n\t\t\t\tValue:      rand.Float64() * 100,\n\t\t\t}\n\n\t\t\tmonitor.SubmitUpdate(update, rand.Float32() > 0.7) // 30% high priority\n\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\t}\n\t}()\n\n\t// Simulate reconfiguration after some time\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"\\n=== Reconfiguring to monitor only CPU and Memory ===\")\n\tmonitor.Reconfigure([]string{\"CPU\", \"Memory\"})\n\n\t// Continue sending updates\n\tgo func() {\n\t\tresources := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\"}\n\t\tids := []string{\"node1\", \"node2\", \"node3\"}\n\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tupdate := ResourceUpdate{\n\t\t\t\tType:       resources[rand.Intn(len(resources))],\n\t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n\t\t\t\tValue:      rand.Float64() * 100,\n\t\t\t}\n\n\t\t\tmonitor.SubmitUpdate(update, rand.Float32() > 0.7)\n\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\t}\n\t}()\n\n\t// Wait for all updates to be processed\n\ttime.Sleep(2 * time.Second)\n\n\t// Shutdown cleanly\n\tfmt.Println(\"\\n=== Shutting down ===\")\n\tmonitor.Shutdown()\n\tfmt.Println(\"All workers stopped\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "main.go:1:1: expected 'package', found Here"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: [.]:\n\n  > [line 0 : column 0] - importing dir \".\": main.go:1:1: expected 'package', found Here (and 1 more errors)\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 0\n  Lines  : 0\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 12:45:12 Including rules: default\n[gosec] 2025/12/01 12:45:12 Excluding rules: default\n[gosec] 2025/12/01 12:45:12 Including analyzers: default\n[gosec] 2025/12/01 12:45:12 Excluding analyzers: default\n[gosec] 2025/12/01 12:45:12 Import directory: /tmp/go_synthesis_gyvpxt1t"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\nmain.go:1:1: expected 'package', found Here\n/tmp/go_synthesis_gyvpxt1t/main.go:1:1: expected 'package', found Here\n/tmp/go_synthesis_gyvpxt1t/main.go:1:5: expected 'IDENT', found 's the complete Go implementation for the resource monitoring system:\n/tmp/go_synthesis_gyvpxt1t/main.go:1:5: rune literal not terminated\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [main.go:1:1: expected 'package', found Here /tmp/go_synthesis_gyvpxt1t/main.go:1:1: expected 'package', found Here /tmp/go_synthesis_gyvpxt1t/main.go:1:5: expected 'IDENT', found 's the complete Go implementation for the resource monitoring system: /tmp/go_synthesis_gyvpxt1t/main.go:1:5: rune literal not terminated]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "main.go:1:1: expected 'package', found Here\n/tmp/go_synthesis_gyvpxt1t/main.go:1:1: expected 'package', found Here\n/tmp/go_synthesis_gyvpxt1t/main.go:1:5: expected 'IDENT', found 's the complete Go implementation for the resource monitoring system:\n/tmp/go_synthesis_gyvpxt1t/main.go:1:5: rune literal not terminated\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "main.go:1:1: expected 'package', found Here (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ResourceUpdate struct {\n\tType       string\n\tIdentifier string\n\tValue      float64\n}\n\ntype ResourceMonitor struct {\n\thighPriorityQueue chan ResourceUpdate\n\tlowPriorityQueue  chan ResourceUpdate\n\tworkersWG         sync.WaitGroup\n\tshutdownChan      chan struct{}\n\treconfigChan      chan struct{}\n\tconfigMutex       sync.RWMutex\n\tmonitoredTypes   map[string]bool\n}\n\nfunc NewResourceMonitor(initialTypes []string) *ResourceMonitor {\n\tmonitoredTypes := make(map[string]bool)\n\tfor _, t := range initialTypes {\n\t\tmonitoredTypes[t] = true\n\t}\n\n\treturn &ResourceMonitor{\n\t\thighPriorityQueue: make(chan ResourceUpdate, 1000),\n\t\tlowPriorityQueue:  make(chan ResourceUpdate, 1000),\n\t\tshutdownChan:      make(chan struct{}),\n\t\treconfigChan:      make(chan struct{}),\n\t\tmonitoredTypes:    monitoredTypes,\n\t}\n}\n\nfunc (rm *ResourceMonitor) Start(workersPerQueue int) {\n\tfor i := 0; i < workersPerQueue; i++ {\n\t\trm.workersWG.Add(1)\n\t\tgo rm.worker(\"high\", rm.highPriorityQueue)\n\t}\n\n\tfor i := 0; i < workersPerQueue; i++ {\n\t\trm.workersWG.Add(1)\n\t\tgo rm.worker(\"low\", rm.lowPriorityQueue)\n\t}\n}\n\nfunc (rm *ResourceMonitor) worker(queueType string, queue chan ResourceUpdate) {\n\tdefer rm.workersWG.Done()\n\n\tfor {\n\t\tselect {\n\t\tcase <-rm.shutdownChan:\n\t\t\treturn\n\t\tcase update := <-queue:\n\t\t\trm.configMutex.RLock()\n\t\t\tshouldProcess := rm.monitoredTypes[update.Type]\n\t\t\trm.configMutex.RUnlock()\n\n\t\t\tif shouldProcess {\n\t\t\t\trm.processUpdate(update, queueType)\n\t\t\t}\n\t\tcase <-rm.reconfigChan:\n\t\t\t// Continue with new config\n\t\t}\n\t}\n}\n\nfunc (rm *ResourceMonitor) processUpdate(update ResourceUpdate, queueType string) {\n\ttime.Sleep(time.Duration(rand.Intn(50)) * time.Millisecond)\n\tfmt.Printf(\"[%s] Processed %s %s: %.2f\\n\", queueType, update.Type, update.Identifier, update.Value)\n}\n\nfunc (rm *ResourceMonitor) SubmitUpdate(update ResourceUpdate, highPriority bool) {\n\tif highPriority {\n\t\trm.highPriorityQueue <- update\n\t} else {\n\t\trm.lowPriorityQueue <- update\n\t}\n}\n\nfunc (rm *ResourceMonitor) Reconfigure(newTypes []string) {\n\trm.configMutex.Lock()\n\tdefer rm.configMutex.Unlock()\n\n\trm.monitoredTypes = make(map[string]bool)\n\tfor _, t := range newTypes {\n\t\trm.monitoredTypes[t] = true\n\t}\n\n\t// Signal workers to use new config\n\tfor i := 0; i < 10; i++ {\n\t\trm.reconfigChan <- struct{}{}\n\t}\n}\n\nfunc (rm *ResourceMonitor) Shutdown() {\n\tclose(rm.shutdownChan)\n\trm.workersWG.Wait()\n\tclose(rm.highPriorityQueue)\n\tclose(rm.lowPriorityQueue)\n\tclose(rm.reconfigChan)\n}\n\nfunc main() {\n\tinitialTypes := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\"}\n\tmonitor := NewResourceMonitor(initialTypes)\n\n\tmonitor.Start(5)\n\n\tgo func() {\n\t\tresources := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\", \"GPU\", \"IO\"}\n\t\tids := []string{\"node1\", \"node2\", \"node3\"}\n\n\t\tfor i := 0; i < 50; i++ {\n\t\t\tupdate := ResourceUpdate{\n\t\t\t\tType:       resources[rand.Intn(len(resources))],\n\t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n\t\t\t\tValue:      rand.Float64() * 100,\n\t\t\t}\n\n\t\t\tmonitor.SubmitUpdate(update, rand.Float32() > 0.7)\n\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"\\n=== Reconfiguring to monitor only CPU and Memory ===\")\n\tmonitor.Reconfigure([]string{\"CPU\", \"Memory\"})\n\n\tgo func() {\n\t\tresources := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\"}\n\t\tids := []string{\"node1\", \"node2\", \"node3\"}\n\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tupdate := ResourceUpdate{\n\t\t\t\tType:       resources[rand.Intn(len(resources))],\n\t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n\t\t\t\tValue:      rand.Float64() * 100,\n\t\t\t}\n\n\t\t\tmonitor.SubmitUpdate(update, rand.Float32() > 0.7)\n\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"\\n=== Shutting down ===\")\n\tmonitor.Shutdown()\n\tfmt.Println(\"All workers stopped\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:148\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    147: \t\t\tmonitor.SubmitUpdate(update, rand.Float32() > 0.7)\n  > 148: \t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n    149: \t\t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:147\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    146: \n  > 147: \t\t\tmonitor.SubmitUpdate(update, rand.Float32() > 0.7)\n    148: \t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:144\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    143: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n  > 144: \t\t\t\tValue:      rand.Float64() * 100,\n    145: \t\t\t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:143\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    142: \t\t\t\tType:       resources[rand.Intn(len(resources))],\n  > 143: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n    144: \t\t\t\tValue:      rand.Float64() * 100,\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:142\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    141: \t\t\tupdate := ResourceUpdate{\n  > 142: \t\t\t\tType:       resources[rand.Intn(len(resources))],\n    143: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:128\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    127: \t\t\tmonitor.SubmitUpdate(update, rand.Float32() > 0.7)\n  > 128: \t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n    129: \t\t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:127\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    126: \n  > 127: \t\t\tmonitor.SubmitUpdate(update, rand.Float32() > 0.7)\n    128: \t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:124\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    123: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n  > 124: \t\t\t\tValue:      rand.Float64() * 100,\n    125: \t\t\t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:123\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    122: \t\t\t\tType:       resources[rand.Intn(len(resources))],\n  > 123: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n    124: \t\t\t\tValue:      rand.Float64() * 100,\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:122\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    121: \t\t\tupdate := ResourceUpdate{\n  > 122: \t\t\t\tType:       resources[rand.Intn(len(resources))],\n    123: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_gyvpxt1t/main.go:75\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    74: func (rm *ResourceMonitor) processUpdate(update ResourceUpdate, queueType string) {\n  > 75: \ttime.Sleep(time.Duration(rand.Intn(50)) * time.Millisecond)\n    76: \tfmt.Printf(\"[%s] Processed %s %s: %.2f\\n\", queueType, update.Type, update.Identifier, update.Value)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_gyvpxt1t/main.go:143\u001b[0m] - G602 (CWE-118): slice index out of range (Confidence: HIGH, Severity: LOW)\n    142: \t\t\t\tType:       resources[rand.Intn(len(resources))],\n  > 143: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n    144: \t\t\t\tValue:      rand.Float64() * 100,\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_gyvpxt1t/main.go:142\u001b[0m] - G602 (CWE-118): slice index out of range (Confidence: HIGH, Severity: LOW)\n    141: \t\t\tupdate := ResourceUpdate{\n  > 142: \t\t\t\tType:       resources[rand.Intn(len(resources))],\n    143: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_gyvpxt1t/main.go:123\u001b[0m] - G602 (CWE-118): slice index out of range (Confidence: HIGH, Severity: LOW)\n    122: \t\t\t\tType:       resources[rand.Intn(len(resources))],\n  > 123: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n    124: \t\t\t\tValue:      rand.Float64() * 100,\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_gyvpxt1t/main.go:122\u001b[0m] - G602 (CWE-118): slice index out of range (Confidence: HIGH, Severity: LOW)\n    121: \t\t\tupdate := ResourceUpdate{\n  > 122: \t\t\t\tType:       resources[rand.Intn(len(resources))],\n    123: \t\t\t\tIdentifier: ids[rand.Intn(len(ids))],\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 156\n  Nosec  : 0\n  Issues : \u001b[1;31m15\u001b[0m\n\n[gosec] 2025/12/01 12:46:13 Including rules: default\n[gosec] 2025/12/01 12:46:13 Excluding rules: default\n[gosec] 2025/12/01 12:46:13 Including analyzers: default\n[gosec] 2025/12/01 12:46:13 Excluding analyzers: default\n[gosec] 2025/12/01 12:46:13 Import directory: /tmp/go_synthesis_gyvpxt1t\n[gosec] 2025/12/01 12:46:14 Checking package: main\n[gosec] 2025/12/01 12:46:14 Checking file: /tmp/go_synthesis_gyvpxt1t/main.go"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ResourceUpdate struct {\n\tType       string\n\tIdentifier string\n\tValue      float64\n}\n\ntype ResourceMonitor struct {\n\thighPriorityQueue chan ResourceUpdate\n\tlowPriorityQueue  chan ResourceUpdate\n\tworkersWG         sync.WaitGroup\n\tshutdownChan      chan struct{}\n\treconfigChan      chan struct{}\n\tconfigMutex       sync.RWMutex\n\tmonitoredTypes    map[string]bool\n}\n\nfunc NewResourceMonitor(initialTypes []string) *ResourceMonitor {\n\tmonitoredTypes := make(map[string]bool)\n\tfor _, t := range initialTypes {\n\t\tmonitoredTypes[t] = true\n\t}\n\n\treturn &ResourceMonitor{\n\t\thighPriorityQueue: make(chan ResourceUpdate, 1000),\n\t\tlowPriorityQueue:  make(chan ResourceUpdate, 1000),\n\t\tshutdownChan:      make(chan struct{}),\n\t\treconfigChan:      make(chan struct{}),\n\t\tmonitoredTypes:    monitoredTypes,\n\t}\n}\n\nfunc (rm *ResourceMonitor) Start(workersPerQueue int) {\n\tfor i := 0; i < workersPerQueue; i++ {\n\t\trm.workersWG.Add(1)\n\t\tgo rm.worker(\"high\", rm.highPriorityQueue)\n\t}\n\n\tfor i := 0; i < workersPerQueue; i++ {\n\t\trm.workersWG.Add(1)\n\t\tgo rm.worker(\"low\", rm.lowPriorityQueue)\n\t}\n}\n\nfunc (rm *ResourceMonitor) worker(queueType string, queue chan ResourceUpdate) {\n\tdefer rm.workersWG.Done()\n\n\tfor {\n\t\tselect {\n\t\tcase <-rm.shutdownChan:\n\t\t\treturn\n\t\tcase update := <-queue:\n\t\t\trm.configMutex.RLock()\n\t\t\tshouldProcess := rm.monitoredTypes[update.Type]\n\t\t\trm.configMutex.RUnlock()\n\n\t\t\tif shouldProcess {\n\t\t\t\trm.processUpdate(update, queueType)\n\t\t\t}\n\t\tcase <-rm.reconfigChan:\n\t\t\t// Continue with new config\n\t\t}\n\t}\n}\n\nfunc (rm *ResourceMonitor) processUpdate(update ResourceUpdate, queueType string) {\n\tdelay, _ := rand.Int(rand.Reader, big.NewInt(50))\n\ttime.Sleep(time.Duration(delay.Int64()) * time.Millisecond)\n\tfmt.Printf(\"[%s] Processed %s %s: %.2f\\n\", queueType, update.Type, update.Identifier, update.Value)\n}\n\nfunc (rm *ResourceMonitor) SubmitUpdate(update ResourceUpdate, highPriority bool) {\n\tif highPriority {\n\t\trm.highPriorityQueue <- update\n\t} else {\n\t\trm.lowPriorityQueue <- update\n\t}\n}\n\nfunc (rm *ResourceMonitor) Reconfigure(newTypes []string) {\n\trm.configMutex.Lock()\n\tdefer rm.configMutex.Unlock()\n\n\trm.monitoredTypes = make(map[string]bool)\n\tfor _, t := range newTypes {\n\t\trm.monitoredTypes[t] = true\n\t}\n\n\t// Signal workers to use new config\n\tfor i := 0; i < 10; i++ {\n\t\trm.reconfigChan <- struct{}{}\n\t}\n}\n\nfunc (rm *ResourceMonitor) Shutdown() {\n\tclose(rm.shutdownChan)\n\trm.workersWG.Wait()\n\tclose(rm.highPriorityQueue)\n\tclose(rm.lowPriorityQueue)\n\tclose(rm.reconfigChan)\n}\n\nfunc secureRandomFloat() float32 {\n\tn, _ := rand.Int(rand.Reader, big.NewInt(100))\n\treturn float32(n.Int64()) / 100.0\n}\n\nfunc secureRandomInt(max int) int {\n\tn, _ := rand.Int(rand.Reader, big.NewInt(int64(max)))\n\treturn int(n.Int64())\n}\n\nfunc main() {\n\tinitialTypes := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\"}\n\tmonitor := NewResourceMonitor(initialTypes)\n\n\tmonitor.Start(5)\n\n\tgo func() {\n\t\tresources := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\", \"GPU\", \"IO\"}\n\t\tids := []string{\"node1\", \"node2\", \"node3\"}\n\n\t\tfor i := 0; i < 50; i++ {\n\t\t\tupdate := ResourceUpdate{\n\t\t\t\tType:       resources[secureRandomInt(len(resources))],\n\t\t\t\tIdentifier: ids[secureRandomInt(len(ids))],\n\t\t\t\tValue:      float64(secureRandomInt(10000)) / 100.0,\n\t\t\t}\n\n\t\t\tmonitor.SubmitUpdate(update, secureRandomFloat() > 0.7)\n\t\t\ttime.Sleep(time.Duration(secureRandomInt(100)) * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"\\n=== Reconfiguring to monitor only CPU and Memory ===\")\n\tmonitor.Reconfigure([]string{\"CPU\", \"Memory\"})\n\n\tgo func() {\n\t\tresources := []string{\"CPU\", \"Memory\", \"Disk\", \"Network\"}\n\t\tids := []string{\"node1\", \"node2\", \"node3\"}\n\n\t\tfor i := 0; i < 30; i++ {\n\t\t\tupdate := ResourceUpdate{\n\t\t\t\tType:       resources[secureRandomInt(len(resources))],\n\t\t\t\tIdentifier: ids[secureRandomInt(len(ids))],\n\t\t\t\tValue:      float64(secureRandomInt(10000)) / 100.0,\n\t\t\t}\n\n\t\t\tmonitor.SubmitUpdate(update, secureRandomFloat() > 0.7)\n\t\t\ttime.Sleep(time.Duration(secureRandomInt(100)) * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"\\n=== Shutting down ===\")\n\tmonitor.Shutdown()\n\tfmt.Println(\"All workers stopped\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[37;40m/tmp/go_synthesis_gyvpxt1t/main.go:155\u001b[0m] - G602 (CWE-118): slice index out of range (Confidence: HIGH, Severity: LOW)\n    154: \t\t\t\tType:       resources[secureRandomInt(len(resources))],\n  > 155: \t\t\t\tIdentifier: ids[secureRandomInt(len(ids))],\n    156: \t\t\t\tValue:      float64(secureRandomInt(10000)) / 100.0,\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_gyvpxt1t/main.go:154\u001b[0m] - G602 (CWE-118): slice index out of range (Confidence: HIGH, Severity: LOW)\n    153: \t\t\tupdate := ResourceUpdate{\n  > 154: \t\t\t\tType:       resources[secureRandomInt(len(resources))],\n    155: \t\t\t\tIdentifier: ids[secureRandomInt(len(ids))],\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_gyvpxt1t/main.go:135\u001b[0m] - G602 (CWE-118): slice index out of range (Confidence: HIGH, Severity: LOW)\n    134: \t\t\t\tType:       resources[secureRandomInt(len(resources))],\n  > 135: \t\t\t\tIdentifier: ids[secureRandomInt(len(ids))],\n    136: \t\t\t\tValue:      float64(secureRandomInt(10000)) / 100.0,\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_gyvpxt1t/main.go:134\u001b[0m] - G602 (CWE-118): slice index out of range (Confidence: HIGH, Severity: LOW)\n    133: \t\t\tupdate := ResourceUpdate{\n  > 134: \t\t\t\tType:       resources[secureRandomInt(len(resources))],\n    135: \t\t\t\tIdentifier: ids[secureRandomInt(len(ids))],\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 168\n  Nosec  : 0\n  Issues : \u001b[1;31m4\u001b[0m\n\n[gosec] 2025/12/01 12:47:14 Including rules: default\n[gosec] 2025/12/01 12:47:14 Excluding rules: default\n[gosec] 2025/12/01 12:47:14 Including analyzers: default\n[gosec] 2025/12/01 12:47:14 Excluding analyzers: default\n[gosec] 2025/12/01 12:47:14 Import directory: /tmp/go_synthesis_gyvpxt1t\n[gosec] 2025/12/01 12:47:14 Checking package: main\n[gosec] 2025/12/01 12:47:14 Checking file: /tmp/go_synthesis_gyvpxt1t/main.go"
                }
            ]
        }
    ],
    "passed": false
}