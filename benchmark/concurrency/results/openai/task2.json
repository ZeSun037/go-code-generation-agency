{
    "task": "task2.txt",
    "provider": "openai",
    "model": "openai/gpt-4o-mini",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\ntype LeaseState struct {\n\ttableID      string\n\ttableName    string\n\tversion      int\n\trefCount     int32\n\tisDeleted    bool\n}\n\ntype LeaseStore struct {\n\tleases map[string]*LeaseState\n\tmu     sync.RWMutex\n}\n\nfunc NewLeaseStore() *LeaseStore {\n\treturn &LeaseStore{leases: make(map[string]*LeaseState)}\n}\n\nfunc (ls *LeaseStore) FetchLatestLease(dbID, tableName string) (*LeaseState, error) {\n\tls.mu.RLock()\n\tlease, exists := ls.leases[fmt.Sprintf(\"%s:%s\", dbID, tableName)]\n\tls.mu.RUnlock()\n\tif !exists {\n\t\treturn nil, errors.New(\"lease not found\")\n\t}\n\treturn lease, nil\n}\n\nfunc (ls *LeaseStore) AddLease(lease *LeaseState) {\n\tls.mu.Lock()\n\tls.leases[fmt.Sprintf(\"%s:%s\", lease.tableID, lease.tableName)] = lease\n\tls.mu.Unlock()\n}\n\nfunc (ls *LeaseStore) DeleteLease(dbID, tableName string) {\n\tls.mu.Lock()\n\tdelete(ls.leases, fmt.Sprintf(\"%s:%s\", dbID, tableName))\n\tls.mu.Unlock()\n}\n\ntype LeaseManager struct {\n\tleaseStore     *LeaseStore\n\ttableNameCache map[string]*LeaseState\n\tmtx            sync.RWMutex\n}\n\nfunc NewLeaseManager(leaseStore *LeaseStore) *LeaseManager {\n\treturn &LeaseManager{\n\t\tleaseStore:     leaseStore,\n\t\ttableNameCache: make(map[string]*LeaseState),\n\t}\n}\n\nfunc (lm *LeaseManager) AcquireByName(dbID, tableName string) (*LeaseState, error) {\n\tlm.mtx.RLock()\n\tcachedLease, exists := lm.tableNameCache[tableName]\n\tlm.mtx.RUnlock()\n\n\tif exists && !cachedLease.isDeleted {\n\t\tatomic.AddInt32(&cachedLease.refCount, 1)\n\t\treturn cachedLease, nil\n\t}\n\n\tlatestLease, err := lm.leaseStore.FetchLatestLease(dbID, tableName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlm.mtx.Lock()\n\tdefer lm.mtx.Unlock()\n\t\n\tif latestLease.isDeleted {\n\t\treturn nil, errors.New(\"table is deleted\")\n\t}\n\t\n\tatomic.AddInt32(&latestLease.refCount, 1)\n\tlm.tableNameCache[tableName] = latestLease\n\treturn latestLease, nil\n}\n\nfunc (lm *LeaseManager) Release(lease *LeaseState) {\n\tif atomic.AddInt32(&lease.refCount, -1) == 0 {\n\t\tlm.mtx.Lock()\n\t\tdefer lm.mtx.Unlock()\n\t\t\n\t\tif lease.isDeleted {\n\t\t\tlm.leaseStore.DeleteLease(lease.tableID, lease.tableName)\n\t\t\tdelete(lm.tableNameCache, lease.tableName)\n\t\t} else {\n\t\t\tlatestLease, _ := lm.leaseStore.FetchLatestLease(lease.tableID, lease.tableName)\n\t\t\tif latestLease != lease {\n\t\t\t\tdelete(lm.tableNameCache, lease.tableName)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (lm *LeaseManager) MarkTableDeleted(dbID, tableName string) {\n\tlm.mtx.Lock()\n\tdefer lm.mtx.Unlock()\n\n\tif lease, exists := lm.tableNameCache[tableName]; exists {\n\t\tlease.isDeleted = true\n\t}\n\tlm.leaseStore.DeleteLease(dbID, tableName)\n}\n\nfunc main() {\n\tleaseStore := NewLeaseStore()\n\tleaseManager := NewLeaseManager(leaseStore)\n\n\tlease := &LeaseState{tableID: \"1\", tableName: \"users\", version: 1, refCount: 0, isDeleted: false}\n\tleaseStore.AddLease(lease)\n\t\n\tacquiredLease, err := leaseManager.AcquireByName(\"db1\", \"users\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease for table: %s with version: %d\\n\", acquiredLease.tableName, acquiredLease.version)\n\n\tleaseManager.Release(acquiredLease)\n\tfmt.Printf(\"Released lease for table: %s\\n\", acquiredLease.tableName)\n\n\tleaseManager.MarkTableDeleted(\"db1\", \"users\")\n\t_, err = leaseManager.AcquireByName(\"db1\", \"users\")\n\tif err != nil {\n\t\tfmt.Println(\"Error acquiring deleted table:\", err)\n\t}\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}