{
    "task": "435e0b73bb99862f9dedf56a50260ff3dfef14ff.txt",
    "provider": "openai",
    "model": "openai/gpt-4o-mini",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// Event represents an event with a type and data.\ntype Event struct {\n\tType string\n\tData interface{}\n}\n\n// Watcher is an interface that defines methods for a watcher.\ntype Watcher interface {\n\tResultChan() <-chan Event\n\tStop()\n}\n\n// Mux represents a multiplexer for events.\ntype Mux struct {\n\twg      sync.WaitGroup\n\tmu      sync.Mutex\n\twatchers map[*watcher]struct{}\n}\n\n// watcher is a concrete implementation of the Watcher interface.\ntype watcher struct {\n\tid      int\n\tch      chan Event\n\tstopped bool\n\tmux     *Mux\n}\n\n// NewMux creates a new Mux.\nfunc NewMux() *Mux {\n\treturn &Mux{\n\t\twatchers: make(map[*watcher]struct{}),\n\t}\n}\n\n// Watch creates a new watcher and returns it.\nfunc (m *Mux) Watch(id int) Watcher {\n\tw := &watcher{\n\t\tid: id,\n\t\tch: make(chan Event),\n\t\tmux: m,\n\t}\n\n\tm.mu.Lock()\n\tm.watchers[w] = struct{}{}\n\tm.mu.Unlock()\n\n\treturn w\n}\n\n// ResultChan returns the read-only channel for receiving events.\nfunc (w *watcher) ResultChan() <-chan Event {\n\treturn w.ch\n}\n\n// Stop stops the watcher from receiving events.\nfunc (w *watcher) Stop() {\n\tw.mux.mu.Lock()\n\tdefer w.mux.mu.Unlock()\n\n\tif !w.stopped {\n\t\tw.stopped = true\n\t\tclose(w.ch)\n\t\tdelete(w.mux.watchers, w)\n\t}\n}\n\n// Broadcast sends an event to all active watchers.\nfunc (m *Mux) Broadcast(event Event) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tfor w := range m.watchers {\n\t\tif !w.stopped {\n\t\t\tselect {\n\t\t\tcase w.ch <- event:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n}\n\n// main demonstrates the functionality of the Mux and Watchers.\nfunc main() {\n\tmux := NewMux()\n\n\t// Starting multiple watchers\n\twatcher1 := mux.Watch(1)\n\twatcher2 := mux.Watch(2)\n\twatcher3 := mux.Watch(3)\n\n\t// Wait group to wait for all watcher processing\n\tmux.wg.Add(3)\n\n\tgo func() {\n\t\tdefer mux.wg.Done()\n\t\tfor event := range watcher1.ResultChan() {\n\t\t\tfmt.Printf(\"Watcher 1 received: %s - %v\\n\", event.Type, event.Data)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer mux.wg.Done()\n\t\tfor event := range watcher2.ResultChan() {\n\t\t\tfmt.Printf(\"Watcher 2 received: %s - %v\\n\", event.Type, event.Data)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer mux.wg.Done()\n\t\tfor event := range watcher3.ResultChan() {\n\t\t\tfmt.Printf(\"Watcher 3 received: %s - %v\\n\", event.Type, event.Data)\n\t\t}\n\t}()\n\n\t// Broadcasting events\n\tmux.Broadcast(Event{Type: \"event1\", Data: \"data1\"})\n\tmux.Broadcast(Event{Type: \"event2\", Data: \"data2\"})\n\n\t// Stopping the second watcher\n\twatcher2.Stop()\n\n\t// Broadcasting more events\n\tmux.Broadcast(Event{Type: \"event3\", Data: \"data3\"})\n\tmux.Broadcast(Event{Type: \"event4\", Data: \"data4\"})\n\n\t// Stopping the first watcher\n\twatcher1.Stop()\n\n\t// Broadcasting final events\n\tmux.Broadcast(Event{Type: \"event5\", Data: \"data5\"})\n\n\t// Wait for all goroutines to finish\n\tmux.wg.Wait()\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}