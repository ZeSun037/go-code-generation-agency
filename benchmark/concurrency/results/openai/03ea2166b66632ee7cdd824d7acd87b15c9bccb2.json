{
    "task": "03ea2166b66632ee7cdd824d7acd87b15c9bccb2.txt",
    "provider": "openai",
    "model": "openai/gpt-4o-mini",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Container struct {\n\tID        string\n\tName      string\n\tRunning   bool\n\tExitCode  int\n}\n\ntype ContainerManager struct {\n\tsync.Mutex\n\tcontainers map[string]*Container\n\tnextID     int\n}\n\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t\tnextID:     1,\n\t}\n}\n\nfunc (cm *ContainerManager) StartContainer(name string) {\n\tcm.Lock()\n\tdefer cm.Unlock()\n\tid := fmt.Sprintf(\"container-%d\", cm.nextID)\n\tcm.containers[id] = &Container{ID: id, Name: name, Running: true}\n\tcm.nextID++\n\tfmt.Printf(\"Started container: %s %s\\n\", id, name)\n}\n\nfunc (cm *ContainerManager) StopContainer(id string, exitCode int) {\n\tcm.Lock()\n\tdefer cm.Unlock()\n\tif container, exists := cm.containers[id]; exists && container.Running {\n\t\tcontainer.Running = false\n\t\tcontainer.ExitCode = exitCode\n\t\tfmt.Printf(\"Stopped container: %s with exit code: %d\\n\", id, exitCode)\n\t}\n}\n\nfunc (cm *ContainerManager) ListContainers(filterExitCode *int) []string {\n\tcm.Lock()\n\tdefer cm.Unlock()\n\tvar result []string\n\tfor _, container := range cm.containers {\n\t\tif filterExitCode == nil || (container.ExitCode == *filterExitCode && !container.Running) {\n\t\t\tresult = append(result, container.ID)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tcm := NewContainerManager()\n\tvar wg sync.WaitGroup\n\n\t// Start containers\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(name string) {\n\t\t\tdefer wg.Done()\n\t\t\tcm.StartContainer(name)\n\t\t}(fmt.Sprintf(\"test-container-%d\", i))\n\t}\n\n\ttime.Sleep(100 * time.Millisecond) // Ensure some containers are started\n\n\t// Stop containers\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(id string, exitCode int) {\n\t\t\tdefer wg.Done()\n\t\t\tcm.StopContainer(id, exitCode)\n\t\t}(fmt.Sprintf(\"container-%d\", i+1), 0)\n\t}\n\n\tfor i := 5; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(id string, exitCode int) {\n\t\t\tdefer wg.Done()\n\t\t\tcm.StopContainer(id, exitCode)\n\t\t}(fmt.Sprintf(\"container-%d\", i+1), 1)\n\t}\n\n\t// List containers concurrently\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(exitCode int) {\n\t\t\tdefer wg.Done()\n\t\t\tvar filter *int\n\t\t\tif i%2 == 0 {\n\t\t\t\tfilter = &exitCode\n\t\t\t}\n\t\t\tlisted := cm.ListContainers(filter)\n\t\t\tfmt.Printf(\"Listing containers with exit code %d: %v\\n\", exitCode, listed)\n\t\t}(i % 2)\n\t}\n\n\twg.Wait()\n\tfmt.Println(\"All operations completed successfully!\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}