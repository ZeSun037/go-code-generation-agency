{
    "task": "0d9e54367f7bf7da9670de723d533eaa920868c8.txt",
    "provider": "openai",
    "model": "openai/gpt-4o-mini",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Container struct {\n\tid          string\n\trunning     bool\n\tstopChan    chan struct{}\n\twg          sync.WaitGroup\n}\n\nfunc NewContainer(id string) *Container {\n\treturn &Container{\n\t\tid:       id,\n\t\tstopChan: make(chan struct{}),\n\t}\n}\n\nfunc (c *Container) Start() {\n\tc.running = true\n\tc.wg.Add(1)\n\tgo func() {\n\t\tdefer c.wg.Done()\n\t\tdefer func() { c.running = false }()\n\n\t\t// Simulated long-running process\n\t\tsigChan := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigChan, os.Interrupt)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-c.stopChan:\n\t\t\t\treturn\n\t\t\tcase <-sigChan:\n\t\t\t\treturn // Respond to interrupt signal\n\t\t\tdefault:\n\t\t\t\ttime.Sleep(time.Second) // Simulating work\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (c *Container) Stop() error {\n\tif !c.running {\n\t\treturn nil // Already stopped\n\t}\n\tclose(c.stopChan)\n\n\t// Wait for up to 10 seconds for the container to shut down\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tc.wg.Wait()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn nil\n\tcase <-time.After(10 * time.Second):\n\t\treturn fmt.Errorf(\"timeout: container %s did not stop\", c.id)\n\t}\n}\n\nfunc (c *Container) Kill() {\n\tif c.running {\n\t\tclose(c.stopChan)\n\t\tc.wg.Wait() // Wait for goroutine to finish\n\t}\n}\n\nfunc (c *Container) WaitTimeout(timeout time.Duration) error {\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tc.wg.Wait()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn nil\n\tcase <-time.After(timeout):\n\t\treturn fmt.Errorf(\"timeout: container %s did not finish\", c.id)\n\t}\n}\n\nfunc main() {\n\tcontainers := []*Container{\n\t\tNewContainer(\"container1\"),\n\t\tNewContainer(\"container2\"),\n\t\tNewContainer(\"container3\"),\n\t}\n\n\tfor _, c := range containers {\n\t\tc.Start()\n\t}\n\n\t// Simulate a well-behaved and a stuck process by waiting\n\ttime.Sleep(2 * time.Second)\n\tfmt.Println(\"Stopping containers...\")\n\n\tfor _, c := range containers {\n\t\tif err := c.Stop(); err != nil {\n\t\t\tfmt.Printf(\"Error stopping %s: %v\\n\", c.id, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"%s stopped gracefully\\n\", c.id)\n\t\t}\n\t}\n\n\tfor _, c := range containers {\n\t\tif err := c.WaitTimeout(5 * time.Second); err != nil {\n\t\t\tfmt.Printf(\"Error waiting for %s: %v\\n\", c.id, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"%s completed successfully\\n\", c.id)\n\t\t}\n\t}\n\n\tfmt.Println(\"All containers processed\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}