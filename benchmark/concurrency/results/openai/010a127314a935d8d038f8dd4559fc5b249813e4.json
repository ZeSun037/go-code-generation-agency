{
    "task": "010a127314a935d8d038f8dd4559fc5b249813e4.txt",
    "provider": "openai",
    "model": "openai/gpt-4o-mini",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ResourceType string\n\nconst (\n\tCPU    ResourceType = \"CPU\"\n\tMemory ResourceType = \"Memory\"\n\tDisk   ResourceType = \"Disk\"\n\tNetwork ResourceType = \"Network\"\n)\n\ntype ResourceUpdate struct {\n\tType     ResourceType\n\tIdentifier string\n\tValue    float64\n}\n\ntype ResourceMonitor struct {\n\tmu                sync.RWMutex\n\tmonitoredTypes    map[ResourceType]struct{}\n\thighPriorityQueue chan ResourceUpdate\n\tlowPriorityQueue  chan ResourceUpdate\n\twg                sync.WaitGroup\n\tshutdownChan      chan struct{}\n}\n\nfunc NewResourceMonitor() *ResourceMonitor {\n\treturn &ResourceMonitor{\n\t\tmonitoredTypes:    make(map[ResourceType]struct{}),\n\t\thighPriorityQueue: make(chan ResourceUpdate, 100),\n\t\tlowPriorityQueue:  make(chan ResourceUpdate, 100),\n\t\tshutdownChan:      make(chan struct{}),\n\t}\n}\n\nfunc (rm *ResourceMonitor) StartWorkers(workerCount int) {\n\trm.wg.Add(workerCount * 2)\n\tfor i := 0; i < workerCount; i++ {\n\t\tgo rm.processUpdates(rm.highPriorityQueue)\n\t\tgo rm.processUpdates(rm.lowPriorityQueue)\n\t}\n}\n\nfunc (rm *ResourceMonitor) processUpdates(queue chan ResourceUpdate) {\n\tdefer rm.wg.Done()\n\tfor {\n\t\tselect {\n\t\tcase update := <-queue:\n\t\t\trm.mu.RLock()\n\t\t\tif _, ok := rm.monitoredTypes[update.Type]; ok {\n\t\t\t\tfmt.Printf(\"Processing update: %+v\\n\", update)\n\t\t\t}\n\t\t\trm.mu.RUnlock()\n\t\tcase <-rm.shutdownChan:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (rm *ResourceMonitor) Reconfigure(newTypes []ResourceType) {\n\trm.mu.Lock()\n\tdefer rm.mu.Unlock()\n\trm.monitoredTypes = make(map[ResourceType]struct{})\n\tfor _, t := range newTypes {\n\t\trm.monitoredTypes[t] = struct{}{}\n\t}\n}\n\nfunc (rm *ResourceMonitor) Shutdown() {\n\tclose(rm.shutdownChan)\n\trm.wg.Wait()\n}\n\nfunc main() {\n\tmonitor := NewResourceMonitor()\n\n\t// Initial configuration and starting workers\n\tmonitor.Reconfigure([]ResourceType{CPU, Memory})\n\tmonitor.StartWorkers(5)\n\n\t// Simulating resource updates\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tmonitor.highPriorityQueue <- ResourceUpdate{Type: CPU, Identifier: \"CPU0\", Value: float64(i) * 10}\n\t\t\tmonitor.lowPriorityQueue <- ResourceUpdate{Type: Memory, Identifier: \"Memory0\", Value: float64(i) * 20}\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(500 * time.Millisecond)\n\n\t// Dynamic reconfiguration\n\tmonitor.Reconfigure([]ResourceType{Disk, Network})\n\n\t// Continue sending updates after reconfiguration\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tmonitor.highPriorityQueue <- ResourceUpdate{Type: Disk, Identifier: \"Disk0\", Value: float64(i) * 30}\n\t\t\tmonitor.lowPriorityQueue <- ResourceUpdate{Type: Network, Identifier: \"Network0\", Value: float64(i) * 40}\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(1 * time.Second)\n\n\t// Shutdown the monitor\n\tmonitor.Shutdown()\n\tfmt.Println(\"Resource Monitor stopped.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}