{
    "task": "1b1fabef8ffec606909f01c3983300fff539f214.txt",
    "provider": "openai",
    "model": "openai/gpt-4o-mini",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Token struct {\n\tUsername  string\n\tExpiresAt time.Time\n}\n\ntype TokenManager struct {\n\ttokens map[string]Token\n\tmu     sync.RWMutex\n}\n\nfunc NewTokenManager() *TokenManager {\n\tmanager := &TokenManager{\n\t\ttokens: make(map[string]Token),\n\t}\n\tgo manager.cleanupExpiredTokens()\n\treturn manager\n}\n\nfunc (tm *TokenManager) CreateToken(username string) string {\n\ttokenStr := generateRandomString(16)\n\texpiration := time.Now().Add(5 * time.Second)\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\ttm.tokens[tokenStr] = Token{Username: username, ExpiresAt: expiration}\n\treturn tokenStr\n}\n\nfunc (tm *TokenManager) RefreshToken(token string) bool {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\tif t, exists := tm.tokens[token]; exists {\n\t\tt.ExpiresAt = time.Now().Add(5 * time.Second)\n\t\ttm.tokens[token] = t\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (tm *TokenManager) ValidateToken(token string) (string, bool) {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\tif t, exists := tm.tokens[token]; exists && time.Now().Before(t.ExpiresAt) {\n\t\tt.ExpiresAt = time.Now().Add(5 * time.Second)\n\t\ttm.tokens[token] = t\n\t\treturn t.Username, true\n\t}\n\treturn \"\", false\n}\n\nfunc (tm *TokenManager) RevokeUser(username string) {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\tfor token, t := range tm.tokens {\n\t\tif t.Username == username {\n\t\t\tdelete(tm.tokens, token)\n\t\t}\n\t}\n}\n\nfunc (tm *TokenManager) cleanupExpiredTokens() {\n\tfor {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ttm.mu.Lock()\n\t\tfor token, t := range tm.tokens {\n\t\t\tif time.Now().After(t.ExpiresAt) {\n\t\t\t\tdelete(tm.tokens, token)\n\t\t\t}\n\t\t}\n\t\ttm.mu.Unlock()\n\t}\n}\n\nfunc (tm *TokenManager) Shutdown() {\n\ttm.mu.Lock()\n\tdefer tm.mu.Unlock()\n\ttm.tokens = make(map[string]Token)\n}\n\nfunc generateRandomString(n int) string {\n\tconst letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\tbytes := make([]byte, n)\n\tif _, err := rand.Read(bytes); err != nil {\n\t\treturn \"\"\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tbytes[i] = letters[int(bytes[i])%len(letters)]\n\t}\n\treturn string(bytes)\n}\n\nfunc main() {\n\tmanager := NewTokenManager()\n\twg := sync.WaitGroup{}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttoken1 := manager.CreateToken(\"user1\")\n\t\tfmt.Println(\"Created token for user1:\", token1)\n\t\ttime.Sleep(2 * time.Second)\n\t\tif username, valid := manager.ValidateToken(token1); valid {\n\t\t\tfmt.Println(\"Validated token for user1:\", username)\n\t\t}\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttoken2 := manager.CreateToken(\"user2\")\n\t\tfmt.Println(\"Created token for user2:\", token2)\n\t\ttime.Sleep(3 * time.Second)\n\t\tif username, valid := manager.ValidateToken(token2); valid {\n\t\t\tfmt.Println(\"Validated token for user2:\", username)\n\t\t}\n\t\tmanager.RevokeUser(\"user2\")\n\t\tfmt.Println(\"Revoked tokens for user2\")\n\t}()\n\n\ttime.Sleep(10 * time.Second)\n\tmanager.Shutdown()\n\twg.Wait()\n\tfmt.Println(\"Shutdown complete\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}