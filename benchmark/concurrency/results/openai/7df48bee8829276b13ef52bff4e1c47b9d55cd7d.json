{
    "task": "7df48bee8829276b13ef52bff4e1c47b9d55cd7d.txt",
    "provider": "openai",
    "model": "openai/gpt-4o-mini",
    "rounds": [
        {
            "code": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\ntype Stream struct {\n    id       int\n    dataChan chan string\n    closeChan chan error\n    mu       sync.Mutex\n}\n\nfunc NewStream(id int) *Stream {\n    return &Stream{\n        id:       id,\n        dataChan: make(chan string),\n        closeChan: make(chan error),\n    }\n}\n\nfunc (s *Stream) Read() (string, error) {\n    select {\n    case data := <-s.dataChan:\n        return data, nil\n    case err := <-s.closeChan:\n        return \"\", err\n    }\n}\n\nfunc (s *Stream) Write(data string) {\n    s.dataChan <- data\n}\n\nfunc (s *Stream) Close(err error) {\n    close(s.dataChan)\n    s.closeChan <- err\n    close(s.closeChan)\n}\n\ntype StreamManager struct {\n    streams map[int]*Stream\n    mu      sync.Mutex\n}\n\nfunc NewStreamManager() *StreamManager {\n    return &StreamManager{\n        streams: make(map[int]*Stream),\n    }\n}\n\nfunc (sm *StreamManager) NewStream(id int) (*Stream, error) {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    if _, exists := sm.streams[id]; exists {\n        return nil, fmt.Errorf(\"stream with id %d already exists\", id)\n    }\n    stream := NewStream(id)\n    sm.streams[id] = stream\n    fmt.Printf(\"Created stream with id %d\\n\", id)\n    return stream, nil\n}\n\nfunc (sm *StreamManager) CloseStream(id int, err error) {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    if stream, exists := sm.streams[id]; exists {\n        stream.Close(err)\n        delete(sm.streams, id)\n        fmt.Printf(\"Closed stream with id %d\\n\", id)\n    }\n}\n\nfunc (sm *StreamManager) Shutdown() {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    for id, stream := range sm.streams {\n        stream.Close(fmt.Errorf(\"stream manager shutdown\"))\n        delete(sm.streams, id)\n        fmt.Printf(\"Closed stream with id %d during shutdown\\n\", id)\n    }\n}\n\nfunc main() {\n    manager := NewStreamManager()\n    stream, _ := manager.NewStream(1)\n\n    var wg sync.WaitGroup\n    for i := 0; i < 5; i++ {\n        wg.Add(1)\n        go func(i int) {\n            defer wg.Done()\n            fmt.Printf(\"Goroutine %d: attempting to read from stream\\n\", i)\n            data, err := stream.Read()\n            if err != nil {\n                fmt.Printf(\"Goroutine %d: read failed with error: %s\\n\", i, err)\n            } else {\n                fmt.Printf(\"Goroutine %d: read data: %s\\n\", i, data)\n            }\n        }(i)\n        time.Sleep(100 * time.Millisecond) // simulate some read delay\n    }\n\n    time.Sleep(500 * time.Millisecond) // simulate some delay before closing\n    manager.CloseStream(1, fmt.Errorf(\"stream closed with error\"))\n\n    wg.Wait()\n    fmt.Println(\"All read operations completed\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "staticcheck",
                    "error": "main.go:13:5: field mu is unused (U1000)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\ntype Stream struct {\n    id        int\n    dataChan  chan string\n    closeChan chan error\n}\n\nfunc NewStream(id int) *Stream {\n    return &Stream{\n        id:        id,\n        dataChan: make(chan string),\n        closeChan: make(chan error),\n    }\n}\n\nfunc (s *Stream) Read() (string, error) {\n    select {\n    case data := <-s.dataChan:\n        return data, nil\n    case err := <-s.closeChan:\n        return \"\", err\n    }\n}\n\nfunc (s *Stream) Write(data string) {\n    s.dataChan <- data\n}\n\nfunc (s *Stream) Close(err error) {\n    close(s.dataChan)\n    s.closeChan <- err\n    close(s.closeChan)\n}\n\ntype StreamManager struct {\n    streams map[int]*Stream\n    mu      sync.Mutex\n}\n\nfunc NewStreamManager() *StreamManager {\n    return &StreamManager{\n        streams: make(map[int]*Stream),\n    }\n}\n\nfunc (sm *StreamManager) NewStream(id int) (*Stream, error) {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    if _, exists := sm.streams[id]; exists {\n        return nil, fmt.Errorf(\"stream with id %d already exists\", id)\n    }\n    stream := NewStream(id)\n    sm.streams[id] = stream\n    fmt.Printf(\"Created stream with id %d\\n\", id)\n    return stream, nil\n}\n\nfunc (sm *StreamManager) CloseStream(id int, err error) {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    if stream, exists := sm.streams[id]; exists {\n        stream.Close(err)\n        delete(sm.streams, id)\n        fmt.Printf(\"Closed stream with id %d\\n\", id)\n    }\n}\n\nfunc (sm *StreamManager) Shutdown() {\n    sm.mu.Lock()\n    defer sm.mu.Unlock()\n    for id, stream := range sm.streams {\n        stream.Close(fmt.Errorf(\"stream manager shutdown\"))\n        delete(sm.streams, id)\n        fmt.Printf(\"Closed stream with id %d during shutdown\\n\", id)\n    }\n}\n\nfunc main() {\n    manager := NewStreamManager()\n    stream, _ := manager.NewStream(1)\n\n    var wg sync.WaitGroup\n    for i := 0; i < 5; i++ {\n        wg.Add(1)\n        go func(i int) {\n            defer wg.Done()\n            fmt.Printf(\"Goroutine %d: attempting to read from stream\\n\", i)\n            data, err := stream.Read()\n            if err != nil {\n                fmt.Printf(\"Goroutine %d: read failed with error: %s\\n\", i, err)\n            } else {\n                fmt.Printf(\"Goroutine %d: read data: %s\\n\", i, data)\n            }\n        }(i)\n        time.Sleep(100 * time.Millisecond) // simulate some read delay\n    }\n\n    time.Sleep(500 * time.Millisecond) // simulate some delay before closing\n    manager.CloseStream(1, fmt.Errorf(\"stream closed with error\"))\n\n    wg.Wait()\n    fmt.Println(\"All read operations completed\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}