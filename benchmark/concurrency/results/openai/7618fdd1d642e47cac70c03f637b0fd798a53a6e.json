{
    "task": "7618fdd1d642e47cac70c03f637b0fd798a53a6e.txt",
    "provider": "openai",
    "model": "openai/gpt-4o-mini",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Broadcast struct {\n\tkey     string\n\trunning bool\n\tstopCh  chan struct{}\n\twg      sync.WaitGroup\n}\n\nfunc NewBroadcast(key string) *Broadcast {\n\treturn &Broadcast{\n\t\tkey:     key,\n\t\trunning: false,\n\t\tstopCh:  make(chan struct{}),\n\t}\n}\n\nfunc (b *Broadcast) Start() {\n\tif b.running {\n\t\treturn\n\t}\n\tb.running = true\n\tb.wg.Add(1)\n\tgo b.run()\n\tfmt.Printf(\"Broadcast %s started.\\n\", b.key)\n}\n\nfunc (b *Broadcast) run() {\n\tdefer b.wg.Done()\n\tfor {\n\t\tselect {\n\t\tcase <-b.stopCh:\n\t\t\tfmt.Printf(\"Broadcast %s stopping.\\n\", b.key)\n\t\t\treturn\n\t\tdefault:\n\t\t\t// Simulate processing\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tfmt.Printf(\"Broadcast %s processing event.\\n\", b.key)\n\t\t}\n\t}\n}\n\nfunc (b *Broadcast) Stop() {\n\tif !b.running {\n\t\treturn\n\t}\n\tclose(b.stopCh)\n\tb.wg.Wait()\n\tb.running = false\n\tfmt.Printf(\"Broadcast %s stopped.\\n\", b.key)\n}\n\ntype BroadcastManager struct {\n\tbroadcasts   map[string]*Broadcast\n\tupdateCh     chan string\n\tstopCh       chan struct{}\n\twg           sync.WaitGroup\n\tmu           sync.Mutex\n}\n\nfunc NewBroadcastManager() *BroadcastManager {\n\treturn &BroadcastManager{\n\t\tbroadcasts: make(map[string]*Broadcast),\n\t\tupdateCh:   make(chan string),\n\t\tstopCh:     make(chan struct{}),\n\t}\n}\n\nfunc (bm *BroadcastManager) AddBroadcast(key string) {\n\tbm.mu.Lock()\n\tdefer bm.mu.Unlock()\n\tif _, exists := bm.broadcasts[key]; exists {\n\t\tfmt.Printf(\"Broadcast %s already exists.\\n\", key)\n\t\treturn\n\t}\n\tb := NewBroadcast(key)\n\tb.Start()\n\tbm.broadcasts[key] = b\n\tfmt.Printf(\"Broadcast %s added.\\n\", key)\n}\n\nfunc (bm *BroadcastManager) RemoveBroadcast(key string) {\n\tbm.mu.Lock()\n\tdefer bm.mu.Unlock()\n\tif b, exists := bm.broadcasts[key]; exists {\n\t\tb.Stop()\n\t\tdelete(bm.broadcasts, key)\n\t\tfmt.Printf(\"Broadcast %s removed.\\n\", key)\n\t}\n}\n\nfunc (bm *BroadcastManager) Run() {\n\tbm.wg.Add(1)\n\tgo bm.coalesceLoop()\n}\n\nfunc (bm *BroadcastManager) coalesceLoop() {\n\tdefer bm.wg.Done()\n\tfor {\n\t\tselect {\n\t\tcase update, ok := <-bm.updateCh:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Printf(\"Processed update: %s\\n\", update)\n\t\tcase <-bm.stopCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (bm *BroadcastManager) Stop() {\n\tclose(bm.stopCh)\n\tclose(bm.updateCh)\n\tbm.mu.Lock()\n\tdefer bm.mu.Unlock()\n\tfor _, b := range bm.broadcasts {\n\t\tb.Stop()\n\t}\n\tbm.wg.Wait()\n\tfmt.Println(\"BroadcastManager stopped.\")\n}\n\nfunc main() {\n\tmanager := NewBroadcastManager()\n\tmanager.Run()\n\n\tmanager.AddBroadcast(\"channel1\")\n\tmanager.AddBroadcast(\"channel2\")\n\tmanager.AddBroadcast(\"channel3\")\n\n\ttime.Sleep(5 * time.Second) // simulate some time for broadcasts to work\n\n\tmanager.RemoveBroadcast(\"channel1\")\n\tmanager.RemoveBroadcast(\"channel2\")\n\n\ttime.Sleep(2 * time.Second) // allow time for removal to process\n\n\tmanager.Stop()\n\tfmt.Println(\"System shutdown successfully.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}