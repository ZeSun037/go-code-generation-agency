{
    "task": "03ea2166b66632ee7cdd824d7acd87b15c9bccb2.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Container struct {\n\tID       string\n\tName     string\n\tRunning  bool\n\tExitCode int\n}\n\ntype ContainerManager struct {\n\tmu         sync.RWMutex\n\tcontainers map[string]*Container\n\tcounter    int64\n}\n\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t}\n}\n\nfunc (cm *ContainerManager) StartContainer(name string) string {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tid := fmt.Sprintf(\"container_%d\", atomic.AddInt64(&cm.counter, 1))\n\tcontainer := &Container{\n\t\tID:       id,\n\t\tName:     name,\n\t\tRunning:  true,\n\t\tExitCode: -1,\n\t}\n\tcm.containers[id] = container\n\treturn id\n}\n\nfunc (cm *ContainerManager) StopContainer(id string, exitCode int) error {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tcontainer, exists := cm.containers[id]\n\tif !exists {\n\t\treturn fmt.Errorf(\"container %s not found\", id)\n\t}\n\n\tif !container.Running {\n\t\treturn fmt.Errorf(\"container %s is not running\", id)\n\t}\n\n\tcontainer.Running = false\n\tcontainer.ExitCode = exitCode\n\treturn nil\n}\n\nfunc (cm *ContainerManager) ListContainers(filterExitCode *int) []Container {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tvar result []Container\n\tfor _, container := range cm.containers {\n\t\tif filterExitCode != nil {\n\t\t\tif !container.Running && container.ExitCode == *filterExitCode {\n\t\t\t\tresult = append(result, *container)\n\t\t\t}\n\t\t} else {\n\t\t\tresult = append(result, *container)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc main() {\n\tmanager := NewContainerManager()\n\tvar wg sync.WaitGroup\n\n\tstartTime := time.Now()\n\n\tfmt.Println(\"Starting container process manager test...\")\n\tfmt.Println()\n\n\tcontainerIDs := make([]string, 10)\n\tidMutex := sync.Mutex{}\n\n\twg.Add(10)\n\tfor i := 0; i < 10; i++ {\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\tid := manager.StartContainer(fmt.Sprintf(\"test-container-%d\", index))\n\t\t\tidMutex.Lock()\n\t\t\tcontainerIDs[index] = id\n\t\t\tidMutex.Unlock()\n\t\t\tfmt.Printf(\"Started container: %s test-container-%d\\n\", id, index)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tfmt.Println()\n\n\twg.Add(5)\n\tfor i := 0; i < 5; i++ {\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Duration(10*index) * time.Millisecond)\n\t\t\terr := manager.StopContainer(containerIDs[index], 0)\n\t\t\tif err == nil {\n\t\t\t\tfmt.Printf(\"Stopped container: %s with exit code: 0\\n\", containerIDs[index])\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Add(5)\n\tfor i := 5; i < 10; i++ {\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Duration(10*(index-5)) * time.Millisecond)\n\t\t\terr := manager.StopContainer(containerIDs[index], 1)\n\t\t\tif err == nil {\n\t\t\t\tfmt.Printf(\"Stopped container: %s with exit code: 1\\n\", containerIDs[index])\n\t\t\t}\n\t\t}(i)\n\t}\n\n\tlistingResults := make(map[int][]string)\n\tresultMutex := sync.Mutex{}\n\n\twg.Add(5)\n\tfor i := 0; i < 5; i++ {\n\t\tgo func(exitCode int) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Duration(50*exitCode) * time.Millisecond)\n\t\t\tcontainers := manager.ListContainers(&exitCode)\n\t\t\tresultMutex.Lock()\n\t\t\tvar ids []string\n\t\t\tfor _, c := range containers {\n\t\t\t\tids = append(ids, c.ID)\n\t\t\t}\n\t\t\tlistingResults[exitCode] = ids\n\t\t\tresultMutex.Unlock()\n\t\t\tfmt.Printf(\"Listing containers with exit code %d: %v\\n\", exitCode, ids)\n\t\t}(0)\n\t}\n\n\twg.Add(5)\n\tfor i := 0; i < 5; i++ {\n\t\tgo func(exitCode int) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Duration(50*exitCode) * time.Millisecond)\n\t\t\tcontainers := manager.ListContainers(&exitCode)\n\t\t\tresultMutex.Lock()\n\t\t\tvar ids []string\n\t\t\tfor _, c := range containers {\n\t\t\t\tids = append(ids, c.ID)\n\t\t\t}\n\t\t\tlistingResults[exitCode] = ids\n\t\t\tresultMutex.Unlock()\n\t\t\tfmt.Printf(\"Listing containers with exit code %d: %v\\n\", exitCode, ids)\n\t\t}(1)\n\t}\n\n\twg.Wait()\n\n\tfmt.Println()\n\tfmt.Println(\"=== Final Results ===\")\n\tallContainers := manager.ListContainers(nil)\n\tfmt.Printf(\"Total containers: %d\\n\", len(allContainers))\n\n\texitCode0 := 0\n\tcontainers0 := manager.ListContainers(&exitCode0)\n\tfmt.Printf(\"Containers with exit code 0: %d\\n\", len(containers0))\n\tfor _, c := range containers0 {\n\t\tfmt.Printf(\"  - %s (%s)\\n\", c.ID, c.Name)\n\t}\n\n\texitCode1 := 1\n\tcontainers1 := manager.ListContainers(&exitCode1)\n\tfmt.Printf(\"Containers with exit code 1: %d\\n\", len(containers1))\n\tfor _, c := range containers1 {\n\t\tfmt.Printf(\"  - %s (%s)\\n\", c.ID, c.Name)\n\t}\n\n\telapsed := time.Since(startTime)\n\tfmt.Println()\n\tfmt.Printf(\"All operations completed successfully in %v!\\n\", elapsed)\n\tfmt.Println(\"No deadlocks detected. System is thread-safe.\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}