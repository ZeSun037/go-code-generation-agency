{
    "task": "7df48bee8829276b13ef52bff4e1c47b9d55cd7d.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Stream struct {\n\tid       int\n\tdataChan chan string\n\tcloseCh  chan struct{}\n\tcloseErr error\n\tmu       sync.RWMutex\n\tclosed   bool\n}\n\nfunc NewStream(id int) *Stream {\n\treturn &Stream{\n\t\tid:       id,\n\t\tdataChan: make(chan string, 10),\n\t\tcloseCh:  make(chan struct{}),\n\t\tclosed:   false,\n\t}\n}\n\nfunc (s *Stream) Read() (string, error) {\n\ts.mu.RLock()\n\tif s.closed {\n\t\terr := s.closeErr\n\t\ts.mu.RUnlock()\n\t\treturn \"\", err\n\t}\n\ts.mu.RUnlock()\n\n\tselect {\n\tcase data, ok := <-s.dataChan:\n\t\tif !ok {\n\t\t\ts.mu.RLock()\n\t\t\terr := s.closeErr\n\t\t\ts.mu.RUnlock()\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn data, nil\n\tcase <-s.closeCh:\n\t\ts.mu.RLock()\n\t\terr := s.closeErr\n\t\ts.mu.RUnlock()\n\t\treturn \"\", err\n\t}\n}\n\nfunc (s *Stream) Write(data string) error {\n\ts.mu.RLock()\n\tif s.closed {\n\t\ts.mu.RUnlock()\n\t\treturn fmt.Errorf(\"stream is closed\")\n\t}\n\ts.mu.RUnlock()\n\n\tselect {\n\tcase s.dataChan <- data:\n\t\treturn nil\n\tcase <-s.closeCh:\n\t\treturn fmt.Errorf(\"stream is closed\")\n\t}\n}\n\nfunc (s *Stream) Close(err error) {\n\ts.mu.Lock()\n\tif s.closed {\n\t\ts.mu.Unlock()\n\t\treturn\n\t}\n\ts.closed = true\n\ts.closeErr = err\n\ts.mu.Unlock()\n\n\tclose(s.closeCh)\n\tclose(s.dataChan)\n}\n\ntype StreamManager struct {\n\tstreams map[int]*Stream\n\tmu      sync.RWMutex\n}\n\nfunc NewStreamManager() *StreamManager {\n\treturn &StreamManager{\n\t\tstreams: make(map[int]*Stream),\n\t}\n}\n\nfunc (sm *StreamManager) NewStream(id int) (*Stream, error) {\n\tsm.mu.Lock()\n\tdefer sm.mu.Unlock()\n\n\tif _, exists := sm.streams[id]; exists {\n\t\treturn nil, fmt.Errorf(\"stream %d already exists\", id)\n\t}\n\n\tstream := NewStream(id)\n\tsm.streams[id] = stream\n\treturn stream, nil\n}\n\nfunc (sm *StreamManager) CloseStream(id int, err error) error {\n\tsm.mu.Lock()\n\tstream, exists := sm.streams[id]\n\tif !exists {\n\t\tsm.mu.Unlock()\n\t\treturn fmt.Errorf(\"stream %d not found\", id)\n\t}\n\tdelete(sm.streams, id)\n\tsm.mu.Unlock()\n\n\tstream.Close(err)\n\treturn nil\n}\n\nfunc (sm *StreamManager) Shutdown() {\n\tsm.mu.Lock()\n\tstreams := make([]*Stream, 0, len(sm.streams))\n\tfor _, stream := range sm.streams {\n\t\tstreams = append(streams, stream)\n\t}\n\tsm.streams = make(map[int]*Stream)\n\tsm.mu.Unlock()\n\n\tfor _, stream := range streams {\n\t\tstream.Close(fmt.Errorf(\"stream manager shutdown\"))\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"=== Stream Manager with Concurrent Readers ===\\n\")\n\n\tmanager := NewStreamManager()\n\n\tstream, err := manager.NewStream(1)\n\tif err != nil {\n\t\tfmt.Printf(\"FAIL: Failed to create stream: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Stream 1 created\")\n\n\tnumReaders := 5\n\tresultCh := make(chan error, numReaders)\n\tvar wg sync.WaitGroup\n\n\tfmt.Printf(\"\\nStarting %d concurrent read operations...\\n\", numReaders)\n\n\tfor i := 0; i < numReaders; i++ {\n\t\twg.Add(1)\n\t\tgo func(readerID int) {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Printf(\"  Reader %d: waiting for data...\\n\", readerID)\n\t\t\tdata, err := stream.Read()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"  Reader %d: received error: %v\\n\", readerID, err)\n\t\t\t\tresultCh <- err\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"  Reader %d: received data: %s\\n\", readerID, data)\n\t\t\t\tresultCh <- nil\n\t\t\t}\n\t\t}(i)\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\ttestErr := fmt.Errorf(\"test stream close error\")\n\tfmt.Printf(\"\\nClosing stream with error: %v\\n\", testErr)\n\tmanager.CloseStream(1, testErr)\n\n\tdone := make(chan bool, 1)\n\tgo func() {\n\t\twg.Wait()\n\t\tdone <- true\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\tfmt.Println(\"\\nAll read operations completed\")\n\tcase <-time.After(2 * time.Second):\n\t\tfmt.Println(\"\\nFAIL: Read operations did not complete within 2 seconds\")\n\t\treturn\n\t}\n\n\tallCorrect := true\n\tfor i := 0; i < numReaders; i++ {\n\t\tresult := <-resultCh\n\t\tif result != testErr {\n\t\t\tallCorrect = false\n\t\t\tfmt.Printf(\"Reader %d: expected error '%v', got '%v'\\n\", i, testErr, result)\n\t\t}\n\t}\n\n\tfmt.Println()\n\tif allCorrect {\n\t\tfmt.Println(\"PASS: All concurrent readers received the correct error\")\n\t} else {\n\t\tfmt.Println(\"FAIL: Some readers did not receive the correct error\")\n\t}\n\n\tfmt.Println(\"\\n=== Testing Shutdown ===\")\n\tmanager2 := NewStreamManager()\n\ts1, _ := manager2.NewStream(10)\n\ts2, _ := manager2.NewStream(20)\n\n\tvar wg2 sync.WaitGroup\n\tshutdownDone := make(chan bool, 2)\n\n\twg2.Add(1)\n\tgo func() {\n\t\tdefer wg2.Done()\n\t\t_, err := s1.Read()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Stream 10: read received shutdown error\")\n\t\t\tshutdownDone <- true\n\t\t}\n\t}()\n\n\twg2.Add(1)\n\tgo func() {\n\t\tdefer wg2.Done()\n\t\t_, err := s2.Read()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Stream 20: read received shutdown error\")\n\t\t\tshutdownDone <- true\n\t\t}\n\t}()\n\n\ttime.Sleep(100 * time.Millisecond)\n\tfmt.Println(\"Shutting down stream manager...\")\n\tmanager2.Shutdown()\n\n\tgo func() {\n\t\twg2.Wait()\n\t\tshutdownDone <- false\n\t\tshutdownDone <- false\n\t}()\n\n\treceived := 0\n\tfor i := 0; i < 2; i++ {\n\t\tselect {\n\t\tcase <-shutdownDone:\n\t\t\treceived++\n\t\tcase <-time.After(2 * time.Second):\n\t\t\tfmt.Println(\"FAIL: Shutdown did not unblock all readers\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tif received >= 2 {\n\t\tfmt.Println(\"PASS: All readers unblocked on shutdown\")\n\t}\n\n\tfmt.Println(\"\\n=== All Tests Complete ===\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[37;40m/tmp/go_synthesis_6hu2rore/main.go:173\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    172: \tfmt.Printf(\"\\nClosing stream with error: %v\\n\", testErr)\n  > 173: \tmanager.CloseStream(1, testErr)\n    174: \n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 259\n  Nosec  : 0\n  Issues : \u001b[1;31m1\u001b[0m\n\n[gosec] 2025/12/01 13:52:35 Including rules: default\n[gosec] 2025/12/01 13:52:35 Excluding rules: default\n[gosec] 2025/12/01 13:52:35 Including analyzers: default\n[gosec] 2025/12/01 13:52:35 Excluding analyzers: default\n[gosec] 2025/12/01 13:52:35 Import directory: /tmp/go_synthesis_6hu2rore\n[gosec] 2025/12/01 13:52:35 Checking package: main\n[gosec] 2025/12/01 13:52:35 Checking file: /tmp/go_synthesis_6hu2rore/main.go"
                },
                {
                    "verifier": "errcheck",
                    "error": "main.go:173:21:\tmanager.CloseStream(1, testErr)"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "/tmp/go_synthesis_6hu2rore/main.go:192:6: comparing with != will fail on wrapped errors. Use errors.Is to check for a specific error"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Stream struct {\n\tid       int\n\tdataChan chan string\n\tcloseCh  chan struct{}\n\tcloseErr error\n\tmu       sync.RWMutex\n\tclosed   bool\n}\n\nfunc NewStream(id int) *Stream {\n\treturn &Stream{\n\t\tid:       id,\n\t\tdataChan: make(chan string, 10),\n\t\tcloseCh:  make(chan struct{}),\n\t\tclosed:   false,\n\t}\n}\n\nfunc (s *Stream) Read() (string, error) {\n\ts.mu.RLock()\n\tif s.closed {\n\t\terr := s.closeErr\n\t\ts.mu.RUnlock()\n\t\treturn \"\", err\n\t}\n\ts.mu.RUnlock()\n\n\tselect {\n\tcase data, ok := <-s.dataChan:\n\t\tif !ok {\n\t\t\ts.mu.RLock()\n\t\t\terr := s.closeErr\n\t\t\ts.mu.RUnlock()\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn data, nil\n\tcase <-s.closeCh:\n\t\ts.mu.RLock()\n\t\terr := s.closeErr\n\t\ts.mu.RUnlock()\n\t\treturn \"\", err\n\t}\n}\n\nfunc (s *Stream) Write(data string) error {\n\ts.mu.RLock()\n\tif s.closed {\n\t\ts.mu.RUnlock()\n\t\treturn fmt.Errorf(\"stream is closed\")\n\t}\n\ts.mu.RUnlock()\n\n\tselect {\n\tcase s.dataChan <- data:\n\t\treturn nil\n\tcase <-s.closeCh:\n\t\treturn fmt.Errorf(\"stream is closed\")\n\t}\n}\n\nfunc (s *Stream) Close(err error) {\n\ts.mu.Lock()\n\tif s.closed {\n\t\ts.mu.Unlock()\n\t\treturn\n\t}\n\ts.closed = true\n\ts.closeErr = err\n\ts.mu.Unlock()\n\n\tclose(s.closeCh)\n\tclose(s.dataChan)\n}\n\ntype StreamManager struct {\n\tstreams map[int]*Stream\n\tmu      sync.RWMutex\n}\n\nfunc NewStreamManager() *StreamManager {\n\treturn &StreamManager{\n\t\tstreams: make(map[int]*Stream),\n\t}\n}\n\nfunc (sm *StreamManager) NewStream(id int) (*Stream, error) {\n\tsm.mu.Lock()\n\tdefer sm.mu.Unlock()\n\n\tif _, exists := sm.streams[id]; exists {\n\t\treturn nil, fmt.Errorf(\"stream %d already exists\", id)\n\t}\n\n\tstream := NewStream(id)\n\tsm.streams[id] = stream\n\treturn stream, nil\n}\n\nfunc (sm *StreamManager) CloseStream(id int, err error) error {\n\tsm.mu.Lock()\n\tstream, exists := sm.streams[id]\n\tif !exists {\n\t\tsm.mu.Unlock()\n\t\treturn fmt.Errorf(\"stream %d not found\", id)\n\t}\n\tdelete(sm.streams, id)\n\tsm.mu.Unlock()\n\n\tstream.Close(err)\n\treturn nil\n}\n\nfunc (sm *StreamManager) Shutdown() {\n\tsm.mu.Lock()\n\tstreams := make([]*Stream, 0, len(sm.streams))\n\tfor _, stream := range sm.streams {\n\t\tstreams = append(streams, stream)\n\t}\n\tsm.streams = make(map[int]*Stream)\n\tsm.mu.Unlock()\n\n\tfor _, stream := range streams {\n\t\tstream.Close(fmt.Errorf(\"stream manager shutdown\"))\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"=== Stream Manager with Concurrent Readers ===\\n\")\n\n\tmanager := NewStreamManager()\n\n\tstream, err := manager.NewStream(1)\n\tif err != nil {\n\t\tfmt.Printf(\"FAIL: Failed to create stream: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Stream 1 created\")\n\n\tnumReaders := 5\n\tresultCh := make(chan error, numReaders)\n\tvar wg sync.WaitGroup\n\n\tfmt.Printf(\"\\nStarting %d concurrent read operations...\\n\", numReaders)\n\n\tfor i := 0; i < numReaders; i++ {\n\t\twg.Add(1)\n\t\tgo func(readerID int) {\n\t\t\tdefer wg.Done()\n\t\t\tfmt.Printf(\"  Reader %d: waiting for data...\\n\", readerID)\n\t\t\tdata, err := stream.Read()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"  Reader %d: received error: %v\\n\", readerID, err)\n\t\t\t\tresultCh <- err\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"  Reader %d: received data: %s\\n\", readerID, data)\n\t\t\t\tresultCh <- nil\n\t\t\t}\n\t\t}(i)\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\ttestErr := fmt.Errorf(\"test stream close error\")\n\tfmt.Printf(\"\\nClosing stream with error: %v\\n\", testErr)\n\tif err := manager.CloseStream(1, testErr); err != nil {\n\t\tfmt.Printf(\"Error closing stream: %v\\n\", err)\n\t}\n\n\tdone := make(chan bool, 1)\n\tgo func() {\n\t\twg.Wait()\n\t\tdone <- true\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\tfmt.Println(\"\\nAll read operations completed\")\n\tcase <-time.After(2 * time.Second):\n\t\tfmt.Println(\"\\nFAIL: Read operations did not complete within 2 seconds\")\n\t\treturn\n\t}\n\n\tallCorrect := true\n\tfor i := 0; i < numReaders; i++ {\n\t\tresult := <-resultCh\n\t\tif !errors.Is(result, testErr) {\n\t\t\tallCorrect = false\n\t\t\tfmt.Printf(\"Reader %d: expected error '%v', got '%v'\\n\", i, testErr, result)\n\t\t}\n\t}\n\n\tfmt.Println()\n\tif allCorrect {\n\t\tfmt.Println(\"PASS: All concurrent readers received the correct error\")\n\t} else {\n\t\tfmt.Println(\"FAIL: Some readers did not receive the correct error\")\n\t}\n\n\tfmt.Println(\"\\n=== Testing Shutdown ===\")\n\tmanager2 := NewStreamManager()\n\ts1, err := manager2.NewStream(10)\n\tif err != nil {\n\t\tfmt.Printf(\"Error creating stream 10: %v\\n\", err)\n\t\treturn\n\t}\n\ts2, err := manager2.NewStream(20)\n\tif err != nil {\n\t\tfmt.Printf(\"Error creating stream 20: %v\\n\", err)\n\t\treturn\n\t}\n\n\tvar wg2 sync.WaitGroup\n\tshutdownDone := make(chan bool, 2)\n\n\twg2.Add(1)\n\tgo func() {\n\t\tdefer wg2.Done()\n\t\t_, err := s1.Read()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Stream 10: read received shutdown error\")\n\t\t\tshutdownDone <- true\n\t\t}\n\t}()\n\n\twg2.Add(1)\n\tgo func() {\n\t\tdefer wg2.Done()\n\t\t_, err := s2.Read()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Stream 20: read received shutdown error\")\n\t\t\tshutdownDone <- true\n\t\t}\n\t}()\n\n\ttime.Sleep(100 * time.Millisecond)\n\tfmt.Println(\"Shutting down stream manager...\")\n\tmanager2.Shutdown()\n\n\tgo func() {\n\t\twg2.Wait()\n\t\tshutdownDone <- false\n\t\tshutdownDone <- false\n\t}()\n\n\treceived := 0\n\tfor i := 0; i < 2; i++ {\n\t\tselect {\n\t\tcase <-shutdownDone:\n\t\t\treceived++\n\t\tcase <-time.After(2 * time.Second):\n\t\t\tfmt.Println(\"FAIL: Shutdown did not unblock all readers\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tif received >= 2 {\n\t\tfmt.Println(\"PASS: All readers unblocked on shutdown\")\n\t}\n\n\tfmt.Println(\"\\n=== All Tests Complete ===\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}