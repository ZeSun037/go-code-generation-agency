{
    "task": "47fc4a2936669af9ec8f851be845f2d4c7bcca18.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Transport represents an underlying network connection\ntype Transport struct {\n\tmu       sync.Mutex\n\terrChan  chan struct{}\n\tclosed   bool\n}\n\n// NewTransport creates a new transport\nfunc NewTransport() *Transport {\n\treturn &Transport{\n\t\terrChan: make(chan struct{}),\n\t}\n}\n\n// Error returns a channel that closes when the transport encounters an error\nfunc (t *Transport) Error() <-chan struct{} {\n\treturn t.errChan\n}\n\n// SignalError triggers a transport error\nfunc (t *Transport) SignalError() {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif !t.closed {\n\t\tclose(t.errChan)\n\t\tt.closed = true\n\t}\n}\n\n// Close closes the transport\nfunc (t *Transport) Close() {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tif !t.closed {\n\t\tclose(t.errChan)\n\t\tt.closed = true\n\t}\n}\n\n// ClientStream represents an active streaming connection\ntype ClientStream struct {\n\tid           int\n\ttransport    *Transport\n\tctx          context.Context\n\tcancel       context.CancelFunc\n\tcleanupOnce  sync.Once\n\tcleanupDone  chan struct{}\n}\n\n// NewClientStream creates a new client stream with proper lifecycle management\nfunc NewClientStream(ctx context.Context, transport *Transport, id int) *ClientStream {\n\tstreamCtx, cancel := context.WithCancel(ctx)\n\tstream := &ClientStream{\n\t\tid:          id,\n\t\ttransport:   transport,\n\t\tctx:         streamCtx,\n\t\tcancel:      cancel,\n\t\tcleanupDone: make(chan struct{}),\n\t}\n\n\tfmt.Printf(\"[Stream %d] Created\\n\", id)\n\n\t// Start background goroutine to monitor stream termination conditions\n\tgo func() {\n\t\tdefer func() {\n\t\t\tstream.cleanup()\n\t\t\tclose(stream.cleanupDone)\n\t\t}()\n\n\t\tselect {\n\t\tcase <-stream.ctx.Done():\n\t\t\tfmt.Printf(\"[Stream %d] Context cancelled\\n\", id)\n\t\tcase <-stream.transport.Error():\n\t\t\tfmt.Printf(\"[Stream %d] Transport error occurred\\n\", id)\n\t\t}\n\t}()\n\n\treturn stream\n}\n\n// cleanup performs cleanup operations for the stream\nfunc (s *ClientStream) cleanup() {\n\ts.cleanupOnce.Do(func() {\n\t\ts.cancel()\n\t\tfmt.Printf(\"[Stream %d] Cleaned up\\n\", s.id)\n\t})\n}\n\n// WaitForCleanup waits until the stream is fully cleaned up\nfunc (s *ClientStream) WaitForCleanup() {\n\t<-s.cleanupDone\n}\n\n// Cancel manually cancels the stream\nfunc (s *ClientStream) Cancel() {\n\ts.cancel()\n}\n\nfunc main() {\n\tfmt.Println(\"=== Streaming Client Connection Manager ===\\n\")\n\n\t// Create shared transport\n\ttransport := NewTransport()\n\n\tvar wg sync.WaitGroup\n\n\t// Scenario 1: Stream cancelled via context cancellation\n\tfmt.Println(\"Scenario 1: Context Cancellation\")\n\tctx1, cancel1 := context.WithCancel(context.Background())\n\tstream1 := NewClientStream(ctx1, transport, 1)\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\tfmt.Printf(\"[Main] Cancelling stream 1\\n\")\n\t\tcancel1()\n\t\tstream1.WaitForCleanup()\n\t}()\n\n\t// Scenario 2: Stream with long timeout\n\tfmt.Println(\"Scenario 2: Long-lived Stream\")\n\tctx2 := context.Background()\n\tstream2 := NewClientStream(ctx2, transport, 2)\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(1000 * time.Millisecond)\n\t\tfmt.Printf(\"[Main] Triggering transport error\\n\")\n\t\ttransport.SignalError()\n\t\tstream2.WaitForCleanup()\n\t}()\n\n\t// Scenario 3: Stream with timeout context\n\tfmt.Println(\"Scenario 3: Timeout Context\")\n\tctx3, cancel3 := context.WithTimeout(context.Background(), 800*time.Millisecond)\n\tdefer cancel3()\n\tstream3 := NewClientStream(ctx3, transport, 3)\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tstream3.WaitForCleanup()\n\t}()\n\n\t// Scenario 4: Multiple rapid streams\n\tfmt.Println(\"Scenario 4: Multiple Rapid Streams\")\n\tfor i := 4; i <= 6; i++ {\n\t\tidx := i\n\t\tctx := context.Background()\n\t\tstream := NewClientStream(ctx, transport, idx)\n\t\twg.Add(1)\n\t\tgo func(s *ClientStream) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Duration(300+idx*100) * time.Millisecond)\n\t\t\tfmt.Printf(\"[Main] Cancelling stream %d\\n\", s.id)\n\t\t\ts.Cancel()\n\t\t\ts.WaitForCleanup()\n\t\t}(stream)\n\t}\n\n\tfmt.Println()\n\n\t// Wait for all scenarios to complete\n\twg.Wait()\n\n\t// Cleanup\n\ttransport.Close()\n\n\tfmt.Println(\"\\n=== All streams cleaned up successfully ===\")\n\tfmt.Println(\"Program terminated gracefully\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}