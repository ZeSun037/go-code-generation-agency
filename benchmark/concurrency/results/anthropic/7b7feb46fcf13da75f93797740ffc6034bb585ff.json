{
    "task": "7b7feb46fcf13da75f93797740ffc6034bb585ff.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"time\"\n)\n\nfunc FetchLeaseInfo(ctx context.Context, leaseID int, url string) ([]byte, error) {\n\ttype result struct {\n\t\tdata []byte\n\t\terr  error\n\t}\n\n\tresultChan := make(chan result, 1)\n\n\tgo func() {\n\t\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\t\tif err != nil {\n\t\t\tresultChan <- result{nil, fmt.Errorf(\"failed to create request: %w\", err)}\n\t\t\treturn\n\t\t}\n\n\t\tresp, err := http.DefaultClient.Do(req)\n\t\tif err != nil {\n\t\t\tresultChan <- result{nil, fmt.Errorf(\"failed to fetch lease info: %w\", err)}\n\t\t\treturn\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tresultChan <- result{nil, fmt.Errorf(\"failed to read response body: %w\", err)}\n\t\t\treturn\n\t\t}\n\n\t\tresultChan <- result{body, nil}\n\t}()\n\n\tselect {\n\tcase res := <-resultChan:\n\t\treturn res.data, res.err\n\tcase <-ctx.Done():\n\t\treturn nil, fmt.Errorf(\"context cancelled: %w\", ctx.Err())\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"=== Lease Information Fetcher Service ===\\n\")\n\n\t// Scenario 1: Successful HTTP request\n\tfmt.Println(\"Scenario 1: Successful HTTP request\")\n\tserver1 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tfmt.Fprintf(w, `{\"leaseID\": 123, \"tenant\": \"John Doe\", \"amount\": 1500, \"startDate\": \"2024-01-01\"}`)\n\t}))\n\tdefer server1.Close()\n\n\tctx1, cancel1 := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel1()\n\n\tdata1, err1 := FetchLeaseInfo(ctx1, 123, server1.URL)\n\tif err1 != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err1)\n\t} else {\n\t\tfmt.Printf(\"Success: %s\\n\", string(data1))\n\t}\n\tfmt.Println()\n\n\t// Scenario 2: Failed HTTP request (invalid URL)\n\tfmt.Println(\"Scenario 2: Failed HTTP request (invalid URL)\")\n\tctx2, cancel2 := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel2()\n\n\tdata2, err2 := FetchLeaseInfo(ctx2, 456, \"http://invalid-domain-that-does-not-exist-12345.local\")\n\tif err2 != nil {\n\t\tfmt.Printf(\"Error (expected): %v\\n\", err2)\n\t} else {\n\t\tfmt.Printf(\"Success: %s\\n\", string(data2))\n\t}\n\tfmt.Println()\n\n\t// Scenario 3: Context cancellation before request completes\n\tfmt.Println(\"Scenario 3: Context cancellation before request completes\")\n\tserver3 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(3 * time.Second)\n\t\tfmt.Fprintf(w, `{\"leaseID\": 789, \"status\": \"active\"}`)\n\t}))\n\tdefer server3.Close()\n\n\tctx3, cancel3 := context.WithTimeout(context.Background(), 500*time.Millisecond)\n\tdefer cancel3()\n\n\tdata3, err3 := FetchLeaseInfo(ctx3, 789, server3.URL)\n\tif err3 != nil {\n\t\tfmt.Printf(\"Error (expected): %v\\n\", err3)\n\t} else {\n\t\tfmt.Printf(\"Success: %s\\n\", string(data3))\n\t}\n\tfmt.Println()\n\n\t// Scenario 4: Successful request with larger payload\n\tfmt.Println(\"Scenario 4: Successful request with larger payload\")\n\tserver4 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"leaseID\": 999,\n\t\t\t\"tenant\": \"Jane Smith\",\n\t\t\t\"property\": \"123 Main Street, Apt 4B\",\n\t\t\t\"amount\": 2500,\n\t\t\t\"currency\": \"USD\",\n\t\t\t\"startDate\": \"2023-06-15\",\n\t\t\t\"endDate\": \"2025-06-14\",\n\t\t\t\"renewalOptions\": 2,\n\t\t\t\"terms\": [\"No pets\", \"Quiet hours after 10 PM\", \"Landlord access 24 hours notice\"]\n\t\t}`)\n\t}))\n\tdefer server4.Close()\n\n\tctx4, cancel4 := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel4()\n\n\tdata4, err4 := FetchLeaseInfo(ctx4, 999, server4.URL)\n\tif err4 != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err4)\n\t} else {\n\t\tfmt.Printf(\"Success: %s\\n\", string(data4))\n\t}\n\tfmt.Println()\n\n\tfmt.Println(\"=== All scenarios completed ===\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "errcheck",
                    "error": "main.go:32:24:\tdefer resp.Body.Close()\nmain.go:58:14:\tfmt.Fprintf(w, `{\"leaseID\": 123, \"tenant\": \"John Doe\", \"amount\": 1500, \"startDate\": \"2024-01-01\"}`)\nmain.go:90:14:\tfmt.Fprintf(w, `{\"leaseID\": 789, \"status\": \"active\"}`)\nmain.go:109:14:\tfmt.Fprintf(w, `{"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"time\"\n)\n\nfunc FetchLeaseInfo(ctx context.Context, leaseID int, url string) ([]byte, error) {\n\ttype result struct {\n\t\tdata []byte\n\t\terr  error\n\t}\n\n\tresultChan := make(chan result, 1)\n\n\tgo func() {\n\t\treq, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n\t\tif err != nil {\n\t\t\tresultChan <- result{nil, fmt.Errorf(\"failed to create request: %w\", err)}\n\t\t\treturn\n\t\t}\n\n\t\tresp, err := http.DefaultClient.Do(req)\n\t\tif err != nil {\n\t\t\tresultChan <- result{nil, fmt.Errorf(\"failed to fetch lease info: %w\", err)}\n\t\t\treturn\n\t\t}\n\t\tdefer func() {\n\t\t\t_ = resp.Body.Close()\n\t\t}()\n\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tresultChan <- result{nil, fmt.Errorf(\"failed to read response body: %w\", err)}\n\t\t\treturn\n\t\t}\n\n\t\tresultChan <- result{body, nil}\n\t}()\n\n\tselect {\n\tcase res := <-resultChan:\n\t\treturn res.data, res.err\n\tcase <-ctx.Done():\n\t\treturn nil, fmt.Errorf(\"context cancelled: %w\", ctx.Err())\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"=== Lease Information Fetcher Service ===\\n\")\n\n\t// Scenario 1: Successful HTTP request\n\tfmt.Println(\"Scenario 1: Successful HTTP request\")\n\tserver1 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t_, _ = fmt.Fprintf(w, `{\"leaseID\": 123, \"tenant\": \"John Doe\", \"amount\": 1500, \"startDate\": \"2024-01-01\"}`)\n\t}))\n\tdefer server1.Close()\n\n\tctx1, cancel1 := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel1()\n\n\tdata1, err1 := FetchLeaseInfo(ctx1, 123, server1.URL)\n\tif err1 != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err1)\n\t} else {\n\t\tfmt.Printf(\"Success: %s\\n\", string(data1))\n\t}\n\tfmt.Println()\n\n\t// Scenario 2: Failed HTTP request (invalid URL)\n\tfmt.Println(\"Scenario 2: Failed HTTP request (invalid URL)\")\n\tctx2, cancel2 := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel2()\n\n\tdata2, err2 := FetchLeaseInfo(ctx2, 456, \"http://invalid-domain-that-does-not-exist-12345.local\")\n\tif err2 != nil {\n\t\tfmt.Printf(\"Error (expected): %v\\n\", err2)\n\t} else {\n\t\tfmt.Printf(\"Success: %s\\n\", string(data2))\n\t}\n\tfmt.Println()\n\n\t// Scenario 3: Context cancellation before request completes\n\tfmt.Println(\"Scenario 3: Context cancellation before request completes\")\n\tserver3 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(3 * time.Second)\n\t\t_, _ = fmt.Fprintf(w, `{\"leaseID\": 789, \"status\": \"active\"}`)\n\t}))\n\tdefer server3.Close()\n\n\tctx3, cancel3 := context.WithTimeout(context.Background(), 500*time.Millisecond)\n\tdefer cancel3()\n\n\tdata3, err3 := FetchLeaseInfo(ctx3, 789, server3.URL)\n\tif err3 != nil {\n\t\tfmt.Printf(\"Error (expected): %v\\n\", err3)\n\t} else {\n\t\tfmt.Printf(\"Success: %s\\n\", string(data3))\n\t}\n\tfmt.Println()\n\n\t// Scenario 4: Successful request with larger payload\n\tfmt.Println(\"Scenario 4: Successful request with larger payload\")\n\tserver4 := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t_, _ = fmt.Fprintf(w, `{\n\t\t\t\"leaseID\": 999,\n\t\t\t\"tenant\": \"Jane Smith\",\n\t\t\t\"property\": \"123 Main Street, Apt 4B\",\n\t\t\t\"amount\": 2500,\n\t\t\t\"currency\": \"USD\",\n\t\t\t\"startDate\": \"2023-06-15\",\n\t\t\t\"endDate\": \"2025-06-14\",\n\t\t\t\"renewalOptions\": 2,\n\t\t\t\"terms\": [\"No pets\", \"Quiet hours after 10 PM\", \"Landlord access 24 hours notice\"]\n\t\t}`)\n\t}))\n\tdefer server4.Close()\n\n\tctx4, cancel4 := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel4()\n\n\tdata4, err4 := FetchLeaseInfo(ctx4, 999, server4.URL)\n\tif err4 != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err4)\n\t} else {\n\t\tfmt.Printf(\"Success: %s\\n\", string(data4))\n\t}\n\tfmt.Println()\n\n\tfmt.Println(\"=== All scenarios completed ===\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}