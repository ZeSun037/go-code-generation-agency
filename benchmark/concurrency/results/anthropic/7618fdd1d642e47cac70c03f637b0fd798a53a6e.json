{
    "task": "7618fdd1d642e47cac70c03f637b0fd798a53a6e.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Broadcast struct {\n\tkey      string\n\tstopChan chan struct{}\n\tmu       sync.Mutex\n\tstopped  bool\n}\n\nfunc NewBroadcast(key string) *Broadcast {\n\treturn &Broadcast{\n\t\tkey:      key,\n\t\tstopChan: make(chan struct{}),\n\t\tstopped:  false,\n\t}\n}\n\nfunc (b *Broadcast) start() {\n\tgo func() {\n\t\tticker := time.NewTicker(100 * time.Millisecond)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-b.stopChan:\n\t\t\t\tb.mu.Lock()\n\t\t\t\tb.stopped = true\n\t\t\t\tb.mu.Unlock()\n\t\t\t\tfmt.Printf(\"[Broadcast %s] Stopped\\n\", b.key)\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tfmt.Printf(\"[Broadcast %s] Broadcasting event\\n\", b.key)\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (b *Broadcast) stop() {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tif !b.stopped {\n\t\tclose(b.stopChan)\n\t}\n}\n\ntype Update struct {\n\taction string\n\tkey    string\n}\n\ntype BroadcastManager struct {\n\tbroadcasts map[string]*Broadcast\n\tupdateChan chan Update\n\tmu         sync.RWMutex\n\trunning    bool\n\tstopOnce   sync.Once\n\tcoalesceDone chan struct{}\n}\n\nfunc NewBroadcastManager() *BroadcastManager {\n\treturn &BroadcastManager{\n\t\tbroadcasts:  make(map[string]*Broadcast),\n\t\tupdateChan:  make(chan Update, 10),\n\t\tcoalesceDone: make(chan struct{}),\n\t}\n}\n\nfunc (bm *BroadcastManager) Run() {\n\tbm.mu.Lock()\n\tif bm.running {\n\t\tbm.mu.Unlock()\n\t\treturn\n\t}\n\tbm.running = true\n\tbm.mu.Unlock()\n\n\tgo func() {\n\t\tdefer close(bm.coalesceDone)\n\t\tfmt.Println(\"[BroadcastManager] Coalesce loop started\")\n\n\t\tfor update := range bm.updateChan {\n\t\t\tfmt.Printf(\"[BroadcastManager] Processing update: action=%s, key=%s\\n\", update.action, update.key)\n\n\t\t\tbm.mu.Lock()\n\t\t\tswitch update.action {\n\t\t\tcase \"add\":\n\t\t\t\tif _, exists := bm.broadcasts[update.key]; !exists {\n\t\t\t\t\tbroadcast := NewBroadcast(update.key)\n\t\t\t\t\tbroadcast.start()\n\t\t\t\t\tbm.broadcasts[update.key] = broadcast\n\t\t\t\t\tfmt.Printf(\"[BroadcastManager] Added broadcast: %s\\n\", update.key)\n\t\t\t\t}\n\t\t\tcase \"remove\":\n\t\t\t\tif broadcast, exists := bm.broadcasts[update.key]; exists {\n\t\t\t\t\tbroadcast.stop()\n\t\t\t\t\tdelete(bm.broadcasts, update.key)\n\t\t\t\t\tfmt.Printf(\"[BroadcastManager] Removed broadcast: %s\\n\", update.key)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbm.mu.Unlock()\n\t\t}\n\n\t\tfmt.Println(\"[BroadcastManager] Coalesce loop finished\")\n\t}()\n}\n\nfunc (bm *BroadcastManager) AddBroadcast(key string) {\n\tbm.updateChan <- Update{action: \"add\", key: key}\n}\n\nfunc (bm *BroadcastManager) RemoveBroadcast(key string) {\n\tbm.updateChan <- Update{action: \"remove\", key: key}\n}\n\nfunc (bm *BroadcastManager) Stop() {\n\tbm.stopOnce.Do(func() {\n\t\tfmt.Println(\"[BroadcastManager] Stop requested\")\n\n\t\tbm.mu.Lock()\n\t\tbroadcasts := make([]*Broadcast, 0)\n\t\tfor _, b := range bm.broadcasts {\n\t\t\tbroadcasts = append(broadcasts, b)\n\t\t}\n\t\tbm.mu.Unlock()\n\n\t\tfor _, b := range broadcasts {\n\t\t\tb.stop()\n\t\t}\n\n\t\tbm.mu.Lock()\n\t\tbm.broadcasts = make(map[string]*Broadcast)\n\t\tbm.mu.Unlock()\n\n\t\tclose(bm.updateChan)\n\n\t\t<-bm.coalesceDone\n\t\tfmt.Println(\"[BroadcastManager] Stopped\")\n\t})\n}\n\nfunc testBroadcastSystem() bool {\n\tfmt.Println(\"\\n========== Starting Broadcast System Test ==========\")\n\tmanager := NewBroadcastManager()\n\tmanager.Run()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Adding broadcasts ---\")\n\tmanager.AddBroadcast(\"stream-1\")\n\tmanager.AddBroadcast(\"stream-2\")\n\tmanager.AddBroadcast(\"stream-3\")\n\n\ttime.Sleep(200 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Concurrent add/remove operations ---\")\n\twg := sync.WaitGroup{}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tmanager.AddBroadcast(\"stream-4\")\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tmanager.RemoveBroadcast(\"stream-1\")\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tmanager.AddBroadcast(\"stream-5\")\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tmanager.RemoveBroadcast(\"stream-2\")\n\t}()\n\n\twg.Wait()\n\ttime.Sleep(200 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Stopping system ---\")\n\tstopDone := make(chan struct{})\n\tgo func() {\n\t\tmanager.Stop()\n\t\tclose(stopDone)\n\t}()\n\n\tselect {\n\tcase <-stopDone:\n\t\tfmt.Println(\"[Test] System stopped successfully\")\n\tcase <-time.After(5 * time.Second):\n\t\tfmt.Println(\"[Test] ERROR: System stop timed out\")\n\t\treturn false\n\t}\n\n\tbm.mu.RLock()\n\tactiveBroadcasts := len(manager.broadcasts)\n\tbm.mu.RUnlock()\n\n\tif activeBroadcasts == 0 {\n\t\tfmt.Println(\"[Test] PASS: All broadcasts cleaned up\")\n\t\treturn true\n\t}\n\tfmt.Printf(\"[Test] FAIL: %d broadcasts still active\\n\", activeBroadcasts)\n\treturn false\n}\n\nfunc main() {\n\tsuccess := testBroadcastSystem()\n\tfmt.Println(\"\\n========== Test Complete ==========\")\n\tif success {\n\t\tfmt.Println(\"Result: PASS\")\n\t} else {\n\t\tfmt.Println(\"Result: FAIL\")\n\t}\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:200:2: undefined: bm\n./main.go:202:2: undefined: bm"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:200:2: undefined: bm\n./main.go:202:2: undefined: bm\n\n\nGolang errors in file: [/tmp/go_synthesis_6gfb9dhv/main.go]:\n\n  > [line 200 : column 2] - undefined: bm\n\n  > [line 202 : column 2] - undefined: bm\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 220\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 13:51:45 Including rules: default\n[gosec] 2025/12/01 13:51:45 Excluding rules: default\n[gosec] 2025/12/01 13:51:45 Including analyzers: default\n[gosec] 2025/12/01 13:51:45 Excluding analyzers: default\n[gosec] 2025/12/01 13:51:45 Import directory: /tmp/go_synthesis_6gfb9dhv\n[gosec] 2025/12/01 13:51:45 Checking package: main\n[gosec] 2025/12/01 13:51:45 Checking file: /tmp/go_synthesis_6gfb9dhv/main.go\n[gosec] 2025/12/01 13:51:46 Panic when running SSA analyzer on package: main. Panic: runtime error: invalid memory address or nil pointer dereference\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xecea40?, 0x1998730?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*Program).packageLevelMember(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/source.go:187\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000f21590, 0xc000f63c00, {0x11e2648?, 0xc000e96ca0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:820 +0x1b2b\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000f21590, 0xc000f63c00, {0x11e2648, 0xc000e96ca0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000f21590, 0xc000f63c00, {0x11e26d8?, 0xc000e947e0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:842 +0x1031\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000f21590, 0xc000f63c00, {0x11e26d8, 0xc000e947e0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).setCallFunc(0xc000f21590?, 0xc000f63c00?, 0xc000e93700?, 0xc0012880c0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1066 +0x2b6\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc000f21590, 0xc000f63c00, 0xc000e93700, 0xc0012880c0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1144 +0x2b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000f21590, 0xc000f63c00, {0x11e2708?, 0xc000e93700}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:724 +0x2105\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000f21590, 0xc000f63c00, {0x11e2708, 0xc000e93700})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000f21590, 0xc000f63c00, {0x11e2d00?, 0xc000e83450?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2699 +0xf5f\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000f21590, 0xc000f63c00, {0x11e2eb0?, 0xc000e8d350?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000f21590, 0xc000f63c00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0x74?, 0xc000f63c00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000f21590)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc0003eda80)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc00016ebd0?, 0xc000e890e0?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc0003621c0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc000c396c0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc0003ec980, 0xc000c396c0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc0003ec980, {0x0, 0x0, 0x0}, {0xc000052d50, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 13:51:46 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_6gfb9dhv/main.go:200:2: undefined: bm\n/tmp/go_synthesis_6gfb9dhv/main.go:202:2: undefined: bm\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:200:2: undefined: bm\n./main.go:202:2: undefined: bm /tmp/go_synthesis_6gfb9dhv/main.go:200:2: undefined: bm /tmp/go_synthesis_6gfb9dhv/main.go:202:2: undefined: bm]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:200:2: undefined: bm\n./main.go:202:2: undefined: bm\n/tmp/go_synthesis_6gfb9dhv/main.go:200:2: undefined: bm\n/tmp/go_synthesis_6gfb9dhv/main.go:202:2: undefined: bm\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:200:2: undefined: bm\n./main.go:202:2: undefined: bm (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Broadcast struct {\n\tkey      string\n\tstopChan chan struct{}\n\tmu       sync.Mutex\n\tstopped  bool\n}\n\nfunc NewBroadcast(key string) *Broadcast {\n\treturn &Broadcast{\n\t\tkey:      key,\n\t\tstopChan: make(chan struct{}),\n\t\tstopped:  false,\n\t}\n}\n\nfunc (b *Broadcast) start() {\n\tgo func() {\n\t\tticker := time.NewTicker(100 * time.Millisecond)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-b.stopChan:\n\t\t\t\tb.mu.Lock()\n\t\t\t\tb.stopped = true\n\t\t\t\tb.mu.Unlock()\n\t\t\t\tfmt.Printf(\"[Broadcast %s] Stopped\\n\", b.key)\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tfmt.Printf(\"[Broadcast %s] Broadcasting event\\n\", b.key)\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (b *Broadcast) stop() {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tif !b.stopped {\n\t\tclose(b.stopChan)\n\t}\n}\n\ntype Update struct {\n\taction string\n\tkey    string\n}\n\ntype BroadcastManager struct {\n\tbroadcasts  map[string]*Broadcast\n\tupdateChan  chan Update\n\tmu          sync.RWMutex\n\trunning     bool\n\tstopOnce    sync.Once\n\tcoalesceDone chan struct{}\n}\n\nfunc NewBroadcastManager() *BroadcastManager {\n\treturn &BroadcastManager{\n\t\tbroadcasts:   make(map[string]*Broadcast),\n\t\tupdateChan:   make(chan Update, 10),\n\t\tcoalesceDone: make(chan struct{}),\n\t}\n}\n\nfunc (bm *BroadcastManager) Run() {\n\tbm.mu.Lock()\n\tif bm.running {\n\t\tbm.mu.Unlock()\n\t\treturn\n\t}\n\tbm.running = true\n\tbm.mu.Unlock()\n\n\tgo func() {\n\t\tdefer close(bm.coalesceDone)\n\t\tfmt.Println(\"[BroadcastManager] Coalesce loop started\")\n\n\t\tfor update := range bm.updateChan {\n\t\t\tfmt.Printf(\"[BroadcastManager] Processing update: action=%s, key=%s\\n\", update.action, update.key)\n\n\t\t\tbm.mu.Lock()\n\t\t\tswitch update.action {\n\t\t\tcase \"add\":\n\t\t\t\tif _, exists := bm.broadcasts[update.key]; !exists {\n\t\t\t\t\tbroadcast := NewBroadcast(update.key)\n\t\t\t\t\tbroadcast.start()\n\t\t\t\t\tbm.broadcasts[update.key] = broadcast\n\t\t\t\t\tfmt.Printf(\"[BroadcastManager] Added broadcast: %s\\n\", update.key)\n\t\t\t\t}\n\t\t\tcase \"remove\":\n\t\t\t\tif broadcast, exists := bm.broadcasts[update.key]; exists {\n\t\t\t\t\tbroadcast.stop()\n\t\t\t\t\tdelete(bm.broadcasts, update.key)\n\t\t\t\t\tfmt.Printf(\"[BroadcastManager] Removed broadcast: %s\\n\", update.key)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbm.mu.Unlock()\n\t\t}\n\n\t\tfmt.Println(\"[BroadcastManager] Coalesce loop finished\")\n\t}()\n}\n\nfunc (bm *BroadcastManager) AddBroadcast(key string) {\n\tbm.updateChan <- Update{action: \"add\", key: key}\n}\n\nfunc (bm *BroadcastManager) RemoveBroadcast(key string) {\n\tbm.updateChan <- Update{action: \"remove\", key: key}\n}\n\nfunc (bm *BroadcastManager) Stop() {\n\tbm.stopOnce.Do(func() {\n\t\tfmt.Println(\"[BroadcastManager] Stop requested\")\n\n\t\tbm.mu.Lock()\n\t\tbroadcasts := make([]*Broadcast, 0)\n\t\tfor _, b := range bm.broadcasts {\n\t\t\tbroadcasts = append(broadcasts, b)\n\t\t}\n\t\tbm.mu.Unlock()\n\n\t\tfor _, b := range broadcasts {\n\t\t\tb.stop()\n\t\t}\n\n\t\tbm.mu.Lock()\n\t\tbm.broadcasts = make(map[string]*Broadcast)\n\t\tbm.mu.Unlock()\n\n\t\tclose(bm.updateChan)\n\n\t\t<-bm.coalesceDone\n\t\tfmt.Println(\"[BroadcastManager] Stopped\")\n\t})\n}\n\nfunc testBroadcastSystem() bool {\n\tfmt.Println(\"\\n========== Starting Broadcast System Test ==========\")\n\tmanager := NewBroadcastManager()\n\tmanager.Run()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Adding broadcasts ---\")\n\tmanager.AddBroadcast(\"stream-1\")\n\tmanager.AddBroadcast(\"stream-2\")\n\tmanager.AddBroadcast(\"stream-3\")\n\n\ttime.Sleep(200 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Concurrent add/remove operations ---\")\n\twg := sync.WaitGroup{}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tmanager.AddBroadcast(\"stream-4\")\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tmanager.RemoveBroadcast(\"stream-1\")\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tmanager.AddBroadcast(\"stream-5\")\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tmanager.RemoveBroadcast(\"stream-2\")\n\t}()\n\n\twg.Wait()\n\ttime.Sleep(200 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Stopping system ---\")\n\tstopDone := make(chan struct{})\n\tgo func() {\n\t\tmanager.Stop()\n\t\tclose(stopDone)\n\t}()\n\n\tselect {\n\tcase <-stopDone:\n\t\tfmt.Println(\"[Test] System stopped successfully\")\n\tcase <-time.After(5 * time.Second):\n\t\tfmt.Println(\"[Test] ERROR: System stop timed out\")\n\t\treturn false\n\t}\n\n\tmanager.mu.RLock()\n\tactiveBroadcasts := len(manager.broadcasts)\n\tmanager.mu.RUnlock()\n\n\tif activeBroadcasts == 0 {\n\t\tfmt.Println(\"[Test] PASS: All broadcasts cleaned up\")\n\t\treturn true\n\t}\n\tfmt.Printf(\"[Test] FAIL: %d broadcasts still active\\n\", activeBroadcasts)\n\treturn false\n}\n\nfunc main() {\n\tsuccess := testBroadcastSystem()\n\tfmt.Println(\"\\n========== Test Complete ==========\")\n\tif success {\n\t\tfmt.Println(\"Result: PASS\")\n\t} else {\n\t\tfmt.Println(\"Result: FAIL\")\n\t}\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}