{
    "task": "22797c718504868665b78f143a595138cb521edf.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Session struct {\n\tID string\n}\n\ntype LockRequest struct {\n\tsessionID string\n\tdone      chan bool\n}\n\ntype LockManager struct {\n\tlocks map[string]*ResourceLock\n\tmu    sync.Mutex\n}\n\ntype ResourceLock struct {\n\tresourceName string\n\tcurrentOwner string\n\tqueue        []LockRequest\n\tmu            sync.Mutex\n\tcond          *sync.Cond\n}\n\nfunc NewLockManager() *LockManager {\n\treturn &LockManager{\n\t\tlocks: make(map[string]*ResourceLock),\n\t}\n}\n\nfunc (lm *LockManager) getResourceLock(resourceName string) *ResourceLock {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tif rl, exists := lm.locks[resourceName]; exists {\n\t\treturn rl\n\t}\n\n\trl := &ResourceLock{\n\t\tresourceName: resourceName,\n\t\tcurrentOwner: \"\",\n\t\tqueue:        []LockRequest{},\n\t}\n\trl.cond = sync.NewCond(&rl.mu)\n\tlm.locks[resourceName] = rl\n\treturn rl\n}\n\nfunc (rl *ResourceLock) AcquireLock(sessionID string) {\n\trl.mu.Lock()\n\tdefer rl.mu.Unlock()\n\n\tdone := make(chan bool, 1)\n\trequest := LockRequest{\n\t\tsessionID: sessionID,\n\t\tdone:      done,\n\t}\n\n\trl.queue = append(rl.queue, request)\n\tfmt.Printf(\"[REQUEST] Session %s requesting lock on %s (queue length: %d)\\n\", sessionID, rl.resourceName, len(rl.queue))\n\n\tfor rl.currentOwner != \"\" && rl.currentOwner != sessionID {\n\t\trl.cond.Wait()\n\t}\n\n\tif rl.currentOwner == sessionID {\n\t\tfmt.Printf(\"[ACQUIRED] Session %s already owns lock on %s\\n\", sessionID, rl.resourceName)\n\t\treturn\n\t}\n\n\tif len(rl.queue) > 0 && rl.queue[0].sessionID == sessionID {\n\t\trl.currentOwner = sessionID\n\t\trl.queue = rl.queue[1:]\n\t\tfmt.Printf(\"[ACQUIRED] Session %s acquired lock on %s\\n\", sessionID, rl.resourceName)\n\t}\n}\n\nfunc (rl *ResourceLock) ReleaseLock(sessionID string) {\n\trl.mu.Lock()\n\tdefer rl.mu.Unlock()\n\n\tif rl.currentOwner != sessionID {\n\t\tfmt.Printf(\"[ERROR] Session %s attempted to release lock on %s but doesn't own it\\n\", sessionID, rl.resourceName)\n\t\treturn\n\t}\n\n\trl.currentOwner = \"\"\n\tfmt.Printf(\"[RELEASED] Session %s released lock on %s\\n\", sessionID, rl.resourceName)\n\n\trl.cond.Broadcast()\n}\n\nfunc (lm *LockManager) AcquireLock(session *Session, resourceName string) {\n\trl := lm.getResourceLock(resourceName)\n\trl.AcquireLock(session.ID)\n}\n\nfunc (lm *LockManager) ReleaseLock(session *Session, resourceName string) {\n\trl := lm.getResourceLock(resourceName)\n\trl.ReleaseLock(session.ID)\n}\n\nfunc simulateClient(clientID int, lockManager *LockManager, resourceName string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\n\tsessionID := fmt.Sprintf(\"session-%d\", clientID)\n\tsession := &Session{ID: sessionID}\n\n\tfmt.Printf(\"[CLIENT-%d] Started with %s\\n\", clientID, sessionID)\n\n\tfmt.Printf(\"[CLIENT-%d] Attempting to acquire lock\\n\", clientID)\n\tlockManager.AcquireLock(session, resourceName)\n\n\tfmt.Printf(\"[CLIENT-%d] Holding lock, doing work...\\n\", clientID)\n\ttime.Sleep(time.Duration(500+clientID*100) * time.Millisecond)\n\n\tfmt.Printf(\"[CLIENT-%d] Work completed, releasing lock\\n\", clientID)\n\tlockManager.ReleaseLock(session, resourceName)\n\n\tfmt.Printf(\"[CLIENT-%d] Finished\\n\", clientID)\n}\n\nfunc simulateMultipleAcquisitions(clientID int, lockManager *LockManager, resourceName string, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\n\tsessionID := fmt.Sprintf(\"multi-session-%d\", clientID)\n\tsession := &Session{ID: sessionID}\n\n\tfmt.Printf(\"[MULTI-CLIENT-%d] Started with %s\\n\", clientID, sessionID)\n\n\tfor i := 1; i <= 3; i++ {\n\t\tfmt.Printf(\"[MULTI-CLIENT-%d] Acquisition attempt #%d\\n\", clientID, i)\n\t\tlockManager.AcquireLock(session, resourceName)\n\n\t\tfmt.Printf(\"[MULTI-CLIENT-%d] Holding lock (attempt #%d), doing work...\\n\", clientID, i)\n\t\ttime.Sleep(300 * time.Millisecond)\n\n\t\tfmt.Printf(\"[MULTI-CLIENT-%d] Releasing lock (attempt #%d)\\n\", clientID, i)\n\t\tlockManager.ReleaseLock(session, resourceName)\n\n\t\tif i < 3 {\n\t\t\ttime.Sleep(200 * time.Millisecond)\n\t\t}\n\t}\n\n\tfmt.Printf(\"[MULTI-CLIENT-%d] Finished all acquisitions\\n\", clientID)\n}\n\nfunc main() {\n\tfmt.Println(\"=== Distributed Lock Manager System ===\\n\")\n\n\tlockManager := NewLockManager()\n\tvar wg sync.WaitGroup\n\n\tfmt.Println(\"--- Scenario 1: Multiple Clients Competing for Same Lock ---\")\n\tnumClients := 5\n\tresourceName := \"resource-1\"\n\n\tfor i := 1; i <= numClients; i++ {\n\t\twg.Add(1)\n\t\tgo simulateClient(i, lockManager, resourceName, &wg)\n\t}\n\n\twg.Wait()\n\n\tfmt.Println(\"\\n--- Scenario 2: Single Client Multiple Acquisitions ---\")\n\tnumMultiClients := 3\n\n\tfor i := 1; i <= numMultiClients; i++ {\n\t\twg.Add(1)\n\t\tgo simulateMultipleAcquisitions(i, lockManager, \"resource-2\", &wg)\n\t}\n\n\twg.Wait()\n\n\tfmt.Println(\"\\n--- Scenario 3: Multiple Resources ---\")\n\tnumClientsPerResource := 3\n\tresources := []string{\"resource-A\", \"resource-B\", \"resource-C\"}\n\n\tfor _, resource := range resources {\n\t\tfor i := 1; i <= numClientsPerResource; i++ {\n\t\t\twg.Add(1)\n\t\t\tclientID := len(resources)*numClientsPerResource + i\n\t\t\tgo simulateClient(clientID, lockManager, resource, &wg)\n\t\t}\n\t}\n\n\twg.Wait()\n\n\tfmt.Println(\"\\n=== All Scenarios Completed Successfully ===\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}