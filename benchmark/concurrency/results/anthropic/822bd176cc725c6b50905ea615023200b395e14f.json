{
    "task": "822bd176cc725c6b50905ea615023200b395e14f.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc ProcessDataBatch(ctx context.Context, items []int, maxWorkers int) ([]int, error) {\n\tif maxWorkers <= 0 {\n\t\tmaxWorkers = 1\n\t}\n\n\tworkQueue := make(chan int, len(items))\n\tresultsChannel := make(chan int, len(items))\n\tvar wg sync.WaitGroup\n\tvar resultsMutex sync.Mutex\n\tvar results []int\n\tcollectorDone := make(chan struct{})\n\tvar collectorErr error\n\n\twg.Add(maxWorkers)\n\tfor i := 0; i < maxWorkers; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase item, ok := <-workQueue:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\n\t\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\t\tprocessed := item * 2\n\n\t\t\t\t\tselect {\n\t\t\t\t\tcase resultsChannel <- processed:\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tgo func() {\n\t\tfor item := range items {\n\t\t\tselect {\n\t\t\tcase workQueue <- item:\n\t\t\tcase <-ctx.Done():\n\t\t\t\tcollectorErr = ctx.Err()\n\t\t\t\tclose(collectorDone)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tclose(workQueue)\n\t}()\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(resultsChannel)\n\t\tcollectorDone <- struct{}{}\n\t}()\n\n\tgo func() {\n\t\tfor result := range resultsChannel {\n\t\t\tresultsMutex.Lock()\n\t\t\tresults = append(results, result)\n\t\t\tresultsMutex.Unlock()\n\t\t}\n\t}()\n\n\t<-collectorDone\n\n\tif collectorErr != nil {\n\t\treturn nil, collectorErr\n\t}\n\n\tif err := ctx.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tresultsMutex.Lock()\n\tdefer resultsMutex.Unlock()\n\treturn results, nil\n}\n\nfunc main() {\n\tfmt.Println(\"=== Test 1: Successful batch processing ===\")\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\n\titems := make([]int, 100)\n\tfor i := range items {\n\t\titems[i] = i\n\t}\n\n\tstart := time.Now()\n\tresults, err := ProcessDataBatch(ctx, items, 5)\n\telapsed := time.Since(start)\n\n\tif err != nil {\n\t\tlog.Fatalf(\"Error: %v\", err)\n\t}\n\tfmt.Printf(\"Processed %d items in %v\\n\", len(results), elapsed)\n\tfmt.Printf(\"First 5 results: %v\\n\", results[:5])\n\tfmt.Printf(\"Last 5 results: %v\\n\", results[len(results)-5:])\n\n\tallCorrect := true\n\tfor i, result := range results {\n\t\tif result != i*2 {\n\t\t\tallCorrect = false\n\t\t\tbreak\n\t\t}\n\t}\n\tfmt.Printf(\"All results correct: %v\\n\\n\", allCorrect)\n\n\tfmt.Println(\"=== Test 2: Early cancellation ===\")\n\tctx2, cancel2 := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfmt.Println(\"Cancelling context...\")\n\t\tcancel2()\n\t}()\n\n\tlargeItems := make([]int, 1000)\n\tfor i := range largeItems {\n\t\tlargeItems[i] = i\n\t}\n\n\tstart2 := time.Now()\n\tresults2, err2 := ProcessDataBatch(ctx2, largeItems, 5)\n\telapsed2 := time.Since(start2)\n\n\tif err2 != nil {\n\t\tfmt.Printf(\"Expected cancellation error: %v\\n\", err2)\n\t}\n\tfmt.Printf(\"Processed %d items before cancellation in %v\\n\", len(results2), elapsed2)\n\n\tfmt.Println(\"\\n=== Test 3: Single worker ===\")\n\tctx3, cancel3 := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer cancel3()\n\n\tsingleWorkerItems := make([]int, 10)\n\tfor i := range singleWorkerItems {\n\t\tsingleWorkerItems[i] = i\n\t}\n\n\tresults3, err3 := ProcessDataBatch(ctx3, singleWorkerItems, 1)\n\tif err3 != nil {\n\t\tlog.Fatalf(\"Error: %v\", err3)\n\t}\n\tfmt.Printf(\"Single worker processed %d items: %v\\n\", len(results3), results3)\n\n\tfmt.Println(\"\\n=== All tests completed successfully ===\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}