{
    "task": "82afb7ab1fe12cf2efceede2322d082eaf5d5adc.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype WriteMessage struct {\n\tstreamID int\n\tdata     []byte\n}\n\ntype StreamManager struct {\n\tmu             sync.Mutex\n\twriteChan      chan WriteMessage\n\tresetChan      chan int\n\tshutdownChan   chan struct{}\n\twg             sync.WaitGroup\n\tclosed         bool\n}\n\nfunc NewStreamManager() *StreamManager {\n\tsm := &StreamManager{\n\t\twriteChan:    make(chan WriteMessage, 100),\n\t\tresetChan:    make(chan int, 10),\n\t\tshutdownChan: make(chan struct{}),\n\t}\n\n\tsm.wg.Add(1)\n\tgo sm.backgroundProcessor()\n\n\treturn sm\n}\n\nfunc (sm *StreamManager) backgroundProcessor() {\n\tdefer sm.wg.Done()\n\n\tfor {\n\t\tselect {\n\t\tcase msg := <-sm.writeChan:\n\t\t\tif msg.streamID%7 == 0 {\n\t\t\t\tselect {\n\t\t\t\tcase sm.resetChan <- msg.streamID:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase resetID := <-sm.resetChan:\n\t\t\t_ = resetID\n\n\t\tcase <-sm.shutdownChan:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (sm *StreamManager) Write(streamID int, data []byte) error {\n\tsm.mu.Lock()\n\tdefer sm.mu.Unlock()\n\n\tif sm.closed {\n\t\treturn fmt.Errorf(\"stream manager is closed\")\n\t}\n\n\tselect {\n\tcase sm.writeChan <- WriteMessage{streamID: streamID, data: data}:\n\t\treturn nil\n\tcase <-sm.shutdownChan:\n\t\treturn fmt.Errorf(\"stream manager is shutting down\")\n\tdefault:\n\t\treturn fmt.Errorf(\"write channel full\")\n\t}\n}\n\nfunc (sm *StreamManager) Close() error {\n\tsm.mu.Lock()\n\tif sm.closed {\n\t\tsm.mu.Unlock()\n\t\treturn fmt.Errorf(\"stream manager already closed\")\n\t}\n\tsm.closed = true\n\tsm.mu.Unlock()\n\n\tclose(sm.shutdownChan)\n\tclose(sm.writeChan)\n\n\tsm.wg.Wait()\n\n\tclose(sm.resetChan)\n\n\treturn nil\n}\n\nfunc main() {\n\tfmt.Println(\"Starting Concurrent Stream Manager...\")\n\n\tsm := NewStreamManager()\n\tvar wg sync.WaitGroup\n\twriteCount := 0\n\tcountMu := sync.Mutex{}\n\n\tfor i := 0; i < 25; i++ {\n\t\twg.Add(1)\n\t\tgo func(writerID int) {\n\t\t\tdefer wg.Done()\n\n\t\t\tfor j := 0; j < 50; j++ {\n\t\t\t\tstreamID := writerID%5 + 1\n\t\t\t\tdata := []byte(fmt.Sprintf(\"stream_%d_msg_%d\", streamID, j))\n\n\t\t\t\terr := sm.Write(streamID, data)\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tcountMu.Lock()\n\t\t\t\twriteCount++\n\t\t\t\tcountMu.Unlock()\n\n\t\t\t\ttime.Sleep(time.Millisecond * time.Duration(5+writerID%3))\n\t\t\t}\n\t\t}(i)\n\t}\n\n\ttime.Sleep(time.Second)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\terr := sm.Close()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Close error: %v\\n\", err)\n\t\t} else {\n\t\t\tfmt.Println(\"StreamManager closed successfully\")\n\t\t}\n\t}()\n\n\twg.Wait()\n\n\tcountMu.Lock()\n\tfmt.Printf(\"Total writes processed: %d\\n\", writeCount)\n\tcountMu.Unlock()\n\n\tfmt.Println(\"Program completed successfully\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}