{
    "task": "1d8813052292e6053957fae01d080fde9717f3fc.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar ErrConnectionClosed = errors.New(\"connection closed\")\n\ntype KVClient struct {\n\tmu       sync.RWMutex\n\tclosed   bool\n\tconn     interface{}\n\twg       sync.WaitGroup\n}\n\nfunc NewKVClient() *KVClient {\n\treturn &KVClient{\n\t\tclosed: false,\n\t\tconn:   \"connected\",\n\t}\n}\n\nfunc (c *KVClient) Get(key string) (string, error) {\n\tc.mu.RLock()\n\tif c.closed {\n\t\tc.mu.RUnlock()\n\t\treturn \"\", ErrConnectionClosed\n\t}\n\tc.mu.RUnlock()\n\n\tc.wg.Add(1)\n\tdefer c.wg.Done()\n\n\tc.mu.RLock()\n\tif c.closed {\n\t\tc.mu.RUnlock()\n\t\treturn \"\", ErrConnectionClosed\n\t}\n\tc.mu.RUnlock()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tc.mu.RLock()\n\tif c.closed {\n\t\tc.mu.RUnlock()\n\t\treturn \"\", ErrConnectionClosed\n\t}\n\tdefer c.mu.RUnlock()\n\n\treturn fmt.Sprintf(\"value_for_%s\", key), nil\n}\n\nfunc (c *KVClient) Close() error {\n\tc.mu.Lock()\n\tif c.closed {\n\t\tc.mu.Unlock()\n\t\treturn nil\n\t}\n\tc.closed = true\n\tc.conn = nil\n\tc.mu.Unlock()\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tc.wg.Wait()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn nil\n\tcase <-time.After(2 * time.Second):\n\t\treturn errors.New(\"timeout waiting for operations to complete\")\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"Starting test...\")\n\n\tclient := NewKVClient()\n\n\tgetCompleted := make(chan error, 1)\n\tcloseCompleted := make(chan error, 1)\n\n\tgo func() {\n\t\t_, err := client.Get(\"test_key\")\n\t\tgetCompleted <- err\n\t}()\n\n\ttime.Sleep(50 * time.Millisecond)\n\n\tgo func() {\n\t\terr := client.Close()\n\t\tcloseCompleted <- err\n\t}()\n\n\ttestTimeout := time.After(3 * time.Second)\n\tgetErr := false\n\tcloseErr := false\n\treceived := 0\n\n\tfor received < 2 {\n\t\tselect {\n\t\tcase err := <-getCompleted:\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Get operation completed with error: %v\\n\", err)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Get operation completed successfully\")\n\t\t\t}\n\t\t\treceived++\n\t\t\tgetErr = true\n\t\tcase err := <-closeCompleted:\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Close operation completed with error: %v\\n\", err)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Close operation completed\")\n\t\t\t}\n\t\t\treceived++\n\t\t\tcloseErr = true\n\t\tcase <-testTimeout:\n\t\t\tfmt.Println(\"Test timed out - possible deadlock\")\n\t\t\tfmt.Println(\"FAILURE\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tif getErr && closeErr {\n\t\tfmt.Println(\"Test completed in time\")\n\t\tfmt.Println(\"SUCCESS\")\n\t} else {\n\t\tfmt.Println(\"Test did not complete properly\")\n\t\tfmt.Println(\"FAILURE\")\n\t}\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}