{
    "task": "8baaa06cce9e58548f60e6e9b21c9af3d42580bb.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tErrClosed        = errors.New(\"pool manager is closed\")\n\tErrNoConnections = errors.New(\"no connections available\")\n\tErrTimeout       = errors.New(\"timeout waiting for ready\")\n)\n\ntype PoolManager struct {\n\tmu                sync.RWMutex\n\tclosed            bool\n\taddresses         map[string]bool\n\tpinnedAddr        string\n\tpinnedCleanup     func(error)\n\tnotifyCh          chan []string\n\taddressUpdatesCh  chan []string\n\twaitReadyCh       chan struct{}\n\tactiveDone        chan struct{}\n\twg                sync.WaitGroup\n}\n\nfunc NewPoolManager(addrs []string) *PoolManager {\n\tpm := &PoolManager{\n\t\taddresses:        make(map[string]bool),\n\t\tnotifyCh:         make(chan []string, 1),\n\t\taddressUpdatesCh: make(chan []string, 10),\n\t\twaitReadyCh:      make(chan struct{}, 1),\n\t\tactiveDone:       make(chan struct{}),\n\t}\n\tfor _, addr := range addrs {\n\t\tpm.addresses[addr] = true\n\t}\n\tpm.wg.Add(1)\n\tgo pm.run()\n\treturn pm\n}\n\nfunc (pm *PoolManager) run() {\n\tdefer pm.wg.Done()\n\tdefer close(pm.notifyCh)\n\tdefer close(pm.addressUpdatesCh)\n\tdefer close(pm.waitReadyCh)\n\n\tfor {\n\t\tselect {\n\t\tcase <-pm.activeDone:\n\t\t\treturn\n\t\tcase addrs := <-pm.addressUpdatesCh:\n\t\t\tpm.mu.Lock()\n\t\t\tpm.addresses = make(map[string]bool)\n\t\t\tfor _, addr := range addrs {\n\t\t\t\tpm.addresses[addr] = true\n\t\t\t}\n\t\t\tpm.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (pm *PoolManager) Up(addr string) func(error) {\n\tpm.mu.Lock()\n\tdefer pm.mu.Unlock()\n\n\tif pm.closed {\n\t\treturn func(error) {}\n\t}\n\n\tif pm.pinnedAddr == \"\" {\n\t\tpm.pinnedAddr = addr\n\t\tpm.notifyLocked([]string{addr})\n\t\tselect {\n\t\tcase pm.waitReadyCh <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t\treturn pm.makeCleanupFunc(addr)\n\t}\n\n\tif pm.pinnedAddr == addr {\n\t\treturn pm.makeCleanupFunc(addr)\n\t}\n\n\treturn func(error) {}\n}\n\nfunc (pm *PoolManager) makeCleanupFunc(addr string) func(error) {\n\treturn func(err error) {\n\t\tpm.mu.Lock()\n\t\tdefer pm.mu.Unlock()\n\n\t\tif pm.pinnedAddr == addr {\n\t\t\tpm.pinnedAddr = \"\"\n\t\t\tpm.pinnedCleanup = nil\n\n\t\t\tavailableAddrs := make([]string, 0)\n\t\t\tfor a := range pm.addresses {\n\t\t\t\tavailableAddrs = append(availableAddrs, a)\n\t\t\t}\n\n\t\t\tpm.notifyLocked(availableAddrs)\n\t\t}\n\t}\n}\n\nfunc (pm *PoolManager) UpdateAddresses(addrs []string) {\n\tpm.mu.RLock()\n\tif pm.closed {\n\t\tpm.mu.RUnlock()\n\t\treturn\n\t}\n\tpm.mu.RUnlock()\n\n\tselect {\n\tcase pm.addressUpdatesCh <- addrs:\n\tcase <-pm.activeDone:\n\t}\n}\n\nfunc (pm *PoolManager) Notify() <-chan []string {\n\treturn pm.notifyCh\n}\n\nfunc (pm *PoolManager) WaitForReady(timeout time.Duration) error {\n\tpm.mu.RLock()\n\tif pm.closed {\n\t\tpm.mu.RUnlock()\n\t\treturn ErrClosed\n\t}\n\tif pm.pinnedAddr != \"\" {\n\t\tpm.mu.RUnlock()\n\t\treturn nil\n\t}\n\tpm.mu.RUnlock()\n\n\ttimer := time.NewTimer(timeout)\n\tdefer timer.Stop()\n\n\tselect {\n\tcase <-pm.waitReadyCh:\n\t\treturn nil\n\tcase <-timer.C:\n\t\treturn ErrTimeout\n\tcase <-pm.activeDone:\n\t\treturn ErrClosed\n\t}\n}\n\nfunc (pm *PoolManager) Close() error {\n\tpm.mu.Lock()\n\tif pm.closed {\n\t\tpm.mu.Unlock()\n\t\treturn nil\n\t}\n\tpm.closed = true\n\n\tif pm.pinnedCleanup != nil {\n\t\tcleanup := pm.pinnedCleanup\n\t\tpm.pinnedCleanup = nil\n\t\tpm.mu.Unlock()\n\t\tcleanup(nil)\n\t\tpm.mu.Lock()\n\t}\n\n\tpm.pinnedAddr = \"\"\n\tpm.mu.Unlock()\n\n\tclose(pm.activeDone)\n\tpm.wg.Wait()\n\n\treturn nil\n}\n\nfunc (pm *PoolManager) notifyLocked(addrs []string) {\n\tselect {\n\tcase pm.notifyCh <- addrs:\n\tdefault:\n\t\tselect {\n\t\tcase <-pm.notifyCh:\n\t\t\tpm.notifyCh <- addrs\n\t\tdefault:\n\t\t}\n\t}\n}\n\nfunc simulateEndpoint(name string, connChan chan string, disconnChan chan string) {\n\tfor range connChan {\n\t\tdisconnChan <- name\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"=== Connection Pool Manager Test ===\\n\")\n\n\ttestBasicConnection()\n\ttestMultipleConnections()\n\ttestConnectionFailover()\n\ttestAddressUpdate()\n\ttestWaitForReady()\n\ttestStressAndGracefulShutdown()\n\n\tfmt.Println(\"\\n=== All tests passed ===\")\n}\n\nfunc testBasicConnection() {\n\tfmt.Println(\"Test 1: Basic Connection\")\n\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\"})\n\n\tcleanup1 := pm.Up(\"server1:5000\")\n\n\tselect {\n\tcase addrs := <-pm.Notify():\n\t\tfmt.Printf(\"  Notified with pinned address: %v\\n\", addrs)\n\t\tif len(addrs) != 1 || addrs[0] != \"server1:5000\" {\n\t\t\tfmt.Println(\"  ERROR: Expected pinned address\")\n\t\t}\n\tcase <-time.After(1 * time.Second):\n\t\tfmt.Println(\"  ERROR: No notification received\")\n\t}\n\n\tcleanup1(nil)\n\n\tselect {\n\tcase addrs := <-pm.Notify():\n\t\tfmt.Printf(\"  Notified with available addresses after disconnect: %v\\n\", addrs)\n\t\tif len(addrs) != 2 {\n\t\t\tfmt.Println(\"  ERROR: Expected 2 available addresses\")\n\t\t}\n\tcase <-time.After(1 * time.Second):\n\t\tfmt.Println(\"  ERROR: No notification received after disconnect\")\n\t}\n\n\tpm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testMultipleConnections() {\n\tfmt.Println(\"Test 2: Multiple Connections\")\n\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\", \"server3:5000\"})\n\n\tcleanup1 := pm.Up(\"server1:5000\")\n\ttime.Sleep(100 * time.Millisecond)\n\n\tcleanup2 := pm.Up(\"server2:5000\")\n\ttime.Sleep(100 * time.Millisecond)\n\n\tvar notified []string\n\tselect {\n\tcase addrs := <-pm.Notify():\n\t\tnotified = addrs\n\t\tfmt.Printf(\"  Currently pinned: %v\\n\", notified)\n\tcase <-time.After(1 * time.Second):\n\t}\n\n\tcleanup1(nil)\n\ttime.Sleep(100 * time.Millisecond)\n\n\tcleanup2(nil)\n\n\tpm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testConnectionFailover() {\n\tfmt.Println(\"Test 3: Connection Failover\")\n\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\"})\n\n\tcleanup1 := pm.Up(\"server1:5000\")\n\t<-pm.Notify()\n\n\tfmt.Println(\"  Server1 pinned, now failing it...\")\n\tcleanup1(nil)\n\n\t<-pm.Notify()\n\n\tcleanup2 := pm.Up(\"server2:5000\")\n\t<-pm.Notify()\n\n\tfmt.Println(\"  Server2 now pinned\")\n\n\tcleanup2(nil)\n\tpm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testAddressUpdate() {\n\tfmt.Println(\"Test 4: Address Update\")\n\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\"})\n\n\tpm.UpdateAddresses([]string{\"server3:5000\", \"server4:5000\"})\n\ttime.Sleep(100 * time.Millisecond)\n\n\tpm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testWaitForReady() {\n\tfmt.Println(\"Test 5: WaitForReady\")\n\tpm := NewPoolManager([]string{\"server1:5000\"})\n\n\tgo func() {\n\t\ttime.Sleep(200 * time.Millisecond)\n\t\tpm.Up(\"server1:5000\")\n\t}()\n\n\terr := pm.WaitForReady(1 * time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"  ERROR: WaitForReady failed: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(\"  Successfully waited for ready\")\n\t}\n\n\tpm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testStressAndGracefulShutdown() {\n\tfmt.Println(\"Test 6: Stress and Graceful Shutdown\")\n\n\tfor iteration := 0; iteration < 5; iteration++ {\n\t\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\", \"server3:5000\"})\n\n\t\tvar wg sync.WaitGroup\n\t\tdone := make(chan struct{})\n\n\t\tfor i := 0; i < 3; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func(id int) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tdefault:\n\t\t\t\t\t\taddr := fmt.Sprintf(\"server%d:5000\", (id%3)+1)\n\t\t\t\t\t\tcleanup := pm.Up(addr)\n\t\t\t\t\t\ttime.Sleep(time.Duration(10+id*5) * time.Millisecond)\n\t\t\t\t\t\tcleanup(nil)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(i)\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-done:\n\t\t\t\t\treturn\n\t\t\t\tcase <-pm.Notify():\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\ttime.Sleep(300 * time.Millisecond)\n\t\tclose(done)\n\n\t\tcloseDone := make(chan error, 1)\n\t\tgo func() {\n\t\t\tcloseDone <- pm.Close()\n\t\t}()\n\n\t\tselect {\n\t\tcase err := <-closeDone:\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"  Iteration %d: Close failed: %v\\n\", iteration, err)\n\t\t\t}\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tfmt.Printf(\"  Iteration %d: Close timeout - DEADLOCK DETECTED\\n\", iteration)\n\t\t}\n\n\t\twg.Wait()\n\t}\n\n\tfmt.Println(\"  PASSED\\n\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[37;40m/tmp/go_synthesis_wg3kvxbb/main.go:317\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    316: \n  > 317: \tpm.Close()\n    318: \tfmt.Println(\"  PASSED\\n\")\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_wg3kvxbb/main.go:297\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    296: \n  > 297: \tpm.Close()\n    298: \tfmt.Println(\"  PASSED\\n\")\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_wg3kvxbb/main.go:286\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    285: \tcleanup2(nil)\n  > 286: \tpm.Close()\n    287: \tfmt.Println(\"  PASSED\\n\")\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_wg3kvxbb/main.go:264\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    263: \n  > 264: \tpm.Close()\n    265: \tfmt.Println(\"  PASSED\\n\")\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_wg3kvxbb/main.go:237\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    236: \n  > 237: \tpm.Close()\n    238: \tfmt.Println(\"  PASSED\\n\")\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 381\n  Nosec  : 0\n  Issues : \u001b[1;31m5\u001b[0m\n\n[gosec] 2025/12/01 13:55:21 Including rules: default\n[gosec] 2025/12/01 13:55:21 Excluding rules: default\n[gosec] 2025/12/01 13:55:21 Including analyzers: default\n[gosec] 2025/12/01 13:55:21 Excluding analyzers: default\n[gosec] 2025/12/01 13:55:21 Import directory: /tmp/go_synthesis_wg3kvxbb\n[gosec] 2025/12/01 13:55:21 Checking package: main\n[gosec] 2025/12/01 13:55:21 Checking file: /tmp/go_synthesis_wg3kvxbb/main.go"
                },
                {
                    "verifier": "errcheck",
                    "error": "main.go:237:10:\tpm.Close()\nmain.go:264:10:\tpm.Close()\nmain.go:286:10:\tpm.Close()\nmain.go:297:10:\tpm.Close()\nmain.go:317:10:\tpm.Close()"
                },
                {
                    "verifier": "staticcheck",
                    "error": "main.go:190:6: func simulateEndpoint is unused (U1000)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\tErrClosed        = errors.New(\"pool manager is closed\")\n\tErrNoConnections = errors.New(\"no connections available\")\n\tErrTimeout       = errors.New(\"timeout waiting for ready\")\n)\n\ntype PoolManager struct {\n\tmu                sync.RWMutex\n\tclosed            bool\n\taddresses         map[string]bool\n\tpinnedAddr        string\n\tpinnedCleanup     func(error)\n\tnotifyCh          chan []string\n\taddressUpdatesCh  chan []string\n\twaitReadyCh       chan struct{}\n\tactiveDone        chan struct{}\n\twg                sync.WaitGroup\n}\n\nfunc NewPoolManager(addrs []string) *PoolManager {\n\tpm := &PoolManager{\n\t\taddresses:        make(map[string]bool),\n\t\tnotifyCh:         make(chan []string, 1),\n\t\taddressUpdatesCh: make(chan []string, 10),\n\t\twaitReadyCh:      make(chan struct{}, 1),\n\t\tactiveDone:       make(chan struct{}),\n\t}\n\tfor _, addr := range addrs {\n\t\tpm.addresses[addr] = true\n\t}\n\tpm.wg.Add(1)\n\tgo pm.run()\n\treturn pm\n}\n\nfunc (pm *PoolManager) run() {\n\tdefer pm.wg.Done()\n\tdefer close(pm.notifyCh)\n\tdefer close(pm.addressUpdatesCh)\n\tdefer close(pm.waitReadyCh)\n\n\tfor {\n\t\tselect {\n\t\tcase <-pm.activeDone:\n\t\t\treturn\n\t\tcase addrs := <-pm.addressUpdatesCh:\n\t\t\tpm.mu.Lock()\n\t\t\tpm.addresses = make(map[string]bool)\n\t\t\tfor _, addr := range addrs {\n\t\t\t\tpm.addresses[addr] = true\n\t\t\t}\n\t\t\tpm.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (pm *PoolManager) Up(addr string) func(error) {\n\tpm.mu.Lock()\n\tdefer pm.mu.Unlock()\n\n\tif pm.closed {\n\t\treturn func(error) {}\n\t}\n\n\tif pm.pinnedAddr == \"\" {\n\t\tpm.pinnedAddr = addr\n\t\tpm.notifyLocked([]string{addr})\n\t\tselect {\n\t\tcase pm.waitReadyCh <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t\treturn pm.makeCleanupFunc(addr)\n\t}\n\n\tif pm.pinnedAddr == addr {\n\t\treturn pm.makeCleanupFunc(addr)\n\t}\n\n\treturn func(error) {}\n}\n\nfunc (pm *PoolManager) makeCleanupFunc(addr string) func(error) {\n\treturn func(err error) {\n\t\tpm.mu.Lock()\n\t\tdefer pm.mu.Unlock()\n\n\t\tif pm.pinnedAddr == addr {\n\t\t\tpm.pinnedAddr = \"\"\n\t\t\tpm.pinnedCleanup = nil\n\n\t\t\tavailableAddrs := make([]string, 0)\n\t\t\tfor a := range pm.addresses {\n\t\t\t\tavailableAddrs = append(availableAddrs, a)\n\t\t\t}\n\n\t\t\tpm.notifyLocked(availableAddrs)\n\t\t}\n\t}\n}\n\nfunc (pm *PoolManager) UpdateAddresses(addrs []string) {\n\tpm.mu.RLock()\n\tif pm.closed {\n\t\tpm.mu.RUnlock()\n\t\treturn\n\t}\n\tpm.mu.RUnlock()\n\n\tselect {\n\tcase pm.addressUpdatesCh <- addrs:\n\tcase <-pm.activeDone:\n\t}\n}\n\nfunc (pm *PoolManager) Notify() <-chan []string {\n\treturn pm.notifyCh\n}\n\nfunc (pm *PoolManager) WaitForReady(timeout time.Duration) error {\n\tpm.mu.RLock()\n\tif pm.closed {\n\t\tpm.mu.RUnlock()\n\t\treturn ErrClosed\n\t}\n\tif pm.pinnedAddr != \"\" {\n\t\tpm.mu.RUnlock()\n\t\treturn nil\n\t}\n\tpm.mu.RUnlock()\n\n\ttimer := time.NewTimer(timeout)\n\tdefer timer.Stop()\n\n\tselect {\n\tcase <-pm.waitReadyCh:\n\t\treturn nil\n\tcase <-timer.C:\n\t\treturn ErrTimeout\n\tcase <-pm.activeDone:\n\t\treturn ErrClosed\n\t}\n}\n\nfunc (pm *PoolManager) Close() error {\n\tpm.mu.Lock()\n\tif pm.closed {\n\t\tpm.mu.Unlock()\n\t\treturn nil\n\t}\n\tpm.closed = true\n\n\tif pm.pinnedCleanup != nil {\n\t\tcleanup := pm.pinnedCleanup\n\t\tpm.pinnedCleanup = nil\n\t\tpm.mu.Unlock()\n\t\tcleanup(nil)\n\t\tpm.mu.Lock()\n\t}\n\n\tpm.pinnedAddr = \"\"\n\tpm.mu.Unlock()\n\n\tclose(pm.activeDone)\n\tpm.wg.Wait()\n\n\treturn nil\n}\n\nfunc (pm *PoolManager) notifyLocked(addrs []string) {\n\tselect {\n\tcase pm.notifyCh <- addrs:\n\tdefault:\n\t\tselect {\n\t\tcase <-pm.notifyCh:\n\t\t\tpm.notifyCh <- addrs\n\t\tdefault:\n\t\t}\n\t}\n}\n\nfunc main() {\n\tfmt.Println(\"=== Connection Pool Manager Test ===\\n\")\n\n\ttestBasicConnection()\n\ttestMultipleConnections()\n\ttestConnectionFailover()\n\ttestAddressUpdate()\n\ttestWaitForReady()\n\ttestStressAndGracefulShutdown()\n\n\tfmt.Println(\"\\n=== All tests passed ===\")\n}\n\nfunc testBasicConnection() {\n\tfmt.Println(\"Test 1: Basic Connection\")\n\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\"})\n\n\tcleanup1 := pm.Up(\"server1:5000\")\n\n\tselect {\n\tcase addrs := <-pm.Notify():\n\t\tfmt.Printf(\"  Notified with pinned address: %v\\n\", addrs)\n\t\tif len(addrs) != 1 || addrs[0] != \"server1:5000\" {\n\t\t\tfmt.Println(\"  ERROR: Expected pinned address\")\n\t\t}\n\tcase <-time.After(1 * time.Second):\n\t\tfmt.Println(\"  ERROR: No notification received\")\n\t}\n\n\tcleanup1(nil)\n\n\tselect {\n\tcase addrs := <-pm.Notify():\n\t\tfmt.Printf(\"  Notified with available addresses after disconnect: %v\\n\", addrs)\n\t\tif len(addrs) != 2 {\n\t\t\tfmt.Println(\"  ERROR: Expected 2 available addresses\")\n\t\t}\n\tcase <-time.After(1 * time.Second):\n\t\tfmt.Println(\"  ERROR: No notification received after disconnect\")\n\t}\n\n\t_ = pm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testMultipleConnections() {\n\tfmt.Println(\"Test 2: Multiple Connections\")\n\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\", \"server3:5000\"})\n\n\tcleanup1 := pm.Up(\"server1:5000\")\n\ttime.Sleep(100 * time.Millisecond)\n\n\tcleanup2 := pm.Up(\"server2:5000\")\n\ttime.Sleep(100 * time.Millisecond)\n\n\tvar notified []string\n\tselect {\n\tcase addrs := <-pm.Notify():\n\t\tnotified = addrs\n\t\tfmt.Printf(\"  Currently pinned: %v\\n\", notified)\n\tcase <-time.After(1 * time.Second):\n\t}\n\n\tcleanup1(nil)\n\ttime.Sleep(100 * time.Millisecond)\n\n\tcleanup2(nil)\n\n\t_ = pm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testConnectionFailover() {\n\tfmt.Println(\"Test 3: Connection Failover\")\n\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\"})\n\n\tcleanup1 := pm.Up(\"server1:5000\")\n\t<-pm.Notify()\n\n\tfmt.Println(\"  Server1 pinned, now failing it...\")\n\tcleanup1(nil)\n\n\t<-pm.Notify()\n\n\tcleanup2 := pm.Up(\"server2:5000\")\n\t<-pm.Notify()\n\n\tfmt.Println(\"  Server2 now pinned\")\n\n\tcleanup2(nil)\n\t_ = pm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testAddressUpdate() {\n\tfmt.Println(\"Test 4: Address Update\")\n\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\"})\n\n\tpm.UpdateAddresses([]string{\"server3:5000\", \"server4:5000\"})\n\ttime.Sleep(100 * time.Millisecond)\n\n\t_ = pm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testWaitForReady() {\n\tfmt.Println(\"Test 5: WaitForReady\")\n\tpm := NewPoolManager([]string{\"server1:5000\"})\n\n\tgo func() {\n\t\ttime.Sleep(200 * time.Millisecond)\n\t\t_ = pm.Up(\"server1:5000\")\n\t}()\n\n\terr := pm.WaitForReady(1 * time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"  ERROR: WaitForReady failed: %v\\n\", err)\n\t} else {\n\t\tfmt.Println(\"  Successfully waited for ready\")\n\t}\n\n\t_ = pm.Close()\n\tfmt.Println(\"  PASSED\\n\")\n}\n\nfunc testStressAndGracefulShutdown() {\n\tfmt.Println(\"Test 6: Stress and Graceful Shutdown\")\n\n\tfor iteration := 0; iteration < 5; iteration++ {\n\t\tpm := NewPoolManager([]string{\"server1:5000\", \"server2:5000\", \"server3:5000\"})\n\n\t\tvar wg sync.WaitGroup\n\t\tdone := make(chan struct{})\n\n\t\tfor i := 0; i < 3; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func(id int) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-done:\n\t\t\t\t\t\treturn\n\t\t\t\t\tdefault:\n\t\t\t\t\t\taddr := fmt.Sprintf(\"server%d:5000\", (id%3)+1)\n\t\t\t\t\t\tcleanup := pm.Up(addr)\n\t\t\t\t\t\ttime.Sleep(time.Duration(10+id*5) * time.Millisecond)\n\t\t\t\t\t\tcleanup(nil)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}(i)\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-done:\n\t\t\t\t\treturn\n\t\t\t\tcase <-pm.Notify():\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\ttime.Sleep(300 * time.Millisecond)\n\t\tclose(done)\n\n\t\tcloseDone := make(chan error, 1)\n\t\tgo func() {\n\t\t\tcloseDone <- pm.Close()\n\t\t}()\n\n\t\tselect {\n\t\tcase err := <-closeDone:\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"  Iteration %d: Close failed: %v\\n\", iteration, err)\n\t\t\t}\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tfmt.Printf(\"  Iteration %d: Close timeout - DEADLOCK DETECTED\\n\", iteration)\n\t\t}\n\n\t\twg.Wait()\n\t}\n\n\tfmt.Println(\"  PASSED\\n\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}