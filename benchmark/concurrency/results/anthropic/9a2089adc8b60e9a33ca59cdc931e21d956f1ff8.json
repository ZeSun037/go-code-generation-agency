{
    "task": "9a2089adc8b60e9a33ca59cdc931e21d956f1ff8.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Status struct {\n\tMessage   string\n\tTimestamp time.Time\n}\n\ntype Pod struct {\n\tUID    string\n\tName   string\n\tStatus Status\n}\n\ntype StatusUpdate struct {\n\tPodUID string\n\tStatus Status\n}\n\ntype ApiServer struct {\n\tmu              sync.RWMutex\n\tstatuses        map[string]Status\n\tsyncCount       int64\n\tnetworkLatency  time.Duration\n}\n\nfunc NewApiServer(latency time.Duration) *ApiServer {\n\treturn &ApiServer{\n\t\tstatuses:       make(map[string]Status),\n\t\tnetworkLatency: latency,\n\t}\n}\n\nfunc (as *ApiServer) UpdateStatus(podUID string, status Status) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tas.statuses[podUID] = status\n\tatomic.AddInt64(&as.syncCount, 1)\n\treturn nil\n}\n\nfunc (as *ApiServer) DeleteStatus(podUID string) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tdelete(as.statuses, podUID)\n\treturn nil\n}\n\nfunc (as *ApiServer) GetStatus(podUID string) (Status, bool) {\n\tas.mu.RLock()\n\tdefer as.mu.RUnlock()\n\tstatus, exists := as.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (as *ApiServer) GetSyncCount() int64 {\n\treturn atomic.LoadInt64(&as.syncCount)\n}\n\ntype Manager struct {\n\tmu              sync.RWMutex\n\tstatuses        map[string]Status\n\tupdateQueue     chan StatusUpdate\n\tapiServer       *ApiServer\n\tstopChan        chan struct{}\n\twg              sync.WaitGroup\n\tupdateCount     int64\n\tsyncCount       int64\n\tpendingDeletes  map[string]bool\n\tdeleteMu        sync.RWMutex\n}\n\nfunc NewManager(apiServer *ApiServer, queueSize int) *Manager {\n\treturn &Manager{\n\t\tstatuses:       make(map[string]Status),\n\t\tupdateQueue:    make(chan StatusUpdate, queueSize),\n\t\tapiServer:      apiServer,\n\t\tstopChan:       make(chan struct{}),\n\t\tpendingDeletes: make(map[string]bool),\n\t}\n}\n\nfunc (m *Manager) SetPodStatus(podUID string, status Status) {\n\tselect {\n\tcase m.updateQueue <- StatusUpdate{PodUID: podUID, Status: status}:\n\t\tatomic.AddInt64(&m.updateCount, 1)\n\t\tm.mu.Lock()\n\t\tm.statuses[podUID] = status\n\t\tm.mu.Unlock()\n\t\tlogf(\"[UPDATE] Pod %s status set to: %s\", podUID, status.Message)\n\tcase <-m.stopChan:\n\t\tlogf(\"[WARN] Update queue full or manager stopped for pod %s\", podUID)\n\tdefault:\n\t\tlogf(\"[WARN] Update queue full for pod %s\", podUID)\n\t}\n}\n\nfunc (m *Manager) GetPodStatus(podUID string) (Status, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tstatus, exists := m.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (m *Manager) DeletePod(podUID string) {\n\tm.deleteMu.Lock()\n\tm.pendingDeletes[podUID] = true\n\tm.deleteMu.Unlock()\n\n\tm.mu.Lock()\n\tdelete(m.statuses, podUID)\n\tm.mu.Unlock()\n\n\tlogf(\"[DELETE] Pod %s marked for deletion\", podUID)\n}\n\nfunc (m *Manager) SyncBatch() {\n\tm.mu.RLock()\n\tstatusesToSync := make(map[string]Status)\n\tfor uid, status := range m.statuses {\n\t\tstatusesToSync[uid] = status\n\t}\n\tm.mu.RUnlock()\n\n\tlogf(\"[SYNC] Starting sync of %d pod statuses\", len(statusesToSync))\n\n\tsyncedCount := 0\n\tfor podUID, status := range statusesToSync {\n\t\terr := m.apiServer.UpdateStatus(podUID, status)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to sync pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tsyncedCount++\n\t\t}\n\t}\n\n\tm.deleteMu.Lock()\n\tdeletesToSync := make(map[string]bool)\n\tfor podUID := range m.pendingDeletes {\n\t\tdeletesToSync[podUID] = true\n\t}\n\tm.deleteMu.Unlock()\n\n\tfor podUID := range deletesToSync {\n\t\terr := m.apiServer.DeleteStatus(podUID)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to delete pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tm.deleteMu.Lock()\n\t\t\tdelete(m.pendingDeletes, podUID)\n\t\t\tm.deleteMu.Unlock()\n\t\t}\n\t}\n\n\tatomic.AddInt64(&m.syncCount, 1)\n\tlogf(\"[SYNC] Completed sync, %d statuses synchronized\", syncedCount)\n}\n\nfunc (m *Manager) syncWorker(interval time.Duration) {\n\tticker := time.NewTicker(interval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tm.SyncBatch()\n\t\tcase <-m.stopChan:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (m *Manager) Start(syncInterval time.Duration) {\n\tm.wg.Add(1)\n\tgo m.syncWorker(syncInterval)\n\tlogf(\"[START] Manager started with sync interval: %v\", syncInterval)\n}\n\nfunc (m *Manager) Stop() {\n\tlogf(\"[STOP] Stopping manager\")\n\tclose(m.stopChan)\n\tm.wg.Wait()\n\tm.SyncBatch()\n}\n\nfunc (m *Manager) GetStats() (updateCount, syncCount, podCount int64) {\n\tupdateCount = atomic.LoadInt64(&m.updateCount)\n\tsyncCount = atomic.LoadInt64(&m.syncCount)\n\n\tm.mu.RLock()\n\tpodCount = int64(len(m.statuses))\n\tm.mu.RUnlock()\n\n\treturn\n}\n\nvar logMutex sync.Mutex\n\nfunc logf(format string, args ...interface{}) {\n\tlogMutex.Lock()\n\tdefer logMutex.Unlock()\n\tfmt.Printf(\"[%s] %s\\n\", time.Now().Format(\"15:04:05.000\"), fmt.Sprintf(format, args...))\n}\n\nfunc simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n\tendTime := time.Now().Add(duration)\n\tpodID := fmt.Sprintf(\"pod-%d\", goroutineID%3)\n\n\tfor time.Now().Before(endTime) {\n\t\tstatus := Status{\n\t\t\tMessage:   fmt.Sprintf(\"Status from goroutine %d at %d\", goroutineID, time.Now().Unix()),\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t\tm.SetPodStatus(podID, status)\n\t\ttime.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)\n\t}\n\tlogf(\"[GOROUTINE] Goroutine %d finished\", goroutineID)\n}\n\nfunc simulateReader(m *Manager, duration time.Duration) {\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rand.Intn(len(podIDs))]\n\t\tif status, exists := m.GetPodStatus(podID); exists {\n\t\t\tlogf(\"[READ] Pod %s status: %s\", podID, status.Message)\n\t\t} else {\n\t\t\tlogf(\"[READ] Pod %s not found\", podID)\n\t\t}\n\t\ttime.Sleep(time.Duration(rand.Intn(300)) * time.Millisecond)\n\t}\n}\n\nfunc simulateDeleter(m *Manager, duration time.Duration) {\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\ttime.Sleep(5 * time.Second)\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rand.Intn(len(podIDs))]\n\t\tm.DeletePod(podID)\n\t\ttime.Sleep(3 * time.Second)\n\t}\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tapiServer := NewApiServer(time.Duration(rand.Intn(41)+10) * time.Millisecond)\n\tmanager := NewManager(apiServer, 100)\n\n\tmanager.Start(2 * time.Second)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tsimulateUpdater(manager, id, 10*time.Second)\n\t\t}(i)\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateReader(manager, 10*time.Second)\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateDeleter(manager, 10*time.Second)\n\t}()\n\n\twg.Wait()\n\n\tmanager.Stop()\n\n\ttime.Sleep(1 * time.Second)\n\n\tupdates, syncs, pods := manager.GetStats()\n\tlogf(\"[STATS] Total updates received: %d\", updates)\n\tlogf(\"[STATS] Total syncs to API: %d\", syncs)\n\tlogf(\"[STATS] Pods in cache: %d\", pods)\n\tlogf(\"[STATS] API server sync count: %d\", apiServer.GetSyncCount())\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:259\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    258: \n  > 259: \tapiServer := NewApiServer(time.Duration(rand.Intn(41)+10) * time.Millisecond)\n    260: \tmanager := NewManager(apiServer, 100)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:250\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    249: \tfor time.Now().Before(endTime) {\n  > 250: \t\tpodID := podIDs[rand.Intn(len(podIDs))]\n    251: \t\tm.DeletePod(podID)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:240\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    239: \t\t}\n  > 240: \t\ttime.Sleep(time.Duration(rand.Intn(300)) * time.Millisecond)\n    241: \t}\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:234\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    233: \tfor time.Now().Before(endTime) {\n  > 234: \t\tpodID := podIDs[rand.Intn(len(podIDs))]\n    235: \t\tif status, exists := m.GetPodStatus(podID); exists {\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:224\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    223: \t\tm.SetPodStatus(podID, status)\n  > 224: \t\ttime.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)\n    225: \t}\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 297\n  Nosec  : 0\n  Issues : \u001b[1;31m5\u001b[0m\n\n[gosec] 2025/12/01 13:57:26 Including rules: default\n[gosec] 2025/12/01 13:57:26 Excluding rules: default\n[gosec] 2025/12/01 13:57:26 Including analyzers: default\n[gosec] 2025/12/01 13:57:26 Excluding analyzers: default\n[gosec] 2025/12/01 13:57:26 Import directory: /tmp/go_synthesis_41nbd2qk\n[gosec] 2025/12/01 13:57:26 Checking package: main\n[gosec] 2025/12/01 13:57:26 Checking file: /tmp/go_synthesis_41nbd2qk/main.go"
                },
                {
                    "verifier": "staticcheck",
                    "error": "main.go:257:2: rand.Seed has been deprecated since Go 1.20 and an alternative has been available since Go 1.0: As of Go 1.20 there is no reason to call Seed with a random value. Programs that call Seed with a known value to get a specific sequence of results should use New(NewSource(seed)) to obtain a local random generator. (SA1019)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand/v2\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Status struct {\n\tMessage   string\n\tTimestamp time.Time\n}\n\ntype Pod struct {\n\tUID    string\n\tName   string\n\tStatus Status\n}\n\ntype StatusUpdate struct {\n\tPodUID string\n\tStatus Status\n}\n\ntype ApiServer struct {\n\tmu             sync.RWMutex\n\tstatuses       map[string]Status\n\tsyncCount      int64\n\tnetworkLatency time.Duration\n}\n\nfunc NewApiServer(latency time.Duration) *ApiServer {\n\treturn &ApiServer{\n\t\tstatuses:       make(map[string]Status),\n\t\tnetworkLatency: latency,\n\t}\n}\n\nfunc (as *ApiServer) UpdateStatus(podUID string, status Status) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tas.statuses[podUID] = status\n\tatomic.AddInt64(&as.syncCount, 1)\n\treturn nil\n}\n\nfunc (as *ApiServer) DeleteStatus(podUID string) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tdelete(as.statuses, podUID)\n\treturn nil\n}\n\nfunc (as *ApiServer) GetStatus(podUID string) (Status, bool) {\n\tas.mu.RLock()\n\tdefer as.mu.RUnlock()\n\tstatus, exists := as.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (as *ApiServer) GetSyncCount() int64 {\n\treturn atomic.LoadInt64(&as.syncCount)\n}\n\ntype Manager struct {\n\tmu             sync.RWMutex\n\tstatuses       map[string]Status\n\tupdateQueue    chan StatusUpdate\n\tapiServer      *ApiServer\n\tstopChan       chan struct{}\n\twg             sync.WaitGroup\n\tupdateCount    int64\n\tsyncCount      int64\n\tpendingDeletes map[string]bool\n\tdeleteMu       sync.RWMutex\n}\n\nfunc NewManager(apiServer *ApiServer, queueSize int) *Manager {\n\treturn &Manager{\n\t\tstatuses:       make(map[string]Status),\n\t\tupdateQueue:    make(chan StatusUpdate, queueSize),\n\t\tapiServer:      apiServer,\n\t\tstopChan:       make(chan struct{}),\n\t\tpendingDeletes: make(map[string]bool),\n\t}\n}\n\nfunc (m *Manager) SetPodStatus(podUID string, status Status) {\n\tselect {\n\tcase m.updateQueue <- StatusUpdate{PodUID: podUID, Status: status}:\n\t\tatomic.AddInt64(&m.updateCount, 1)\n\t\tm.mu.Lock()\n\t\tm.statuses[podUID] = status\n\t\tm.mu.Unlock()\n\t\tlogf(\"[UPDATE] Pod %s status set to: %s\", podUID, status.Message)\n\tcase <-m.stopChan:\n\t\tlogf(\"[WARN] Update queue full or manager stopped for pod %s\", podUID)\n\tdefault:\n\t\tlogf(\"[WARN] Update queue full for pod %s\", podUID)\n\t}\n}\n\nfunc (m *Manager) GetPodStatus(podUID string) (Status, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tstatus, exists := m.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (m *Manager) DeletePod(podUID string) {\n\tm.deleteMu.Lock()\n\tm.pendingDeletes[podUID] = true\n\tm.deleteMu.Unlock()\n\n\tm.mu.Lock()\n\tdelete(m.statuses, podUID)\n\tm.mu.Unlock()\n\n\tlogf(\"[DELETE] Pod %s marked for deletion\", podUID)\n}\n\nfunc (m *Manager) SyncBatch() {\n\tm.mu.RLock()\n\tstatusesToSync := make(map[string]Status)\n\tfor uid, status := range m.statuses {\n\t\tstatusesToSync[uid] = status\n\t}\n\tm.mu.RUnlock()\n\n\tlogf(\"[SYNC] Starting sync of %d pod statuses\", len(statusesToSync))\n\n\tsyncedCount := 0\n\tfor podUID, status := range statusesToSync {\n\t\terr := m.apiServer.UpdateStatus(podUID, status)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to sync pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tsyncedCount++\n\t\t}\n\t}\n\n\tm.deleteMu.Lock()\n\tdeletesToSync := make(map[string]bool)\n\tfor podUID := range m.pendingDeletes {\n\t\tdeletesToSync[podUID] = true\n\t}\n\tm.deleteMu.Unlock()\n\n\tfor podUID := range deletesToSync {\n\t\terr := m.apiServer.DeleteStatus(podUID)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to delete pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tm.deleteMu.Lock()\n\t\t\tdelete(m.pendingDeletes, podUID)\n\t\t\tm.deleteMu.Unlock()\n\t\t}\n\t}\n\n\tatomic.AddInt64(&m.syncCount, 1)\n\tlogf(\"[SYNC] Completed sync, %d statuses synchronized\", syncedCount)\n}\n\nfunc (m *Manager) syncWorker(interval time.Duration) {\n\tticker := time.NewTicker(interval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tm.SyncBatch()\n\t\tcase <-m.stopChan:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (m *Manager) Start(syncInterval time.Duration) {\n\tm.wg.Add(1)\n\tgo m.syncWorker(syncInterval)\n\tlogf(\"[START] Manager started with sync interval: %v\", syncInterval)\n}\n\nfunc (m *Manager) Stop() {\n\tlogf(\"[STOP] Stopping manager\")\n\tclose(m.stopChan)\n\tm.wg.Wait()\n\tm.SyncBatch()\n}\n\nfunc (m *Manager) GetStats() (updateCount, syncCount, podCount int64) {\n\tupdateCount = atomic.LoadInt64(&m.updateCount)\n\tsyncCount = atomic.LoadInt64(&m.syncCount)\n\n\tm.mu.RLock()\n\tpodCount = int64(len(m.statuses))\n\tm.mu.RUnlock()\n\n\treturn\n}\n\nvar logMutex sync.Mutex\n\nfunc logf(format string, args ...interface{}) {\n\tlogMutex.Lock()\n\tdefer logMutex.Unlock()\n\tfmt.Printf(\"[%s] %s\\n\", time.Now().Format(\"15:04:05.000\"), fmt.Sprintf(format, args...))\n}\n\nfunc simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n\tendTime := time.Now().Add(duration)\n\tpodID := fmt.Sprintf(\"pod-%d\", goroutineID%3)\n\n\tfor time.Now().Before(endTime) {\n\t\tstatus := Status{\n\t\t\tMessage:   fmt.Sprintf(\"Status from goroutine %d at %d\", goroutineID, time.Now().Unix()),\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t\tm.SetPodStatus(podID, status)\n\t\ttime.Sleep(time.Duration(rng.Intn(500)) * time.Millisecond)\n\t}\n\tlogf(\"[GOROUTINE] Goroutine %d finished\", goroutineID)\n}\n\nfunc simulateReader(m *Manager, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+1))\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rng.Intn(len(podIDs))]\n\t\tif status, exists := m.GetPodStatus(podID); exists {\n\t\t\tlogf(\"[READ] Pod %s status: %s\", podID, status.Message)\n\t\t} else {\n\t\t\tlogf(\"[READ] Pod %s not found\", podID)\n\t\t}\n\t\ttime.Sleep(time.Duration(rng.Intn(300)) * time.Millisecond)\n\t}\n}\n\nfunc simulateDeleter(m *Manager, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+2))\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\ttime.Sleep(5 * time.Second)\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rng.Intn(len(podIDs))]\n\t\tm.DeletePod(podID)\n\t\ttime.Sleep(3 * time.Second)\n\t}\n}\n\nfunc main() {\n\trng := rand.New(rand.NewPCG(1, 2))\n\tapiServer := NewApiServer(time.Duration(rng.Intn(41)+10) * time.Millisecond)\n\tmanager := NewManager(apiServer, 100)\n\n\tmanager.Start(2 * time.Second)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tsimulateUpdater(manager, id, 10*time.Second)\n\t\t}(i)\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateReader(manager, 10*time.Second)\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateDeleter(manager, 10*time.Second)\n\t}()\n\n\twg.Wait()\n\n\tmanager.Stop()\n\n\ttime.Sleep(1 * time.Second)\n\n\tupdates, syncs, pods := manager.GetStats()\n\tlogf(\"[STATS] Total updates received: %d\", updates)\n\tlogf(\"[STATS] Total syncs to API: %d\", syncs)\n\tlogf(\"[STATS] Pods in cache: %d\", pods)\n\tlogf(\"[STATS] API server sync count: %d\", apiServer.GetSyncCount())\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:225:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:236:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:242:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:253:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:261:46: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:225:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:236:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:242:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:253:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:261:46: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n\n\nGolang errors in file: [/tmp/go_synthesis_41nbd2qk/main.go]:\n\n  > [line 225 : column 32] - rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n\n  > [line 236 : column 23] - rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n\n  > [line 242 : column 32] - rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n\n  > [line 253 : column 23] - rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n\n  > [line 261 : column 46] - rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n\n\n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:260\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    259: func main() {\n  > 260: \trng := rand.New(rand.NewPCG(1, 2))\n    261: \tapiServer := NewApiServer(time.Duration(rng.Intn(41)+10) * time.Millisecond)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:247\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    246: func simulateDeleter(m *Manager, duration time.Duration) {\n  > 247: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+2))\n    248: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:231\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    230: func simulateReader(m *Manager, duration time.Duration) {\n  > 231: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+1))\n    232: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 299\n  Nosec  : 0\n  Issues : \u001b[1;31m4\u001b[0m\n\n[gosec] 2025/12/01 13:57:43 Including rules: default\n[gosec] 2025/12/01 13:57:43 Excluding rules: default\n[gosec] 2025/12/01 13:57:43 Including analyzers: default\n[gosec] 2025/12/01 13:57:43 Excluding analyzers: default\n[gosec] 2025/12/01 13:57:43 Import directory: /tmp/go_synthesis_41nbd2qk\n[gosec] 2025/12/01 13:57:44 Checking package: main\n[gosec] 2025/12/01 13:57:44 Checking file: /tmp/go_synthesis_41nbd2qk/main.go\n[gosec] 2025/12/01 13:57:44 Panic when running SSA analyzer on package: main. Panic: runtime error: invalid memory address or nil pointer dereference\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xecea40?, 0x1998730?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*Program).packageLevelMember(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/source.go:187\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0009fc270, 0xc000b55a00, {0x11e2648?, 0xc0002c6dc0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:820 +0x1b2b\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0009fc270, 0xc000b55a00, {0x11e2648, 0xc0002c6dc0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0009fc270, 0xc000b55a00, {0x11e26d8?, 0xc000f94f18}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:842 +0x1031\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0009fc270, 0xc000b55a00, {0x11e26d8, 0xc000f94f18})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).setCallFunc(0xc0009fc270?, 0xc000b55a00?, 0xc0009066c0?, 0xc000d337c0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1066 +0x2b6\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc0009fc270, 0xc000b55a00, 0xc0009066c0, 0xc000d337c0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1144 +0x2b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0009fc270, 0xc000b55a00, {0x11e2708?, 0xc0009066c0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:724 +0x2105\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0009fc270, 0xc000b55a00, {0x11e2708, 0xc0009066c0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0009fc270, 0xc000b55a00, {0x11e2708?, 0xc000906700}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:696 +0x1e59\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0009fc270, 0xc000b55a00, {0x11e2708, 0xc000906700})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0009fc270, 0xc000b55a00, {0x11e2678?, 0xc000f972c0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:761 +0x15e9\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0009fc270, 0xc000b55a00, {0x11e2678, 0xc000f972c0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).emitCallArgs(0xc0009fc270, 0xc000b55a00, 0xc0002023c0, 0xc000906740, {0x0?, 0x0, 0x78?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1090 +0x105\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc0009fc270, 0xc000b55a00, 0xc000906740, 0xc000d33740)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1151 +0x85\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0009fc270, 0xc000b55a00, {0x11e2708?, 0xc000906740}, {0x1, {0x11de938, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:724 +0x2105\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0009fc270, 0xc000b55a00, {0x11e2708, 0xc000906740})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc0009fc270, 0xc000b55a00, {0x11e2d00?, 0xc000c824d0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2699 +0xf5f\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc0009fc270, 0xc000b55a00, {0x11e2eb0?, 0xc000f972f0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).forStmt(0xc0009fc270, 0xc000b55a00, 0xc0009067c0, 0x0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1860 +0x6d6\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc0009fc270, 0xc000b55a00, {0x11e3000?, 0xc0009067c0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2788 +0x4b4\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc0009fc270, 0xc000b55a00, {0x11e2eb0?, 0xc000f97320?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc0009fc270, 0xc000b55a00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000b55a00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc0009fc270)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc000ded080)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc00018c480?, 0xc000704b40?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc00106a0e0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc000e041a0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc000728a00, 0xc000e041a0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc000728a00, {0x0, 0x0, 0x0}, {0xc000204d30, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 13:57:44 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_41nbd2qk/main.go:225:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:236:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:242:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:253:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:261:46: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:225:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:236:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:242:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:253:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:261:46: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN) /tmp/go_synthesis_41nbd2qk/main.go:225:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN) /tmp/go_synthesis_41nbd2qk/main.go:236:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN) /tmp/go_synthesis_41nbd2qk/main.go:242:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN) /tmp/go_synthesis_41nbd2qk/main.go:253:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN) /tmp/go_synthesis_41nbd2qk/main.go:261:46: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:225:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:236:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:242:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:253:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:261:46: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:225:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:236:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:242:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:253:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n/tmp/go_synthesis_41nbd2qk/main.go:261:46: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:225:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:236:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:242:32: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:253:23: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN)\n./main.go:261:46: rng.Intn undefined (type *rand.Rand has no field or method Intn, but does have method IntN) (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand/v2\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Status struct {\n\tMessage   string\n\tTimestamp time.Time\n}\n\ntype Pod struct {\n\tUID    string\n\tName   string\n\tStatus Status\n}\n\ntype StatusUpdate struct {\n\tPodUID string\n\tStatus Status\n}\n\ntype ApiServer struct {\n\tmu             sync.RWMutex\n\tstatuses       map[string]Status\n\tsyncCount      int64\n\tnetworkLatency time.Duration\n}\n\nfunc NewApiServer(latency time.Duration) *ApiServer {\n\treturn &ApiServer{\n\t\tstatuses:       make(map[string]Status),\n\t\tnetworkLatency: latency,\n\t}\n}\n\nfunc (as *ApiServer) UpdateStatus(podUID string, status Status) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tas.statuses[podUID] = status\n\tatomic.AddInt64(&as.syncCount, 1)\n\treturn nil\n}\n\nfunc (as *ApiServer) DeleteStatus(podUID string) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tdelete(as.statuses, podUID)\n\treturn nil\n}\n\nfunc (as *ApiServer) GetStatus(podUID string) (Status, bool) {\n\tas.mu.RLock()\n\tdefer as.mu.RUnlock()\n\tstatus, exists := as.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (as *ApiServer) GetSyncCount() int64 {\n\treturn atomic.LoadInt64(&as.syncCount)\n}\n\ntype Manager struct {\n\tmu             sync.RWMutex\n\tstatuses       map[string]Status\n\tupdateQueue    chan StatusUpdate\n\tapiServer      *ApiServer\n\tstopChan       chan struct{}\n\twg             sync.WaitGroup\n\tupdateCount    int64\n\tsyncCount      int64\n\tpendingDeletes map[string]bool\n\tdeleteMu       sync.RWMutex\n}\n\nfunc NewManager(apiServer *ApiServer, queueSize int) *Manager {\n\treturn &Manager{\n\t\tstatuses:       make(map[string]Status),\n\t\tupdateQueue:    make(chan StatusUpdate, queueSize),\n\t\tapiServer:      apiServer,\n\t\tstopChan:       make(chan struct{}),\n\t\tpendingDeletes: make(map[string]bool),\n\t}\n}\n\nfunc (m *Manager) SetPodStatus(podUID string, status Status) {\n\tselect {\n\tcase m.updateQueue <- StatusUpdate{PodUID: podUID, Status: status}:\n\t\tatomic.AddInt64(&m.updateCount, 1)\n\t\tm.mu.Lock()\n\t\tm.statuses[podUID] = status\n\t\tm.mu.Unlock()\n\t\tlogf(\"[UPDATE] Pod %s status set to: %s\", podUID, status.Message)\n\tcase <-m.stopChan:\n\t\tlogf(\"[WARN] Update queue full or manager stopped for pod %s\", podUID)\n\tdefault:\n\t\tlogf(\"[WARN] Update queue full for pod %s\", podUID)\n\t}\n}\n\nfunc (m *Manager) GetPodStatus(podUID string) (Status, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tstatus, exists := m.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (m *Manager) DeletePod(podUID string) {\n\tm.deleteMu.Lock()\n\tm.pendingDeletes[podUID] = true\n\tm.deleteMu.Unlock()\n\n\tm.mu.Lock()\n\tdelete(m.statuses, podUID)\n\tm.mu.Unlock()\n\n\tlogf(\"[DELETE] Pod %s marked for deletion\", podUID)\n}\n\nfunc (m *Manager) SyncBatch() {\n\tm.mu.RLock()\n\tstatusesToSync := make(map[string]Status)\n\tfor uid, status := range m.statuses {\n\t\tstatusesToSync[uid] = status\n\t}\n\tm.mu.RUnlock()\n\n\tlogf(\"[SYNC] Starting sync of %d pod statuses\", len(statusesToSync))\n\n\tsyncedCount := 0\n\tfor podUID, status := range statusesToSync {\n\t\terr := m.apiServer.UpdateStatus(podUID, status)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to sync pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tsyncedCount++\n\t\t}\n\t}\n\n\tm.deleteMu.Lock()\n\tdeletesToSync := make(map[string]bool)\n\tfor podUID := range m.pendingDeletes {\n\t\tdeletesToSync[podUID] = true\n\t}\n\tm.deleteMu.Unlock()\n\n\tfor podUID := range deletesToSync {\n\t\terr := m.apiServer.DeleteStatus(podUID)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to delete pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tm.deleteMu.Lock()\n\t\t\tdelete(m.pendingDeletes, podUID)\n\t\t\tm.deleteMu.Unlock()\n\t\t}\n\t}\n\n\tatomic.AddInt64(&m.syncCount, 1)\n\tlogf(\"[SYNC] Completed sync, %d statuses synchronized\", syncedCount)\n}\n\nfunc (m *Manager) syncWorker(interval time.Duration) {\n\tticker := time.NewTicker(interval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tm.SyncBatch()\n\t\tcase <-m.stopChan:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (m *Manager) Start(syncInterval time.Duration) {\n\tm.wg.Add(1)\n\tgo m.syncWorker(syncInterval)\n\tlogf(\"[START] Manager started with sync interval: %v\", syncInterval)\n}\n\nfunc (m *Manager) Stop() {\n\tlogf(\"[STOP] Stopping manager\")\n\tclose(m.stopChan)\n\tm.wg.Wait()\n\tm.SyncBatch()\n}\n\nfunc (m *Manager) GetStats() (updateCount, syncCount, podCount int64) {\n\tupdateCount = atomic.LoadInt64(&m.updateCount)\n\tsyncCount = atomic.LoadInt64(&m.syncCount)\n\n\tm.mu.RLock()\n\tpodCount = int64(len(m.statuses))\n\tm.mu.RUnlock()\n\n\treturn\n}\n\nvar logMutex sync.Mutex\n\nfunc logf(format string, args ...interface{}) {\n\tlogMutex.Lock()\n\tdefer logMutex.Unlock()\n\tfmt.Printf(\"[%s] %s\\n\", time.Now().Format(\"15:04:05.000\"), fmt.Sprintf(format, args...))\n}\n\nfunc simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n\tendTime := time.Now().Add(duration)\n\tpodID := fmt.Sprintf(\"pod-%d\", goroutineID%3)\n\n\tfor time.Now().Before(endTime) {\n\t\tstatus := Status{\n\t\t\tMessage:   fmt.Sprintf(\"Status from goroutine %d at %d\", goroutineID, time.Now().Unix()),\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t\tm.SetPodStatus(podID, status)\n\t\ttime.Sleep(time.Duration(rng.IntN(500)) * time.Millisecond)\n\t}\n\tlogf(\"[GOROUTINE] Goroutine %d finished\", goroutineID)\n}\n\nfunc simulateReader(m *Manager, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+1))\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rng.IntN(len(podIDs))]\n\t\tif status, exists := m.GetPodStatus(podID); exists {\n\t\t\tlogf(\"[READ] Pod %s status: %s\", podID, status.Message)\n\t\t} else {\n\t\t\tlogf(\"[READ] Pod %s not found\", podID)\n\t\t}\n\t\ttime.Sleep(time.Duration(rng.IntN(300)) * time.Millisecond)\n\t}\n}\n\nfunc simulateDeleter(m *Manager, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+2))\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\ttime.Sleep(5 * time.Second)\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rng.IntN(len(podIDs))]\n\t\tm.DeletePod(podID)\n\t\ttime.Sleep(3 * time.Second)\n\t}\n}\n\nfunc main() {\n\trng := rand.New(rand.NewPCG(1, 2))\n\tapiServer := NewApiServer(time.Duration(rng.IntN(41)+10) * time.Millisecond)\n\tmanager := NewManager(apiServer, 100)\n\n\tmanager.Start(2 * time.Second)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tsimulateUpdater(manager, id, 10*time.Second)\n\t\t}(i)\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateReader(manager, 10*time.Second)\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateDeleter(manager, 10*time.Second)\n\t}()\n\n\twg.Wait()\n\n\tmanager.Stop()\n\n\ttime.Sleep(1 * time.Second)\n\n\tupdates, syncs, pods := manager.GetStats()\n\tlogf(\"[STATS] Total updates received: %d\", updates)\n\tlogf(\"[STATS] Total syncs to API: %d\", syncs)\n\tlogf(\"[STATS] Pods in cache: %d\", pods)\n\tlogf(\"[STATS] API server sync count: %d\", apiServer.GetSyncCount())\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:247\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    246: func simulateDeleter(m *Manager, duration time.Duration) {\n  > 247: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+2))\n    248: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:247\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    246: func simulateDeleter(m *Manager, duration time.Duration) {\n  > 247: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+2))\n    248: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:231\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    230: func simulateReader(m *Manager, duration time.Duration) {\n  > 231: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+1))\n    232: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:231\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    230: func simulateReader(m *Manager, duration time.Duration) {\n  > 231: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+1))\n    232: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G115 (CWE-190): integer overflow conversion int -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:260\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    259: func main() {\n  > 260: \trng := rand.New(rand.NewPCG(1, 2))\n    261: \tapiServer := NewApiServer(time.Duration(rng.IntN(41)+10) * time.Millisecond)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:247\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    246: func simulateDeleter(m *Manager, duration time.Duration) {\n  > 247: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+2))\n    248: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:231\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    230: func simulateReader(m *Manager, duration time.Duration) {\n  > 231: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(time.Now().UnixNano())+1))\n    232: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 299\n  Nosec  : 0\n  Issues : \u001b[1;31m10\u001b[0m\n\n[gosec] 2025/12/01 13:58:00 Including rules: default\n[gosec] 2025/12/01 13:58:00 Excluding rules: default\n[gosec] 2025/12/01 13:58:00 Including analyzers: default\n[gosec] 2025/12/01 13:58:00 Excluding analyzers: default\n[gosec] 2025/12/01 13:58:00 Import directory: /tmp/go_synthesis_41nbd2qk\n[gosec] 2025/12/01 13:58:01 Checking package: main\n[gosec] 2025/12/01 13:58:01 Checking file: /tmp/go_synthesis_41nbd2qk/main.go"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand/v2\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Status struct {\n\tMessage   string\n\tTimestamp time.Time\n}\n\ntype Pod struct {\n\tUID    string\n\tName   string\n\tStatus Status\n}\n\ntype StatusUpdate struct {\n\tPodUID string\n\tStatus Status\n}\n\ntype ApiServer struct {\n\tmu             sync.RWMutex\n\tstatuses       map[string]Status\n\tsyncCount      int64\n\tnetworkLatency time.Duration\n}\n\nfunc NewApiServer(latency time.Duration) *ApiServer {\n\treturn &ApiServer{\n\t\tstatuses:       make(map[string]Status),\n\t\tnetworkLatency: latency,\n\t}\n}\n\nfunc (as *ApiServer) UpdateStatus(podUID string, status Status) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tas.statuses[podUID] = status\n\tatomic.AddInt64(&as.syncCount, 1)\n\treturn nil\n}\n\nfunc (as *ApiServer) DeleteStatus(podUID string) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tdelete(as.statuses, podUID)\n\treturn nil\n}\n\nfunc (as *ApiServer) GetStatus(podUID string) (Status, bool) {\n\tas.mu.RLock()\n\tdefer as.mu.RUnlock()\n\tstatus, exists := as.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (as *ApiServer) GetSyncCount() int64 {\n\treturn atomic.LoadInt64(&as.syncCount)\n}\n\ntype Manager struct {\n\tmu             sync.RWMutex\n\tstatuses       map[string]Status\n\tupdateQueue    chan StatusUpdate\n\tapiServer      *ApiServer\n\tstopChan       chan struct{}\n\twg             sync.WaitGroup\n\tupdateCount    int64\n\tsyncCount      int64\n\tpendingDeletes map[string]bool\n\tdeleteMu       sync.RWMutex\n}\n\nfunc NewManager(apiServer *ApiServer, queueSize int) *Manager {\n\treturn &Manager{\n\t\tstatuses:       make(map[string]Status),\n\t\tupdateQueue:    make(chan StatusUpdate, queueSize),\n\t\tapiServer:      apiServer,\n\t\tstopChan:       make(chan struct{}),\n\t\tpendingDeletes: make(map[string]bool),\n\t}\n}\n\nfunc (m *Manager) SetPodStatus(podUID string, status Status) {\n\tselect {\n\tcase m.updateQueue <- StatusUpdate{PodUID: podUID, Status: status}:\n\t\tatomic.AddInt64(&m.updateCount, 1)\n\t\tm.mu.Lock()\n\t\tm.statuses[podUID] = status\n\t\tm.mu.Unlock()\n\t\tlogf(\"[UPDATE] Pod %s status set to: %s\", podUID, status.Message)\n\tcase <-m.stopChan:\n\t\tlogf(\"[WARN] Update queue full or manager stopped for pod %s\", podUID)\n\tdefault:\n\t\tlogf(\"[WARN] Update queue full for pod %s\", podUID)\n\t}\n}\n\nfunc (m *Manager) GetPodStatus(podUID string) (Status, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tstatus, exists := m.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (m *Manager) DeletePod(podUID string) {\n\tm.deleteMu.Lock()\n\tm.pendingDeletes[podUID] = true\n\tm.deleteMu.Unlock()\n\n\tm.mu.Lock()\n\tdelete(m.statuses, podUID)\n\tm.mu.Unlock()\n\n\tlogf(\"[DELETE] Pod %s marked for deletion\", podUID)\n}\n\nfunc (m *Manager) SyncBatch() {\n\tm.mu.RLock()\n\tstatusesToSync := make(map[string]Status)\n\tfor uid, status := range m.statuses {\n\t\tstatusesToSync[uid] = status\n\t}\n\tm.mu.RUnlock()\n\n\tlogf(\"[SYNC] Starting sync of %d pod statuses\", len(statusesToSync))\n\n\tsyncedCount := 0\n\tfor podUID, status := range statusesToSync {\n\t\terr := m.apiServer.UpdateStatus(podUID, status)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to sync pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tsyncedCount++\n\t\t}\n\t}\n\n\tm.deleteMu.Lock()\n\tdeletesToSync := make(map[string]bool)\n\tfor podUID := range m.pendingDeletes {\n\t\tdeletesToSync[podUID] = true\n\t}\n\tm.deleteMu.Unlock()\n\n\tfor podUID := range deletesToSync {\n\t\terr := m.apiServer.DeleteStatus(podUID)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to delete pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tm.deleteMu.Lock()\n\t\t\tdelete(m.pendingDeletes, podUID)\n\t\t\tm.deleteMu.Unlock()\n\t\t}\n\t}\n\n\tatomic.AddInt64(&m.syncCount, 1)\n\tlogf(\"[SYNC] Completed sync, %d statuses synchronized\", syncedCount)\n}\n\nfunc (m *Manager) syncWorker(interval time.Duration) {\n\tticker := time.NewTicker(interval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tm.SyncBatch()\n\t\tcase <-m.stopChan:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (m *Manager) Start(syncInterval time.Duration) {\n\tm.wg.Add(1)\n\tgo m.syncWorker(syncInterval)\n\tlogf(\"[START] Manager started with sync interval: %v\", syncInterval)\n}\n\nfunc (m *Manager) Stop() {\n\tlogf(\"[STOP] Stopping manager\")\n\tclose(m.stopChan)\n\tm.wg.Wait()\n\tm.SyncBatch()\n}\n\nfunc (m *Manager) GetStats() (updateCount, syncCount, podCount int64) {\n\tupdateCount = atomic.LoadInt64(&m.updateCount)\n\tsyncCount = atomic.LoadInt64(&m.syncCount)\n\n\tm.mu.RLock()\n\tpodCount = int64(len(m.statuses))\n\tm.mu.RUnlock()\n\n\treturn\n}\n\nvar logMutex sync.Mutex\n\nfunc logf(format string, args ...interface{}) {\n\tlogMutex.Lock()\n\tdefer logMutex.Unlock()\n\tfmt.Printf(\"[%s] %s\\n\", time.Now().Format(\"15:04:05.000\"), fmt.Sprintf(format, args...))\n}\n\nfunc simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n\tendTime := time.Now().Add(duration)\n\tpodID := fmt.Sprintf(\"pod-%d\", goroutineID%3)\n\n\tfor time.Now().Before(endTime) {\n\t\tstatus := Status{\n\t\t\tMessage:   fmt.Sprintf(\"Status from goroutine %d at %d\", goroutineID, time.Now().Unix()),\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t\tm.SetPodStatus(podID, status)\n\t\ttime.Sleep(time.Duration(rng.IntN(500)) * time.Millisecond)\n\t}\n\tlogf(\"[GOROUTINE] Goroutine %d finished\", goroutineID)\n}\n\nfunc simulateReader(m *Manager, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(1), uint64(2)))\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rng.IntN(len(podIDs))]\n\t\tif status, exists := m.GetPodStatus(podID); exists {\n\t\t\tlogf(\"[READ] Pod %s status: %s\", podID, status.Message)\n\t\t} else {\n\t\t\tlogf(\"[READ] Pod %s not found\", podID)\n\t\t}\n\t\ttime.Sleep(time.Duration(rng.IntN(300)) * time.Millisecond)\n\t}\n}\n\nfunc simulateDeleter(m *Manager, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(3), uint64(4)))\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\ttime.Sleep(5 * time.Second)\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rng.IntN(len(podIDs))]\n\t\tm.DeletePod(podID)\n\t\ttime.Sleep(3 * time.Second)\n\t}\n}\n\nfunc main() {\n\trng := rand.New(rand.NewPCG(1, 2))\n\tapiServer := NewApiServer(time.Duration(rng.IntN(41)+10) * time.Millisecond)\n\tmanager := NewManager(apiServer, 100)\n\n\tmanager.Start(2 * time.Second)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tsimulateUpdater(manager, id, 10*time.Second)\n\t\t}(i)\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateReader(manager, 10*time.Second)\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateDeleter(manager, 10*time.Second)\n\t}()\n\n\twg.Wait()\n\n\tmanager.Stop()\n\n\ttime.Sleep(1 * time.Second)\n\n\tupdates, syncs, pods := manager.GetStats()\n\tlogf(\"[STATS] Total updates received: %d\", updates)\n\tlogf(\"[STATS] Total syncs to API: %d\", syncs)\n\tlogf(\"[STATS] Pods in cache: %d\", pods)\n\tlogf(\"[STATS] API server sync count: %d\", apiServer.GetSyncCount())\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G115 (CWE-190): integer overflow conversion int -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:260\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    259: func main() {\n  > 260: \trng := rand.New(rand.NewPCG(1, 2))\n    261: \tapiServer := NewApiServer(time.Duration(rng.IntN(41)+10) * time.Millisecond)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:247\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    246: func simulateDeleter(m *Manager, duration time.Duration) {\n  > 247: \trng := rand.New(rand.NewPCG(uint64(3), uint64(4)))\n    248: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:231\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    230: func simulateReader(m *Manager, duration time.Duration) {\n  > 231: \trng := rand.New(rand.NewPCG(uint64(1), uint64(2)))\n    232: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(goroutineID), uint64(time.Now().UnixNano())))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 299\n  Nosec  : 0\n  Issues : \u001b[1;31m6\u001b[0m\n\n[gosec] 2025/12/01 13:58:16 Including rules: default\n[gosec] 2025/12/01 13:58:16 Excluding rules: default\n[gosec] 2025/12/01 13:58:16 Including analyzers: default\n[gosec] 2025/12/01 13:58:16 Excluding analyzers: default\n[gosec] 2025/12/01 13:58:16 Import directory: /tmp/go_synthesis_41nbd2qk\n[gosec] 2025/12/01 13:58:17 Checking package: main\n[gosec] 2025/12/01 13:58:17 Checking file: /tmp/go_synthesis_41nbd2qk/main.go"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand/v2\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype Status struct {\n\tMessage   string\n\tTimestamp time.Time\n}\n\ntype Pod struct {\n\tUID    string\n\tName   string\n\tStatus Status\n}\n\ntype StatusUpdate struct {\n\tPodUID string\n\tStatus Status\n}\n\ntype ApiServer struct {\n\tmu             sync.RWMutex\n\tstatuses       map[string]Status\n\tsyncCount      int64\n\tnetworkLatency time.Duration\n}\n\nfunc NewApiServer(latency time.Duration) *ApiServer {\n\treturn &ApiServer{\n\t\tstatuses:       make(map[string]Status),\n\t\tnetworkLatency: latency,\n\t}\n}\n\nfunc (as *ApiServer) UpdateStatus(podUID string, status Status) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tas.statuses[podUID] = status\n\tatomic.AddInt64(&as.syncCount, 1)\n\treturn nil\n}\n\nfunc (as *ApiServer) DeleteStatus(podUID string) error {\n\ttime.Sleep(as.networkLatency)\n\tas.mu.Lock()\n\tdefer as.mu.Unlock()\n\tdelete(as.statuses, podUID)\n\treturn nil\n}\n\nfunc (as *ApiServer) GetStatus(podUID string) (Status, bool) {\n\tas.mu.RLock()\n\tdefer as.mu.RUnlock()\n\tstatus, exists := as.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (as *ApiServer) GetSyncCount() int64 {\n\treturn atomic.LoadInt64(&as.syncCount)\n}\n\ntype Manager struct {\n\tmu             sync.RWMutex\n\tstatuses       map[string]Status\n\tupdateQueue    chan StatusUpdate\n\tapiServer      *ApiServer\n\tstopChan       chan struct{}\n\twg             sync.WaitGroup\n\tupdateCount    int64\n\tsyncCount      int64\n\tpendingDeletes map[string]bool\n\tdeleteMu       sync.RWMutex\n}\n\nfunc NewManager(apiServer *ApiServer, queueSize int) *Manager {\n\treturn &Manager{\n\t\tstatuses:       make(map[string]Status),\n\t\tupdateQueue:    make(chan StatusUpdate, queueSize),\n\t\tapiServer:      apiServer,\n\t\tstopChan:       make(chan struct{}),\n\t\tpendingDeletes: make(map[string]bool),\n\t}\n}\n\nfunc (m *Manager) SetPodStatus(podUID string, status Status) {\n\tselect {\n\tcase m.updateQueue <- StatusUpdate{PodUID: podUID, Status: status}:\n\t\tatomic.AddInt64(&m.updateCount, 1)\n\t\tm.mu.Lock()\n\t\tm.statuses[podUID] = status\n\t\tm.mu.Unlock()\n\t\tlogf(\"[UPDATE] Pod %s status set to: %s\", podUID, status.Message)\n\tcase <-m.stopChan:\n\t\tlogf(\"[WARN] Update queue full or manager stopped for pod %s\", podUID)\n\tdefault:\n\t\tlogf(\"[WARN] Update queue full for pod %s\", podUID)\n\t}\n}\n\nfunc (m *Manager) GetPodStatus(podUID string) (Status, bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tstatus, exists := m.statuses[podUID]\n\treturn status, exists\n}\n\nfunc (m *Manager) DeletePod(podUID string) {\n\tm.deleteMu.Lock()\n\tm.pendingDeletes[podUID] = true\n\tm.deleteMu.Unlock()\n\n\tm.mu.Lock()\n\tdelete(m.statuses, podUID)\n\tm.mu.Unlock()\n\n\tlogf(\"[DELETE] Pod %s marked for deletion\", podUID)\n}\n\nfunc (m *Manager) SyncBatch() {\n\tm.mu.RLock()\n\tstatusesToSync := make(map[string]Status)\n\tfor uid, status := range m.statuses {\n\t\tstatusesToSync[uid] = status\n\t}\n\tm.mu.RUnlock()\n\n\tlogf(\"[SYNC] Starting sync of %d pod statuses\", len(statusesToSync))\n\n\tsyncedCount := 0\n\tfor podUID, status := range statusesToSync {\n\t\terr := m.apiServer.UpdateStatus(podUID, status)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to sync pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tsyncedCount++\n\t\t}\n\t}\n\n\tm.deleteMu.Lock()\n\tdeletesToSync := make(map[string]bool)\n\tfor podUID := range m.pendingDeletes {\n\t\tdeletesToSync[podUID] = true\n\t}\n\tm.deleteMu.Unlock()\n\n\tfor podUID := range deletesToSync {\n\t\terr := m.apiServer.DeleteStatus(podUID)\n\t\tif err != nil {\n\t\t\tlogf(\"[ERROR] Failed to delete pod %s: %v\", podUID, err)\n\t\t} else {\n\t\t\tm.deleteMu.Lock()\n\t\t\tdelete(m.pendingDeletes, podUID)\n\t\t\tm.deleteMu.Unlock()\n\t\t}\n\t}\n\n\tatomic.AddInt64(&m.syncCount, 1)\n\tlogf(\"[SYNC] Completed sync, %d statuses synchronized\", syncedCount)\n}\n\nfunc (m *Manager) syncWorker(interval time.Duration) {\n\tticker := time.NewTicker(interval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tm.SyncBatch()\n\t\tcase <-m.stopChan:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (m *Manager) Start(syncInterval time.Duration) {\n\tm.wg.Add(1)\n\tgo m.syncWorker(syncInterval)\n\tlogf(\"[START] Manager started with sync interval: %v\", syncInterval)\n}\n\nfunc (m *Manager) Stop() {\n\tlogf(\"[STOP] Stopping manager\")\n\tclose(m.stopChan)\n\tm.wg.Wait()\n\tm.SyncBatch()\n}\n\nfunc (m *Manager) GetStats() (updateCount, syncCount, podCount int64) {\n\tupdateCount = atomic.LoadInt64(&m.updateCount)\n\tsyncCount = atomic.LoadInt64(&m.syncCount)\n\n\tm.mu.RLock()\n\tpodCount = int64(len(m.statuses))\n\tm.mu.RUnlock()\n\n\treturn\n}\n\nvar logMutex sync.Mutex\n\nfunc logf(format string, args ...interface{}) {\n\tlogMutex.Lock()\n\tdefer logMutex.Unlock()\n\tfmt.Printf(\"[%s] %s\\n\", time.Now().Format(\"15:04:05.000\"), fmt.Sprintf(format, args...))\n}\n\nfunc simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(goroutineID)))\n\tendTime := time.Now().Add(duration)\n\tpodID := fmt.Sprintf(\"pod-%d\", goroutineID%3)\n\n\tfor time.Now().Before(endTime) {\n\t\tstatus := Status{\n\t\t\tMessage:   fmt.Sprintf(\"Status from goroutine %d at %d\", goroutineID, time.Now().Unix()),\n\t\t\tTimestamp: time.Now(),\n\t\t}\n\t\tm.SetPodStatus(podID, status)\n\t\ttime.Sleep(time.Duration(rng.IntN(500)) * time.Millisecond)\n\t}\n\tlogf(\"[GOROUTINE] Goroutine %d finished\", goroutineID)\n}\n\nfunc simulateReader(m *Manager, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 2))\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rng.IntN(len(podIDs))]\n\t\tif status, exists := m.GetPodStatus(podID); exists {\n\t\t\tlogf(\"[READ] Pod %s status: %s\", podID, status.Message)\n\t\t} else {\n\t\t\tlogf(\"[READ] Pod %s not found\", podID)\n\t\t}\n\t\ttime.Sleep(time.Duration(rng.IntN(300)) * time.Millisecond)\n\t}\n}\n\nfunc simulateDeleter(m *Manager, duration time.Duration) {\n\trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 4))\n\tendTime := time.Now().Add(duration)\n\tpodIDs := []string{\"pod-0\", \"pod-1\", \"pod-2\"}\n\n\ttime.Sleep(5 * time.Second)\n\tfor time.Now().Before(endTime) {\n\t\tpodID := podIDs[rng.IntN(len(podIDs))]\n\t\tm.DeletePod(podID)\n\t\ttime.Sleep(3 * time.Second)\n\t}\n}\n\nfunc main() {\n\trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 2))\n\tapiServer := NewApiServer(time.Duration(rng.IntN(41)+10) * time.Millisecond)\n\tmanager := NewManager(apiServer, 100)\n\n\tmanager.Start(2 * time.Second)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\tsimulateUpdater(manager, id, 10*time.Second)\n\t\t}(i)\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateReader(manager, 10*time.Second)\n\t}()\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tsimulateDeleter(manager, 10*time.Second)\n\t}()\n\n\twg.Wait()\n\n\tmanager.Stop()\n\n\ttime.Sleep(1 * time.Second)\n\n\tupdates, syncs, pods := manager.GetStats()\n\tlogf(\"[STATS] Total updates received: %d\", updates)\n\tlogf(\"[STATS] Total syncs to API: %d\", syncs)\n\tlogf(\"[STATS] Pods in cache: %d\", pods)\n\tlogf(\"[STATS] API server sync count: %d\", apiServer.GetSyncCount())\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:260\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    259: func main() {\n  > 260: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 2))\n    261: \tapiServer := NewApiServer(time.Duration(rng.IntN(41)+10) * time.Millisecond)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:247\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    246: func simulateDeleter(m *Manager, duration time.Duration) {\n  > 247: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 4))\n    248: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:231\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    230: func simulateReader(m *Manager, duration time.Duration) {\n  > 231: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 2))\n    232: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(goroutineID)))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G115 (CWE-190): integer overflow conversion int -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(goroutineID)))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:260\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    259: func main() {\n  > 260: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 2))\n    261: \tapiServer := NewApiServer(time.Duration(rng.IntN(41)+10) * time.Millisecond)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:247\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    246: func simulateDeleter(m *Manager, duration time.Duration) {\n  > 247: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 4))\n    248: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:231\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    230: func simulateReader(m *Manager, duration time.Duration) {\n  > 231: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), 2))\n    232: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_41nbd2qk/main.go:215\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    214: func simulateUpdater(m *Manager, goroutineID int, duration time.Duration) {\n  > 215: \trng := rand.New(rand.NewPCG(uint64(time.Now().UnixNano()), uint64(goroutineID)))\n    216: \tendTime := time.Now().Add(duration)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 299\n  Nosec  : 0\n  Issues : \u001b[1;31m9\u001b[0m\n\n[gosec] 2025/12/01 13:58:33 Including rules: default\n[gosec] 2025/12/01 13:58:33 Excluding rules: default\n[gosec] 2025/12/01 13:58:33 Including analyzers: default\n[gosec] 2025/12/01 13:58:33 Excluding analyzers: default\n[gosec] 2025/12/01 13:58:33 Import directory: /tmp/go_synthesis_41nbd2qk\n[gosec] 2025/12/01 13:58:33 Checking package: main\n[gosec] 2025/12/01 13:58:33 Checking file: /tmp/go_synthesis_41nbd2qk/main.go"
                }
            ]
        }
    ],
    "passed": false
}