{
    "task": "36f5b713bf4cad4702163ed9476ea83de9059b3d.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Cache struct {\n\tdata map[string]string\n\tmu   sync.RWMutex\n}\n\nfunc NewCache() *Cache {\n\treturn &Cache{\n\t\tdata: make(map[string]string),\n\t}\n}\n\nfunc (c *Cache) Get(key string) (string, bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tval, ok := c.data[key]\n\treturn val, ok\n}\n\nfunc (c *Cache) Put(key, value string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.data[key] = value\n}\n\nfunc (c *Cache) Close() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tfmt.Println(\"Cache closed and resources cleaned up\")\n\tc.data = make(map[string]string)\n}\n\ntype Client struct {\n\tctx    context.Context\n\tcancel context.CancelFunc\n}\n\nfunc NewClient(parentCtx context.Context) *Client {\n\tctx, cancel := context.WithCancel(parentCtx)\n\treturn &Client{\n\t\tctx:    ctx,\n\t\tcancel: cancel,\n\t}\n}\n\nfunc (c *Client) Context() context.Context {\n\treturn c.ctx\n}\n\nfunc (c *Client) Close() {\n\tc.cancel()\n}\n\ntype KVProxy struct {\n\tclient *Client\n\tcache  *Cache\n\tdone   chan struct{}\n}\n\nfunc NewKVProxy(client *Client) (*KVProxy, chan struct{}) {\n\tdone := make(chan struct{})\n\tproxy := &KVProxy{\n\t\tclient: client,\n\t\tcache:  NewCache(),\n\t\tdone:   done,\n\t}\n\n\tgo func() {\n\t\t<-client.Context().Done()\n\t\tproxy.cache.Close()\n\t\tclose(done)\n\t}()\n\n\treturn proxy, done\n}\n\nfunc (p *KVProxy) Get(key string) (string, bool) {\n\tselect {\n\tcase <-p.client.Context().Done():\n\t\treturn \"\", false\n\tdefault:\n\t\treturn p.cache.Get(key)\n\t}\n}\n\nfunc (p *KVProxy) Put(key, value string) error {\n\tselect {\n\tcase <-p.client.Context().Done():\n\t\treturn fmt.Errorf(\"proxy is closed\")\n\tdefault:\n\t\tp.cache.Put(key, value)\n\t\treturn nil\n\t}\n}\n\nfunc main() {\n\tstartGoroutines := runtime.NumGoroutine()\n\tfmt.Printf(\"Starting goroutines: %d\\n\", startGoroutines)\n\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel()\n\n\tclients := make([]*Client, 3)\n\tproxies := make([]*KVProxy, 3)\n\tdoneChannels := make([]chan struct{}, 3)\n\n\tfor i := 0; i < 3; i++ {\n\t\tclients[i] = NewClient(ctx)\n\t\tproxies[i], doneChannels[i] = NewKVProxy(clients[i])\n\t\tfmt.Printf(\"Created proxy %d\\n\", i+1)\n\t}\n\n\tfmt.Println(\"Performing operations...\")\n\tfor i := 0; i < 3; i++ {\n\t\terr := proxies[i].Put(fmt.Sprintf(\"key%d\", i), fmt.Sprintf(\"value%d\", i))\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error putting key%d: %v\\n\", i, err)\n\t\t}\n\t\tval, ok := proxies[i].Get(fmt.Sprintf(\"key%d\", i))\n\t\tif ok {\n\t\t\tfmt.Printf(\"Proxy %d: key%d = %s\\n\", i+1, i, val)\n\t\t}\n\t}\n\n\tfmt.Println(\"Closing clients...\")\n\tfor i := 0; i < 3; i++ {\n\t\tclients[i].Close()\n\t}\n\n\tfmt.Println(\"Waiting for cleanup...\")\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 3; i++ {\n\t\twg.Add(1)\n\t\tgo func(done chan struct{}) {\n\t\t\tdefer wg.Done()\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-ctx.Done():\n\t\t\t}\n\t\t}(doneChannels[i])\n\t}\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\tcase <-ctx.Done():\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\tendGoroutines := runtime.NumGoroutine()\n\tfmt.Printf(\"Ending goroutines: %d\\n\", endGoroutines)\n\n\tif endGoroutines <= startGoroutines {\n\t\tfmt.Println(\"Program completed successfully\")\n\t} else {\n\t\tfmt.Printf(\"Warning: goroutine leak detected (started: %d, ended: %d)\\n\", startGoroutines, endGoroutines)\n\t}\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}