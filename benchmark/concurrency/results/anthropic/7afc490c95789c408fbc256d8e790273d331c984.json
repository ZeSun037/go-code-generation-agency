{
    "task": "7afc490c95789c408fbc256d8e790273d331c984.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype CoordinatorStatus struct {\n\tTasksProcessed int\n\tIsRunning      bool\n\tCurrentState   string\n}\n\ntype TaskCoordinator struct {\n\tmu              sync.RWMutex\n\ttasksProcessed  int\n\tisRunning       bool\n\tstopChan        chan struct{}\n\tstoppedChan     chan struct{}\n}\n\nfunc NewTaskCoordinator() *TaskCoordinator {\n\treturn &TaskCoordinator{\n\t\ttasksProcessed: 0,\n\t\tisRunning:      false,\n\t\tstopChan:       make(chan struct{}),\n\t\tstoppedChan:    make(chan struct{}),\n\t}\n}\n\nfunc (tc *TaskCoordinator) Start() {\n\ttc.mu.Lock()\n\tif tc.isRunning {\n\t\ttc.mu.Unlock()\n\t\treturn\n\t}\n\ttc.isRunning = true\n\ttc.mu.Unlock()\n\n\tgo tc.eventLoop()\n}\n\nfunc (tc *TaskCoordinator) eventLoop() {\n\tticker := time.NewTicker(50 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-tc.stopChan:\n\t\t\ttc.mu.Lock()\n\t\t\ttc.isRunning = false\n\t\t\ttc.mu.Unlock()\n\t\t\tclose(tc.stoppedChan)\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\ttc.mu.Lock()\n\t\t\ttc.tasksProcessed++\n\t\t\ttc.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (tc *TaskCoordinator) Stop() {\n\ttc.mu.RLock()\n\tisRunning := tc.isRunning\n\ttc.mu.RUnlock()\n\n\tif isRunning {\n\t\tclose(tc.stopChan)\n\t\t<-tc.stoppedChan\n\t}\n}\n\nfunc (tc *TaskCoordinator) Status() CoordinatorStatus {\n\ttc.mu.RLock()\n\tdefer tc.mu.RUnlock()\n\n\tstate := \"stopped\"\n\tif tc.isRunning {\n\t\tstate = \"processing\"\n\t}\n\n\treturn CoordinatorStatus{\n\t\tTasksProcessed: tc.tasksProcessed,\n\t\tIsRunning:      tc.isRunning,\n\t\tCurrentState:   state,\n\t}\n}\n\nfunc queryStatus(goroutineID int, coordinator *TaskCoordinator, queryCount int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\n\tfor i := 0; i < queryCount; i++ {\n\t\tstatus := coordinator.Status()\n\t\tfmt.Printf(\"Goroutine %d: Status{TasksProcessed: %d, IsRunning: %v, CurrentState: \\\"%s\\\"}\\n\",\n\t\t\tgoroutineID, status.TasksProcessed, status.IsRunning, status.CurrentState)\n\t\ttime.Sleep(200 * time.Millisecond)\n\t}\n}\n\nfunc main() {\n\tcoordinator := NewTaskCoordinator()\n\tcoordinator.Start()\n\n\tvar wg sync.WaitGroup\n\n\tnumGoroutines := 3\n\tqueriesPerGoroutine := 4\n\n\tfor i := 1; i <= numGoroutines; i++ {\n\t\twg.Add(1)\n\t\tgo queryStatus(i, coordinator, queriesPerGoroutine, &wg)\n\t}\n\n\ttime.Sleep(1 * time.Second)\n\n\tfmt.Println(\"Coordinator stopping...\")\n\tcoordinator.Stop()\n\tfmt.Println(\"Coordinator stopped\")\n\n\ttime.Sleep(500 * time.Millisecond)\n\n\tfor i := 1; i <= numGoroutines; i++ {\n\t\twg.Add(1)\n\t\tgo queryStatus(i, coordinator, 1, &wg)\n\t}\n\n\twg.Wait()\n\n\tfmt.Println(\"Program completed successfully\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}