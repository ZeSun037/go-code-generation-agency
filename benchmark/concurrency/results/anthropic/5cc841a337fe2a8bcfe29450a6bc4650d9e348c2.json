{
    "task": "5cc841a337fe2a8bcfe29450a6bc4650d9e348c2.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Task struct {\n\tName             string\n\tRequiredCapacity int\n\tRequiredSkills   []string\n\tRequiredLocation string\n}\n\ntype Worker struct {\n\tName             string\n\tCapacity         int\n\tSkills           []string\n\tLocation         string\n\tCurrentLoad      int\n}\n\ntype CacheEntry struct {\n\tFit     bool\n\tReasons []string\n\tTime    time.Time\n}\n\ntype Cache struct {\n\tmu       sync.RWMutex\n\tentries  map[string]CacheEntry\n\tttl      time.Duration\n\tinvalidated map[string]time.Time\n}\n\ntype SchedulingResult struct {\n\tTaskName     string\n\tWorkerName   string\n\tCanAssign    bool\n\tReasons      []string\n\tCacheHit     bool\n}\n\ntype Predicate func(task Task, worker Worker) (bool, []string, error)\n\nfunc NewCache(ttl time.Duration) *Cache {\n\treturn &Cache{\n\t\tentries:     make(map[string]CacheEntry),\n\t\tttl:         ttl,\n\t\tinvalidated: make(map[string]time.Time),\n\t}\n}\n\nfunc (c *Cache) getCacheKey(taskName, workerName, predicateName string) string {\n\treturn fmt.Sprintf(\"%s:%s:%s\", taskName, workerName, predicateName)\n}\n\nfunc (c *Cache) GetCachedResult(taskName, workerName, predicateName string) (fit bool, reasons []string, valid bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tkey := c.getCacheKey(taskName, workerName, predicateName)\n\n\tif invalidTime, exists := c.invalidated[key]; exists {\n\t\treturn false, nil, false\n\t}\n\n\tentry, exists := c.entries[key]\n\tif !exists {\n\t\treturn false, nil, false\n\t}\n\n\tif time.Since(entry.Time) > c.ttl {\n\t\treturn false, nil, false\n\t}\n\n\treturn entry.Fit, entry.Reasons, true\n}\n\nfunc (c *Cache) UpdateCache(taskName, workerName, predicateName string, fit bool, reasons []string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tkey := c.getCacheKey(taskName, workerName, predicateName)\n\tc.entries[key] = CacheEntry{\n\t\tFit:     fit,\n\t\tReasons: reasons,\n\t\tTime:    time.Now(),\n\t}\n\tdelete(c.invalidated, key)\n}\n\nfunc (c *Cache) InvalidateWorkerCache(workerName string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tnow := time.Now()\n\tfor key := range c.entries {\n\t\tif len(key) > 0 {\n\t\t\tparts := parseKey(key)\n\t\t\tif len(parts) >= 2 && parts[1] == workerName {\n\t\t\t\tc.invalidated[key] = now\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc parseKey(key string) []string {\n\tvar result []string\n\tvar current string\n\tfor i := 0; i < len(key); i++ {\n\t\tif key[i] == ':' {\n\t\t\tresult = append(result, current)\n\t\t\tcurrent = \"\"\n\t\t} else {\n\t\t\tcurrent += string(key[i])\n\t\t}\n\t}\n\tresult = append(result, current)\n\treturn result\n}\n\nfunc (c *Cache) Clear() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.entries = make(map[string]CacheEntry)\n\tc.invalidated = make(map[string]time.Time)\n}\n\nfunc PredicateCapacity(task Task, worker Worker) (bool, []string, error) {\n\treasons := []string{}\n\tavailableCapacity := worker.Capacity - worker.CurrentLoad\n\tif availableCapacity < task.RequiredCapacity {\n\t\treasons = append(reasons, fmt.Sprintf(\"Insufficient capacity: required %d, available %d\", task.RequiredCapacity, availableCapacity))\n\t\treturn false, reasons, nil\n\t}\n\treturn true, []string{fmt.Sprintf(\"Sufficient capacity available: %d\", availableCapacity)}, nil\n}\n\nfunc PredicateSkills(task Task, worker Worker) (bool, []string, error) {\n\treasons := []string{}\n\tskillMap := make(map[string]bool)\n\tfor _, skill := range worker.Skills {\n\t\tskillMap[skill] = true\n\t}\n\n\tmissingSkills := []string{}\n\tfor _, requiredSkill := range task.RequiredSkills {\n\t\tif !skillMap[requiredSkill] {\n\t\t\tmissingSkills = append(missingSkills, requiredSkill)\n\t\t}\n\t}\n\n\tif len(missingSkills) > 0 {\n\t\treasons = append(reasons, fmt.Sprintf(\"Missing skills: %v\", missingSkills))\n\t\treturn false, reasons, nil\n\t}\n\n\treasons = append(reasons, fmt.Sprintf(\"Has all required skills: %v\", task.RequiredSkills))\n\treturn true, reasons, nil\n}\n\nfunc PredicateLocation(task Task, worker Worker) (bool, []string, error) {\n\treasons := []string{}\n\tif worker.Location != task.RequiredLocation {\n\t\treasons = append(reasons, fmt.Sprintf(\"Wrong location: worker at %s, task requires %s\", worker.Location, task.RequiredLocation))\n\t\treturn false, reasons, nil\n\t}\n\treasons = append(reasons, fmt.Sprintf(\"Worker at correct location: %s\", worker.Location))\n\treturn true, reasons, nil\n}\n\nfunc ScheduleTask(task Task, worker Worker, predicates []Predicate, cache *Cache) (bool, []string, map[string]bool) {\n\tallReasons := []string{}\n\tcacheHits := make(map[string]bool)\n\n\tfor i, predicate := range predicates {\n\t\tpredicateName := fmt.Sprintf(\"predicate_%d\", i)\n\n\t\tcachedFit, cachedReasons, valid := cache.GetCachedResult(task.Name, worker.Name, predicateName)\n\t\tif valid {\n\t\t\tcacheHits[predicateName] = true\n\t\t\tif !cachedFit {\n\t\t\t\tallReasons = append(allReasons, cachedReasons...)\n\t\t\t\treturn false, allReasons, cacheHits\n\t\t\t}\n\t\t\tallReasons = append(allReasons, cachedReasons...)\n\t\t\tcontinue\n\t\t}\n\n\t\tfit, reasons, err := predicate(task, worker)\n\t\tif err != nil {\n\t\t\tallReasons = append(allReasons, fmt.Sprintf(\"Error in predicate %d: %v\", i, err))\n\t\t\treturn false, allReasons, cacheHits\n\t\t}\n\n\t\tcache.UpdateCache(task.Name, worker.Name, predicateName, fit, reasons)\n\t\tcacheHits[predicateName] = false\n\n\t\tif !fit {\n\t\t\tallReasons = append(allReasons, reasons...)\n\t\t\treturn false, allReasons, cacheHits\n\t\t}\n\n\t\tallReasons = append(allReasons, reasons...)\n\t}\n\n\treturn true, allReasons, cacheHits\n}\n\nfunc main() {\n\tcache := NewCache(5 * time.Second)\n\n\tworkers := []Worker{\n\t\t{Name: \"Worker-1\", Capacity: 100, Skills: []string{\"Python\", \"Docker\"}, Location: \"NYC\", CurrentLoad: 30},\n\t\t{Name: \"Worker-2\", Capacity: 80, Skills: []string{\"Java\", \"Kubernetes\"}, Location: \"SF\", CurrentLoad: 20},\n\t\t{Name: \"Worker-3\", Capacity: 120, Skills: []string{\"Python\", \"Java\", \"Docker\"}, Location: \"NYC\", CurrentLoad: 50},\n\t\t{Name: \"Worker-4\", Capacity: 60, Skills: []string{\"Go\", \"Rust\"}, Location: \"Austin\", CurrentLoad: 10},\n\t\t{Name: \"Worker-5\", Capacity: 150, Skills: []string{\"Python\", \"Java\", \"Go\", \"Docker\"}, Location: \"SF\", CurrentLoad: 80},\n\t}\n\n\ttasks := []Task{\n\t\t{Name: \"Task-1\", RequiredCapacity: 30, RequiredSkills: []string{\"Python\", \"Docker\"}, RequiredLocation: \"NYC\"},\n\t\t{Name: \"Task-2\", RequiredCapacity: 50, RequiredSkills: []string{\"Java\", \"Kubernetes\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"Task-3\", RequiredCapacity: 20, RequiredSkills: []string{\"Python\"}, RequiredLocation: \"NYC\"},\n\t\t{Name: \"Task-4\", RequiredCapacity: 40, RequiredSkills: []string{\"Go\", \"Rust\"}, RequiredLocation: \"Austin\"},\n\t\t{Name: \"Task-5\", RequiredCapacity: 35, RequiredSkills: []string{\"Java\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"Task-6\", RequiredCapacity: 25, RequiredSkills: []string{\"Docker\"}, RequiredLocation: \"NYC\"},\n\t\t{Name: \"Task-7\", RequiredCapacity: 15, RequiredSkills: []string{\"Go\"}, RequiredLocation: \"Austin\"},\n\t\t{Name: \"Task-8\", RequiredCapacity: 60, RequiredSkills: []string{\"Python\", \"Docker\", \"Java\"}, RequiredLocation: \"NYC\"},\n\t\t{Name: \"Task-9\", RequiredCapacity: 10, RequiredSkills: []string{\"Rust\"}, RequiredLocation: \"Austin\"},\n\t\t{Name: \"Task-10\", RequiredCapacity: 70, RequiredSkills: []string{\"Python\", \"Java\"}, RequiredLocation: \"SF\"},\n\t}\n\n\tpredicates := []Predicate{\n\t\tPredicateCapacity,\n\t\tPredicateSkills,\n\t\tPredicateLocation,\n\t}\n\n\tresultsChan := make(chan SchedulingResult, len(tasks)*len(workers))\n\tvar wg sync.WaitGroup\n\n\tgo func() {\n\t\tticker := time.NewTicker(2 * time.Second)\n\t\tdefer ticker.Stop()\n\t\tcount := 0\n\t\tfor range ticker.C {\n\t\t\tcount++\n\t\t\tif count > 2 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif count%2 == 0 && len(workers) > 0 {\n\t\t\t\tfmt.Printf(\"\\n[Event Handler] Invalidating cache for %s due to capacity change\\n\", workers[0].Name)\n\t\t\t\tcache.InvalidateWorkerCache(workers[0].Name)\n\t\t\t\tworkers[0].CurrentLoad += 20\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor _, task := range tasks {\n\t\tfor _, worker := range workers {\n\t\t\twg.Add(1)\n\t\t\tgo func(t Task, w Worker) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfit, reasons, cacheHits := ScheduleTask(t, w, predicates, cache)\n\t\t\t\tcacheHitCount := 0\n\t\t\t\tfor _, hit := range cacheHits {\n\t\t\t\t\tif hit {\n\t\t\t\t\t\tcacheHitCount++\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult := SchedulingResult{\n\t\t\t\t\tTaskName:   t.Name,\n\t\t\t\t\tWorkerName: w.Name,\n\t\t\t\t\tCanAssign:  fit,\n\t\t\t\t\tReasons:    reasons,\n\t\t\t\t\tCacheHit:   cacheHitCount > 0,\n\t\t\t\t}\n\t\t\t\tresultsChan <- result\n\t\t\t}(task, worker)\n\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}\n\n\twg.Wait()\n\tclose(resultsChan)\n\n\tfmt.Println(\"\\n=== SCHEDULING RESULTS ===\\n\")\n\n\tassignmentMap := make(map[string]string)\n\tfor result := range resultsChan {\n\t\tcacheIndicator := \"\"\n\t\tif result.CacheHit {\n\t\t\tcacheIndicator = \" [CACHE HIT]\"\n\t\t}\n\t\tstatus := \"\u2717 REJECTED\"\n\t\tif result.CanAssign {\n\t\t\tstatus = \"\u2713 ASSIGNED\"\n\t\t\tassignmentMap[result.TaskName] = result.WorkerName\n\t\t}\n\n\t\tfmt.Printf(\"%s -> %s: %s%s\\n\", result.TaskName, result.WorkerName, status, cacheIndicator)\n\t\tif !result.CanAssign && len(result.Reasons) > 0 {\n\t\t\tfmt.Printf(\"  Reasons: %v\\n\", result.Reasons)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\n=== FINAL ASSIGNMENTS ===\\n\")\n\tif len(assignmentMap) == 0 {\n\t\tfmt.Println(\"No tasks were assigned.\")\n\t} else {\n\t\tfor task, worker := range assignmentMap {\n\t\t\tfmt.Printf(\"%s -> %s\\n\", task, worker)\n\t\t}\n\t}\n\n\tfmt.Printf(\"\\nTotal tasks: %d\\n\", len(tasks))\n\tfmt.Printf(\"Assigned tasks: %d\\n\", len(assignmentMap))\n\tfmt.Printf(\"Unassigned tasks: %d\\n\", len(tasks)-len(assignmentMap))\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:65:5: declared and not used: invalidTime"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:65:5: declared and not used: invalidTime\n\n\nGolang errors in file: [/tmp/go_synthesis_h51073bb/main.go]:\n\n  > [line 65 : column 5] - declared and not used: invalidTime\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 324\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 13:49:00 Including rules: default\n[gosec] 2025/12/01 13:49:00 Excluding rules: default\n[gosec] 2025/12/01 13:49:00 Including analyzers: default\n[gosec] 2025/12/01 13:49:00 Excluding analyzers: default\n[gosec] 2025/12/01 13:49:00 Import directory: /tmp/go_synthesis_h51073bb\n[gosec] 2025/12/01 13:49:00 Checking package: main\n[gosec] 2025/12/01 13:49:00 Checking file: /tmp/go_synthesis_h51073bb/main.go"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_h51073bb/main.go:65:5: declared and not used: invalidTime\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:65:5: declared and not used: invalidTime /tmp/go_synthesis_h51073bb/main.go:65:5: declared and not used: invalidTime]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:65:5: declared and not used: invalidTime\n/tmp/go_synthesis_h51073bb/main.go:65:5: declared and not used: invalidTime\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:65:5: declared and not used: invalidTime (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Task struct {\n\tName             string\n\tRequiredCapacity int\n\tRequiredSkills   []string\n\tRequiredLocation string\n}\n\ntype Worker struct {\n\tName        string\n\tCapacity    int\n\tSkills      []string\n\tLocation    string\n\tCurrentLoad int\n}\n\ntype CacheEntry struct {\n\tFit     bool\n\tReasons []string\n\tTime    time.Time\n}\n\ntype Cache struct {\n\tmu          sync.RWMutex\n\tentries     map[string]CacheEntry\n\tttl         time.Duration\n\tinvalidated map[string]time.Time\n}\n\ntype SchedulingResult struct {\n\tTaskName   string\n\tWorkerName string\n\tCanAssign  bool\n\tReasons    []string\n\tCacheHit   bool\n}\n\ntype Predicate func(task Task, worker Worker) (bool, []string, error)\n\nfunc NewCache(ttl time.Duration) *Cache {\n\treturn &Cache{\n\t\tentries:     make(map[string]CacheEntry),\n\t\tttl:         ttl,\n\t\tinvalidated: make(map[string]time.Time),\n\t}\n}\n\nfunc (c *Cache) getCacheKey(taskName, workerName, predicateName string) string {\n\treturn fmt.Sprintf(\"%s:%s:%s\", taskName, workerName, predicateName)\n}\n\nfunc (c *Cache) GetCachedResult(taskName, workerName, predicateName string) (fit bool, reasons []string, valid bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tkey := c.getCacheKey(taskName, workerName, predicateName)\n\n\tif _, exists := c.invalidated[key]; exists {\n\t\treturn false, nil, false\n\t}\n\n\tentry, exists := c.entries[key]\n\tif !exists {\n\t\treturn false, nil, false\n\t}\n\n\tif time.Since(entry.Time) > c.ttl {\n\t\treturn false, nil, false\n\t}\n\n\treturn entry.Fit, entry.Reasons, true\n}\n\nfunc (c *Cache) UpdateCache(taskName, workerName, predicateName string, fit bool, reasons []string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tkey := c.getCacheKey(taskName, workerName, predicateName)\n\tc.entries[key] = CacheEntry{\n\t\tFit:     fit,\n\t\tReasons: reasons,\n\t\tTime:    time.Now(),\n\t}\n\tdelete(c.invalidated, key)\n}\n\nfunc (c *Cache) InvalidateWorkerCache(workerName string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tnow := time.Now()\n\tfor key := range c.entries {\n\t\tif len(key) > 0 {\n\t\t\tparts := parseKey(key)\n\t\t\tif len(parts) >= 2 && parts[1] == workerName {\n\t\t\t\tc.invalidated[key] = now\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc parseKey(key string) []string {\n\tvar result []string\n\tvar current string\n\tfor i := 0; i < len(key); i++ {\n\t\tif key[i] == ':' {\n\t\t\tresult = append(result, current)\n\t\t\tcurrent = \"\"\n\t\t} else {\n\t\t\tcurrent += string(key[i])\n\t\t}\n\t}\n\tresult = append(result, current)\n\treturn result\n}\n\nfunc (c *Cache) Clear() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.entries = make(map[string]CacheEntry)\n\tc.invalidated = make(map[string]time.Time)\n}\n\nfunc PredicateCapacity(task Task, worker Worker) (bool, []string, error) {\n\treasons := []string{}\n\tavailableCapacity := worker.Capacity - worker.CurrentLoad\n\tif availableCapacity < task.RequiredCapacity {\n\t\treasons = append(reasons, fmt.Sprintf(\"Insufficient capacity: required %d, available %d\", task.RequiredCapacity, availableCapacity))\n\t\treturn false, reasons, nil\n\t}\n\treturn true, []string{fmt.Sprintf(\"Sufficient capacity available: %d\", availableCapacity)}, nil\n}\n\nfunc PredicateSkills(task Task, worker Worker) (bool, []string, error) {\n\treasons := []string{}\n\tskillMap := make(map[string]bool)\n\tfor _, skill := range worker.Skills {\n\t\tskillMap[skill] = true\n\t}\n\n\tmissingSkills := []string{}\n\tfor _, requiredSkill := range task.RequiredSkills {\n\t\tif !skillMap[requiredSkill] {\n\t\t\tmissingSkills = append(missingSkills, requiredSkill)\n\t\t}\n\t}\n\n\tif len(missingSkills) > 0 {\n\t\treasons = append(reasons, fmt.Sprintf(\"Missing skills: %v\", missingSkills))\n\t\treturn false, reasons, nil\n\t}\n\n\treasons = append(reasons, fmt.Sprintf(\"Has all required skills: %v\", task.RequiredSkills))\n\treturn true, reasons, nil\n}\n\nfunc PredicateLocation(task Task, worker Worker) (bool, []string, error) {\n\treasons := []string{}\n\tif worker.Location != task.RequiredLocation {\n\t\treasons = append(reasons, fmt.Sprintf(\"Wrong location: worker at %s, task requires %s\", worker.Location, task.RequiredLocation))\n\t\treturn false, reasons, nil\n\t}\n\treasons = append(reasons, fmt.Sprintf(\"Worker at correct location: %s\", worker.Location))\n\treturn true, reasons, nil\n}\n\nfunc ScheduleTask(task Task, worker Worker, predicates []Predicate, cache *Cache) (bool, []string, map[string]bool) {\n\tallReasons := []string{}\n\tcacheHits := make(map[string]bool)\n\n\tfor i, predicate := range predicates {\n\t\tpredicateName := fmt.Sprintf(\"predicate_%d\", i)\n\n\t\tcachedFit, cachedReasons, valid := cache.GetCachedResult(task.Name, worker.Name, predicateName)\n\t\tif valid {\n\t\t\tcacheHits[predicateName] = true\n\t\t\tif !cachedFit {\n\t\t\t\tallReasons = append(allReasons, cachedReasons...)\n\t\t\t\treturn false, allReasons, cacheHits\n\t\t\t}\n\t\t\tallReasons = append(allReasons, cachedReasons...)\n\t\t\tcontinue\n\t\t}\n\n\t\tfit, reasons, err := predicate(task, worker)\n\t\tif err != nil {\n\t\t\tallReasons = append(allReasons, fmt.Sprintf(\"Error in predicate %d: %v\", i, err))\n\t\t\treturn false, allReasons, cacheHits\n\t\t}\n\n\t\tcache.UpdateCache(task.Name, worker.Name, predicateName, fit, reasons)\n\t\tcacheHits[predicateName] = false\n\n\t\tif !fit {\n\t\t\tallReasons = append(allReasons, reasons...)\n\t\t\treturn false, allReasons, cacheHits\n\t\t}\n\n\t\tallReasons = append(allReasons, reasons...)\n\t}\n\n\treturn true, allReasons, cacheHits\n}\n\nfunc main() {\n\tcache := NewCache(5 * time.Second)\n\n\tworkers := []Worker{\n\t\t{Name: \"Worker-1\", Capacity: 100, Skills: []string{\"Python\", \"Docker\"}, Location: \"NYC\", CurrentLoad: 30},\n\t\t{Name: \"Worker-2\", Capacity: 80, Skills: []string{\"Java\", \"Kubernetes\"}, Location: \"SF\", CurrentLoad: 20},\n\t\t{Name: \"Worker-3\", Capacity: 120, Skills: []string{\"Python\", \"Java\", \"Docker\"}, Location: \"NYC\", CurrentLoad: 50},\n\t\t{Name: \"Worker-4\", Capacity: 60, Skills: []string{\"Go\", \"Rust\"}, Location: \"Austin\", CurrentLoad: 10},\n\t\t{Name: \"Worker-5\", Capacity: 150, Skills: []string{\"Python\", \"Java\", \"Go\", \"Docker\"}, Location: \"SF\", CurrentLoad: 80},\n\t}\n\n\ttasks := []Task{\n\t\t{Name: \"Task-1\", RequiredCapacity: 30, RequiredSkills: []string{\"Python\", \"Docker\"}, RequiredLocation: \"NYC\"},\n\t\t{Name: \"Task-2\", RequiredCapacity: 50, RequiredSkills: []string{\"Java\", \"Kubernetes\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"Task-3\", RequiredCapacity: 20, RequiredSkills: []string{\"Python\"}, RequiredLocation: \"NYC\"},\n\t\t{Name: \"Task-4\", RequiredCapacity: 40, RequiredSkills: []string{\"Go\", \"Rust\"}, RequiredLocation: \"Austin\"},\n\t\t{Name: \"Task-5\", RequiredCapacity: 35, RequiredSkills: []string{\"Java\"}, RequiredLocation: \"SF\"},\n\t\t{Name: \"Task-6\", RequiredCapacity: 25, RequiredSkills: []string{\"Docker\"}, RequiredLocation: \"NYC\"},\n\t\t{Name: \"Task-7\", RequiredCapacity: 15, RequiredSkills: []string{\"Go\"}, RequiredLocation: \"Austin\"},\n\t\t{Name: \"Task-8\", RequiredCapacity: 60, RequiredSkills: []string{\"Python\", \"Docker\", \"Java\"}, RequiredLocation: \"NYC\"},\n\t\t{Name: \"Task-9\", RequiredCapacity: 10, RequiredSkills: []string{\"Rust\"}, RequiredLocation: \"Austin\"},\n\t\t{Name: \"Task-10\", RequiredCapacity: 70, RequiredSkills: []string{\"Python\", \"Java\"}, RequiredLocation: \"SF\"},\n\t}\n\n\tpredicates := []Predicate{\n\t\tPredicateCapacity,\n\t\tPredicateSkills,\n\t\tPredicateLocation,\n\t}\n\n\tresultsChan := make(chan SchedulingResult, len(tasks)*len(workers))\n\tvar wg sync.WaitGroup\n\n\tgo func() {\n\t\tticker := time.NewTicker(2 * time.Second)\n\t\tdefer ticker.Stop()\n\t\tcount := 0\n\t\tfor range ticker.C {\n\t\t\tcount++\n\t\t\tif count > 2 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif count%2 == 0 && len(workers) > 0 {\n\t\t\t\tfmt.Printf(\"\\n[Event Handler] Invalidating cache for %s due to capacity change\\n\", workers[0].Name)\n\t\t\t\tcache.InvalidateWorkerCache(workers[0].Name)\n\t\t\t\tworkers[0].CurrentLoad += 20\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor _, task := range tasks {\n\t\tfor _, worker := range workers {\n\t\t\twg.Add(1)\n\t\t\tgo func(t Task, w Worker) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tfit, reasons, cacheHits := ScheduleTask(t, w, predicates, cache)\n\t\t\t\tcacheHitCount := 0\n\t\t\t\tfor _, hit := range cacheHits {\n\t\t\t\t\tif hit {\n\t\t\t\t\t\tcacheHitCount++\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult := SchedulingResult{\n\t\t\t\t\tTaskName:   t.Name,\n\t\t\t\t\tWorkerName: w.Name,\n\t\t\t\t\tCanAssign:  fit,\n\t\t\t\t\tReasons:    reasons,\n\t\t\t\t\tCacheHit:   cacheHitCount > 0,\n\t\t\t\t}\n\t\t\t\tresultsChan <- result\n\t\t\t}(task, worker)\n\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}\n\n\twg.Wait()\n\tclose(resultsChan)\n\n\tfmt.Println(\"\\n=== SCHEDULING RESULTS ===\\n\")\n\n\tassignmentMap := make(map[string]string)\n\tfor result := range resultsChan {\n\t\tcacheIndicator := \"\"\n\t\tif result.CacheHit {\n\t\t\tcacheIndicator = \" [CACHE HIT]\"\n\t\t}\n\t\tstatus := \"\u2717 REJECTED\"\n\t\tif result.CanAssign {\n\t\t\tstatus = \"\u2713 ASSIGNED\"\n\t\t\tassignmentMap[result.TaskName] = result.WorkerName\n\t\t}\n\n\t\tfmt.Printf(\"%s -> %s: %s%s\\n\", result.TaskName, result.WorkerName, status, cacheIndicator)\n\t\tif !result.CanAssign && len(result.Reasons) > 0 {\n\t\t\tfmt.Printf(\"  Reasons: %v\\n\", result.Reasons)\n\t\t}\n\t}\n\n\tfmt.Println(\"\\n=== FINAL ASSIGNMENTS ===\\n\")\n\tif len(assignmentMap) == 0 {\n\t\tfmt.Println(\"No tasks were assigned.\")\n\t} else {\n\t\tfor task, worker := range assignmentMap {\n\t\t\tfmt.Printf(\"%s -> %s\\n\", task, worker)\n\t\t}\n\t}\n\n\tfmt.Printf(\"\\nTotal tasks: %d\\n\", len(tasks))\n\tfmt.Printf(\"Assigned tasks: %d\\n\", len(assignmentMap))\n\tfmt.Printf(\"Unassigned tasks: %d\\n\", len(tasks)-len(assignmentMap))\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}