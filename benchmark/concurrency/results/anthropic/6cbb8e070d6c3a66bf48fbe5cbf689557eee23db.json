{
    "task": "6cbb8e070d6c3a66bf48fbe5cbf689557eee23db.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ConnectionTracker struct {\n\tmu          sync.RWMutex\n\tconnections map[string]*net.UDPConn\n\tlastActivity map[string]time.Time\n}\n\ntype UDPProxy struct {\n\tfrontendAddr *net.UDPAddr\n\tbackendAddr  *net.UDPAddr\n\tlistener     *net.UDPConn\n\ttracker      *ConnectionTracker\n\tidleTimeout  time.Duration\n\tdone         chan struct{}\n}\n\nfunc NewConnectionTracker() *ConnectionTracker {\n\treturn &ConnectionTracker{\n\t\tconnections:  make(map[string]*net.UDPConn),\n\t\tlastActivity: make(map[string]time.Time),\n\t}\n}\n\nfunc NewUDPProxy(frontendAddr, backendAddr string, idleTimeout time.Duration) (*UDPProxy, error) {\n\tfAddr, err := net.ResolveUDPAddr(\"udp\", frontendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve frontend address: %w\", err)\n\t}\n\n\tbAddr, err := net.ResolveUDPAddr(\"udp\", backendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve backend address: %w\", err)\n\t}\n\n\tlistener, err := net.ListenUDP(\"udp\", fAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to listen on frontend: %w\", err)\n\t}\n\n\treturn &UDPProxy{\n\t\tfrontendAddr: fAddr,\n\t\tbackendAddr:  bAddr,\n\t\tlistener:     listener,\n\t\ttracker:      NewConnectionTracker(),\n\t\tidleTimeout:  idleTimeout,\n\t\tdone:         make(chan struct{}),\n\t}, nil\n}\n\nfunc (p *UDPProxy) getOrCreateBackendConn(clientAddr string) (*net.UDPConn, error) {\n\tp.tracker.mu.RLock()\n\tconn, exists := p.tracker.connections[clientAddr]\n\tp.tracker.mu.RUnlock()\n\n\tif exists {\n\t\tp.tracker.mu.Lock()\n\t\tp.tracker.lastActivity[clientAddr] = time.Now()\n\t\tp.tracker.mu.Unlock()\n\t\treturn conn, nil\n\t}\n\n\tbackendConn, err := net.DialUDP(\"udp\", nil, p.backendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to dial backend: %w\", err)\n\t}\n\n\tp.tracker.mu.Lock()\n\tp.tracker.connections[clientAddr] = backendConn\n\tp.tracker.lastActivity[clientAddr] = time.Now()\n\tp.tracker.mu.Unlock()\n\n\tgo p.handleBackendResponse(clientAddr, backendConn)\n\n\treturn backendConn, nil\n}\n\nfunc (p *UDPProxy) handleBackendResponse(clientAddr string, backendConn *net.UDPConn) {\n\tbuffer := make([]byte, 4096)\n\tclientUDPAddr, err := net.ResolveUDPAddr(\"udp\", clientAddr)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to resolve client address %s: %v\", clientAddr, err)\n\t\treturn\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\tbackendConn.SetReadDeadline(time.Now().Add(5 * time.Second))\n\t\tn, _, err := backendConn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Printf(\"Error reading from backend for client %s: %v\", clientAddr, err)\n\t\t\tp.closeClientConnection(clientAddr)\n\t\t\treturn\n\t\t}\n\n\t\tp.tracker.mu.Lock()\n\t\tp.tracker.lastActivity[clientAddr] = time.Now()\n\t\tp.tracker.mu.Unlock()\n\n\t\t_, err = p.listener.WriteToUDP(buffer[:n], clientUDPAddr)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error writing to client %s: %v\", clientAddr, err)\n\t\t\tp.closeClientConnection(clientAddr)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *UDPProxy) closeClientConnection(clientAddr string) {\n\tp.tracker.mu.Lock()\n\tdefer p.tracker.mu.Unlock()\n\n\tif conn, exists := p.tracker.connections[clientAddr]; exists {\n\t\tconn.Close()\n\t\tdelete(p.tracker.connections, clientAddr)\n\t\tdelete(p.tracker.lastActivity, clientAddr)\n\t}\n}\n\nfunc (p *UDPProxy) cleanupIdleConnections() {\n\tticker := time.NewTicker(10 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tp.tracker.mu.Lock()\n\t\t\tnow := time.Now()\n\t\t\tfor clientAddr, lastActivity := range p.tracker.lastActivity {\n\t\t\t\tif now.Sub(lastActivity) > p.idleTimeout {\n\t\t\t\t\tif conn, exists := p.tracker.connections[clientAddr]; exists {\n\t\t\t\t\t\tconn.Close()\n\t\t\t\t\t\tdelete(p.tracker.connections, clientAddr)\n\t\t\t\t\t}\n\t\t\t\t\tdelete(p.tracker.lastActivity, clientAddr)\n\t\t\t\t\tlog.Printf(\"Closed idle connection for client %s\", clientAddr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.tracker.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (p *UDPProxy) Start() error {\n\tlog.Printf(\"UDP Proxy starting: %s -> %s\", p.frontendAddr, p.backendAddr)\n\tgo p.cleanupIdleConnections()\n\n\tbuffer := make([]byte, 4096)\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\n\t\tn, clientAddr, err := p.listener.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading from frontend: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo p.handleClientPacket(clientAddr, buffer[:n])\n\t}\n}\n\nfunc (p *UDPProxy) handleClientPacket(clientAddr *net.UDPAddr, data []byte) {\n\tbackendConn, err := p.getOrCreateBackendConn(clientAddr.String())\n\tif err != nil {\n\t\tlog.Printf(\"Failed to get/create backend connection for %s: %v\", clientAddr, err)\n\t\treturn\n\t}\n\n\t_, err = backendConn.Write(data)\n\tif err != nil {\n\t\tlog.Printf(\"Error writing to backend for client %s: %v\", clientAddr, err)\n\t\tp.closeClientConnection(clientAddr.String())\n\t}\n}\n\nfunc (p *UDPProxy) Stop() {\n\tclose(p.done)\n\tp.listener.Close()\n\n\tp.tracker.mu.Lock()\n\tfor _, conn := range p.tracker.connections {\n\t\tconn.Close()\n\t}\n\tp.tracker.connections = make(map[string]*net.UDPConn)\n\tp.tracker.lastActivity = make(map[string]time.Time)\n\tp.tracker.mu.Unlock()\n\n\tlog.Println(\"UDP Proxy stopped\")\n}\n\nfunc startEchoServer(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resolve echo server address: %w\", err)\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to listen on echo server: %w\", err)\n\t}\n\n\tgo func() {\n\t\tdefer conn.Close()\n\t\tbuffer := make([]byte, 4096)\n\t\tlog.Printf(\"Echo server listening on %s\", addr)\n\t\tfor {\n\t\t\tn, remoteAddr, err := conn.ReadFromUDP(buffer)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Echo server read error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, err = conn.WriteToUDP(buffer[:n], remoteAddr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Echo server write error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc main() {\n\terr := startEchoServer(\"127.0.0.1:9999\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start echo server: %v\", err)\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tproxy, err := NewUDPProxy(\"127.0.0.1:8888\", \"127.0.0.1:9999\", 30*time.Second)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create UDP proxy: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := proxy.Start(); err != nil {\n\t\t\tlog.Fatalf(\"Proxy error: %v\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tgo func() {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tclientAddr, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:0\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to resolve client address: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconn, err := net.DialUDP(\"udp\", clientAddr, net.UDPAddrFromAddrPort(net.ParseAddrPort(\"127.0.0.1:8888\")))\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to dial proxy: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer conn.Close()\n\n\t\t\tmessage := []byte(fmt.Sprintf(\"Hello from client %d\", i))\n\t\t\t_, err = conn.Write(message)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d write error: %v\", i, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconn.SetReadDeadline(time.Now().Add(2 * time.Second))\n\t\t\tresponse := make([]byte, 4096)\n\t\t\tn, err := conn.Read(response)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d read error: %v\", i, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Printf(\"Client %d received: %s\", i, string(response[:n]))\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(5 * time.Second)\n\tproxy.Stop()\n\tlog.Println(\"Program finished\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:274:76: undefined: net.ParseAddrPort"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:274:76: undefined: net.ParseAddrPort\n\n\nGolang errors in file: [/tmp/go_synthesis_oolhgxvx/main.go]:\n\n  > [line 274 : column 76] - undefined: net.ParseAddrPort\n\n\n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:288\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    287: \n  > 288: \t\t\tconn.SetReadDeadline(time.Now().Add(2 * time.Second))\n    289: \t\t\tresponse := make([]byte, 4096)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:204\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    203: \tfor _, conn := range p.tracker.connections {\n  > 204: \t\tconn.Close()\n    205: \t}\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:200\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    199: \tclose(p.done)\n  > 200: \tp.listener.Close()\n    201: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:150\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    149: \t\t\t\t\tif conn, exists := p.tracker.connections[clientAddr]; exists {\n  > 150: \t\t\t\t\t\tconn.Close()\n    151: \t\t\t\t\t\tdelete(p.tracker.connections, clientAddr)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:130\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    129: \tif conn, exists := p.tracker.connections[clientAddr]; exists {\n  > 130: \t\tconn.Close()\n    131: \t\tdelete(p.tracker.connections, clientAddr)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:101\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    100: \n  > 101: \t\tbackendConn.SetReadDeadline(time.Now().Add(5 * time.Second))\n    102: \t\tn, _, err := backendConn.ReadFromUDP(buffer)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 304\n  Nosec  : 0\n  Issues : \u001b[1;31m6\u001b[0m\n\n[gosec] 2025/12/01 13:51:02 Including rules: default\n[gosec] 2025/12/01 13:51:02 Excluding rules: default\n[gosec] 2025/12/01 13:51:02 Including analyzers: default\n[gosec] 2025/12/01 13:51:02 Excluding analyzers: default\n[gosec] 2025/12/01 13:51:02 Import directory: /tmp/go_synthesis_oolhgxvx\n[gosec] 2025/12/01 13:51:02 Checking package: main\n[gosec] 2025/12/01 13:51:02 Checking file: /tmp/go_synthesis_oolhgxvx/main.go\n[gosec] 2025/12/01 13:51:03 Panic when running SSA analyzer on package: main. Panic: runtime error: invalid memory address or nil pointer dereference\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xecea40?, 0x1998730?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*Program).packageLevelMember(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/source.go:187\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000433620, 0xc000bc0200, {0x11e2648?, 0xc000b78be0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:820 +0x1b2b\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000433620, 0xc000bc0200, {0x11e2648, 0xc000b78be0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000433620, 0xc000bc0200, {0x11e26d8?, 0xc00012bd88}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:842 +0x1031\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000433620, 0xc000bc0200, {0x11e26d8, 0xc00012bd88})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).setCallFunc(0xc000433620?, 0xc000bc0200?, 0xc000c93cc0?, 0xc00005c6c0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1066 +0x2b6\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc000433620, 0xc000bc0200, 0xc000c93cc0, 0xc00005c6c0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1144 +0x2b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000433620, 0xc000bc0200, {0x11e2708?, 0xc000c93cc0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:724 +0x2105\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000433620, 0xc000bc0200, {0x11e2708, 0xc000c93cc0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).emitCallArgs(0xc000433620, 0xc000bc0200, 0xc0010dd000, 0xc000c93d00, {0x0?, 0x0, 0x78?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1090 +0x105\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc000433620, 0xc000bc0200, 0xc000c93d00, 0xc00005c640)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1151 +0x85\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000433620, 0xc000bc0200, {0x11e2708?, 0xc000c93d00}, {0x7, {0x11de848, 0xc001097430}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:724 +0x2105\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000433620, 0xc000bc0200, {0x11e2708, 0xc000c93d00})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).emitCallArgs(0xc000433620, 0xc000bc0200, 0xc001090740, 0xc000c93d80, {0x0?, 0x0, 0x78?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1090 +0x105\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc000433620, 0xc000bc0200, 0xc000c93d80, 0xc00005c5c0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1151 +0x85\ngolang.org/x/tools/go/ssa.(*builder).exprN(0xc000433620, 0xc000bc0200, {0x11e2708, 0xc000c93d80})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:292 +0x27e\ngolang.org/x/tools/go/ssa.(*builder).assignStmt(0xc000433620, 0xc000bc0200, {0xc000b78ac0, 0x2, 0xc000bb1ad0?}, {0xc00012c940, 0x1, 0xf97c00?}, 0x1)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1234 +0x369\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000433620, 0xc000bc0200, {0x11e2d90?, 0xc000c93dc0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2720 +0x5b5\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000433620, 0xc000bc0200, {0x11e2eb0?, 0xc000ee5200?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).forStmtGo122(0xc000433620, 0xc000bc0200, 0xc0011467c0, 0x0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1973 +0xeda\ngolang.org/x/tools/go/ssa.(*builder).forStmt(0xc000433620, 0xc000bc0200, 0xc0011467c0, 0x0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1814 +0xba\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000433620, 0xc000bc0200, {0x11e3000?, 0xc0011467c0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2788 +0x4b4\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000433620, 0xc000bc0200, {0x11e2eb0?, 0xc000ee5230?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000433620, 0xc000bc0200)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000433620, 0xc000b1f600, {0x11e3060?, 0xc00012cc10}, {0x7, {0x11df558, 0xc000d3a440}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:677 +0x1497\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000433620, 0xc000b1f600, {0x11e3060, 0xc00012cc10})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).setCallFunc(0x48?, 0xf73600?, 0x0?, 0xc000c99ae8)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1066 +0x2b6\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc000433620, 0xc000b1f600, 0xc001146800, 0xc000c99ae8)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1144 +0x2b\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000433620, 0xc000b1f600, {0x11e2dc0?, 0xc00012cc20?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2731 +0x725\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000433620, 0xc000b1f600, {0x11e2eb0?, 0xc000ee5290?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000433620, 0xc000b1f600)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000b1f600)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000433620)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc000d22c80)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc000392090?, 0xc0010034a0?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc000438000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc000b83d40)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc000aee980, 0xc000b83d40)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc000aee980, {0x0, 0x0, 0x0}, {0xc000052cc0, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 13:51:03 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_oolhgxvx/main.go:274:76: undefined: net.ParseAddrPort\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:274:76: undefined: net.ParseAddrPort /tmp/go_synthesis_oolhgxvx/main.go:274:76: undefined: net.ParseAddrPort]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:274:76: undefined: net.ParseAddrPort\n/tmp/go_synthesis_oolhgxvx/main.go:274:76: undefined: net.ParseAddrPort\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:274:76: undefined: net.ParseAddrPort (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ConnectionTracker struct {\n\tmu          sync.RWMutex\n\tconnections map[string]*net.UDPConn\n\tlastActivity map[string]time.Time\n}\n\ntype UDPProxy struct {\n\tfrontendAddr *net.UDPAddr\n\tbackendAddr  *net.UDPAddr\n\tlistener     *net.UDPConn\n\ttracker      *ConnectionTracker\n\tidleTimeout  time.Duration\n\tdone         chan struct{}\n}\n\nfunc NewConnectionTracker() *ConnectionTracker {\n\treturn &ConnectionTracker{\n\t\tconnections:  make(map[string]*net.UDPConn),\n\t\tlastActivity: make(map[string]time.Time),\n\t}\n}\n\nfunc NewUDPProxy(frontendAddr, backendAddr string, idleTimeout time.Duration) (*UDPProxy, error) {\n\tfAddr, err := net.ResolveUDPAddr(\"udp\", frontendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve frontend address: %w\", err)\n\t}\n\n\tbAddr, err := net.ResolveUDPAddr(\"udp\", backendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve backend address: %w\", err)\n\t}\n\n\tlistener, err := net.ListenUDP(\"udp\", fAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to listen on frontend: %w\", err)\n\t}\n\n\treturn &UDPProxy{\n\t\tfrontendAddr: fAddr,\n\t\tbackendAddr:  bAddr,\n\t\tlistener:     listener,\n\t\ttracker:      NewConnectionTracker(),\n\t\tidleTimeout:  idleTimeout,\n\t\tdone:         make(chan struct{}),\n\t}, nil\n}\n\nfunc (p *UDPProxy) getOrCreateBackendConn(clientAddr string) (*net.UDPConn, error) {\n\tp.tracker.mu.RLock()\n\tconn, exists := p.tracker.connections[clientAddr]\n\tp.tracker.mu.RUnlock()\n\n\tif exists {\n\t\tp.tracker.mu.Lock()\n\t\tp.tracker.lastActivity[clientAddr] = time.Now()\n\t\tp.tracker.mu.Unlock()\n\t\treturn conn, nil\n\t}\n\n\tbackendConn, err := net.DialUDP(\"udp\", nil, p.backendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to dial backend: %w\", err)\n\t}\n\n\tp.tracker.mu.Lock()\n\tp.tracker.connections[clientAddr] = backendConn\n\tp.tracker.lastActivity[clientAddr] = time.Now()\n\tp.tracker.mu.Unlock()\n\n\tgo p.handleBackendResponse(clientAddr, backendConn)\n\n\treturn backendConn, nil\n}\n\nfunc (p *UDPProxy) handleBackendResponse(clientAddr string, backendConn *net.UDPConn) {\n\tbuffer := make([]byte, 4096)\n\tclientUDPAddr, err := net.ResolveUDPAddr(\"udp\", clientAddr)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to resolve client address %s: %v\", clientAddr, err)\n\t\treturn\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\tbackendConn.SetReadDeadline(time.Now().Add(5 * time.Second))\n\t\tn, _, err := backendConn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Printf(\"Error reading from backend for client %s: %v\", clientAddr, err)\n\t\t\tp.closeClientConnection(clientAddr)\n\t\t\treturn\n\t\t}\n\n\t\tp.tracker.mu.Lock()\n\t\tp.tracker.lastActivity[clientAddr] = time.Now()\n\t\tp.tracker.mu.Unlock()\n\n\t\t_, err = p.listener.WriteToUDP(buffer[:n], clientUDPAddr)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error writing to client %s: %v\", clientAddr, err)\n\t\t\tp.closeClientConnection(clientAddr)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *UDPProxy) closeClientConnection(clientAddr string) {\n\tp.tracker.mu.Lock()\n\tdefer p.tracker.mu.Unlock()\n\n\tif conn, exists := p.tracker.connections[clientAddr]; exists {\n\t\tconn.Close()\n\t\tdelete(p.tracker.connections, clientAddr)\n\t\tdelete(p.tracker.lastActivity, clientAddr)\n\t}\n}\n\nfunc (p *UDPProxy) cleanupIdleConnections() {\n\tticker := time.NewTicker(10 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tp.tracker.mu.Lock()\n\t\t\tnow := time.Now()\n\t\t\tfor clientAddr, lastActivity := range p.tracker.lastActivity {\n\t\t\t\tif now.Sub(lastActivity) > p.idleTimeout {\n\t\t\t\t\tif conn, exists := p.tracker.connections[clientAddr]; exists {\n\t\t\t\t\t\tconn.Close()\n\t\t\t\t\t\tdelete(p.tracker.connections, clientAddr)\n\t\t\t\t\t}\n\t\t\t\t\tdelete(p.tracker.lastActivity, clientAddr)\n\t\t\t\t\tlog.Printf(\"Closed idle connection for client %s\", clientAddr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.tracker.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (p *UDPProxy) Start() error {\n\tlog.Printf(\"UDP Proxy starting: %s -> %s\", p.frontendAddr, p.backendAddr)\n\tgo p.cleanupIdleConnections()\n\n\tbuffer := make([]byte, 4096)\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\n\t\tn, clientAddr, err := p.listener.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading from frontend: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo p.handleClientPacket(clientAddr, buffer[:n])\n\t}\n}\n\nfunc (p *UDPProxy) handleClientPacket(clientAddr *net.UDPAddr, data []byte) {\n\tbackendConn, err := p.getOrCreateBackendConn(clientAddr.String())\n\tif err != nil {\n\t\tlog.Printf(\"Failed to get/create backend connection for %s: %v\", clientAddr, err)\n\t\treturn\n\t}\n\n\t_, err = backendConn.Write(data)\n\tif err != nil {\n\t\tlog.Printf(\"Error writing to backend for client %s: %v\", clientAddr, err)\n\t\tp.closeClientConnection(clientAddr.String())\n\t}\n}\n\nfunc (p *UDPProxy) Stop() {\n\tclose(p.done)\n\tp.listener.Close()\n\n\tp.tracker.mu.Lock()\n\tfor _, conn := range p.tracker.connections {\n\t\tconn.Close()\n\t}\n\tp.tracker.connections = make(map[string]*net.UDPConn)\n\tp.tracker.lastActivity = make(map[string]time.Time)\n\tp.tracker.mu.Unlock()\n\n\tlog.Println(\"UDP Proxy stopped\")\n}\n\nfunc startEchoServer(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resolve echo server address: %w\", err)\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to listen on echo server: %w\", err)\n\t}\n\n\tgo func() {\n\t\tdefer conn.Close()\n\t\tbuffer := make([]byte, 4096)\n\t\tlog.Printf(\"Echo server listening on %s\", addr)\n\t\tfor {\n\t\t\tn, remoteAddr, err := conn.ReadFromUDP(buffer)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Echo server read error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, err = conn.WriteToUDP(buffer[:n], remoteAddr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Echo server write error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc main() {\n\terr := startEchoServer(\"127.0.0.1:9999\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start echo server: %v\", err)\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tproxy, err := NewUDPProxy(\"127.0.0.1:8888\", \"127.0.0.1:9999\", 30*time.Second)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create UDP proxy: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := proxy.Start(); err != nil {\n\t\t\tlog.Fatalf(\"Proxy error: %v\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tgo func() {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tclientAddr, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:0\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to resolve client address: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tproxyAddr, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:8888\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to resolve proxy address: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconn, err := net.DialUDP(\"udp\", clientAddr, proxyAddr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to dial proxy: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmessage := []byte(fmt.Sprintf(\"Hello from client %d\", i))\n\t\t\t_, err = conn.Write(message)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d write error: %v\", i, err)\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr = conn.SetReadDeadline(time.Now().Add(2 * time.Second))\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d set deadline error: %v\", i, err)\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresponse := make([]byte, 4096)\n\t\t\tn, err := conn.Read(response)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d read error: %v\", i, err)\n\t\t\t\tconn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Printf(\"Client %d received: %s\", i, string(response[:n]))\n\t\t\tconn.Close()\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(5 * time.Second)\n\tproxy.Stop()\n\tlog.Println(\"Program finished\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:310\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    309: \t\t\tlog.Printf(\"Client %d received: %s\", i, string(response[:n]))\n  > 310: \t\t\tconn.Close()\n    311: \t\t\ttime.Sleep(100 * time.Millisecond)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:305\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    304: \t\t\t\tlog.Printf(\"Client %d read error: %v\", i, err)\n  > 305: \t\t\t\tconn.Close()\n    306: \t\t\t\tcontinue\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:297\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    296: \t\t\t\tlog.Printf(\"Client %d set deadline error: %v\", i, err)\n  > 297: \t\t\t\tconn.Close()\n    298: \t\t\t\tcontinue\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:290\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    289: \t\t\t\tlog.Printf(\"Client %d write error: %v\", i, err)\n  > 290: \t\t\t\tconn.Close()\n    291: \t\t\t\tcontinue\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:204\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    203: \tfor _, conn := range p.tracker.connections {\n  > 204: \t\tconn.Close()\n    205: \t}\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:200\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    199: \tclose(p.done)\n  > 200: \tp.listener.Close()\n    201: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:150\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    149: \t\t\t\t\tif conn, exists := p.tracker.connections[clientAddr]; exists {\n  > 150: \t\t\t\t\t\tconn.Close()\n    151: \t\t\t\t\t\tdelete(p.tracker.connections, clientAddr)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:130\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    129: \tif conn, exists := p.tracker.connections[clientAddr]; exists {\n  > 130: \t\tconn.Close()\n    131: \t\tdelete(p.tracker.connections, clientAddr)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_oolhgxvx/main.go:101\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    100: \n  > 101: \t\tbackendConn.SetReadDeadline(time.Now().Add(5 * time.Second))\n    102: \t\tn, _, err := backendConn.ReadFromUDP(buffer)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 318\n  Nosec  : 0\n  Issues : \u001b[1;31m9\u001b[0m\n\n[gosec] 2025/12/01 13:51:17 Including rules: default\n[gosec] 2025/12/01 13:51:17 Excluding rules: default\n[gosec] 2025/12/01 13:51:17 Including analyzers: default\n[gosec] 2025/12/01 13:51:17 Excluding analyzers: default\n[gosec] 2025/12/01 13:51:17 Import directory: /tmp/go_synthesis_oolhgxvx\n[gosec] 2025/12/01 13:51:17 Checking package: main\n[gosec] 2025/12/01 13:51:17 Checking file: /tmp/go_synthesis_oolhgxvx/main.go"
                },
                {
                    "verifier": "errcheck",
                    "error": "main.go:101:30:\tbackendConn.SetReadDeadline(time.Now().Add(5 * time.Second))\nmain.go:130:13:\tconn.Close()\nmain.go:150:17:\tconn.Close()\nmain.go:200:18:\tp.listener.Close()\nmain.go:204:13:\tconn.Close()\nmain.go:225:19:\tdefer conn.Close()\nmain.go:290:15:\tconn.Close()\nmain.go:297:15:\tconn.Close()\nmain.go:305:15:\tconn.Close()\nmain.go:310:14:\tconn.Close()"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "/tmp/go_synthesis_oolhgxvx/main.go:104:21: type assertion on error will fail on wrapped errors. Use errors.As to check for specific errors"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ConnectionTracker struct {\n\tmu          sync.RWMutex\n\tconnections map[string]*net.UDPConn\n\tlastActivity map[string]time.Time\n}\n\ntype UDPProxy struct {\n\tfrontendAddr *net.UDPAddr\n\tbackendAddr  *net.UDPAddr\n\tlistener     *net.UDPConn\n\ttracker      *ConnectionTracker\n\tidleTimeout  time.Duration\n\tdone         chan struct{}\n}\n\nfunc NewConnectionTracker() *ConnectionTracker {\n\treturn &ConnectionTracker{\n\t\tconnections:  make(map[string]*net.UDPConn),\n\t\tlastActivity: make(map[string]time.Time),\n\t}\n}\n\nfunc NewUDPProxy(frontendAddr, backendAddr string, idleTimeout time.Duration) (*UDPProxy, error) {\n\tfAddr, err := net.ResolveUDPAddr(\"udp\", frontendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve frontend address: %w\", err)\n\t}\n\n\tbAddr, err := net.ResolveUDPAddr(\"udp\", backendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to resolve backend address: %w\", err)\n\t}\n\n\tlistener, err := net.ListenUDP(\"udp\", fAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to listen on frontend: %w\", err)\n\t}\n\n\treturn &UDPProxy{\n\t\tfrontendAddr: fAddr,\n\t\tbackendAddr:  bAddr,\n\t\tlistener:     listener,\n\t\ttracker:      NewConnectionTracker(),\n\t\tidleTimeout:  idleTimeout,\n\t\tdone:         make(chan struct{}),\n\t}, nil\n}\n\nfunc (p *UDPProxy) getOrCreateBackendConn(clientAddr string) (*net.UDPConn, error) {\n\tp.tracker.mu.RLock()\n\tconn, exists := p.tracker.connections[clientAddr]\n\tp.tracker.mu.RUnlock()\n\n\tif exists {\n\t\tp.tracker.mu.Lock()\n\t\tp.tracker.lastActivity[clientAddr] = time.Now()\n\t\tp.tracker.mu.Unlock()\n\t\treturn conn, nil\n\t}\n\n\tbackendConn, err := net.DialUDP(\"udp\", nil, p.backendAddr)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to dial backend: %w\", err)\n\t}\n\n\tp.tracker.mu.Lock()\n\tp.tracker.connections[clientAddr] = backendConn\n\tp.tracker.lastActivity[clientAddr] = time.Now()\n\tp.tracker.mu.Unlock()\n\n\tgo p.handleBackendResponse(clientAddr, backendConn)\n\n\treturn backendConn, nil\n}\n\nfunc (p *UDPProxy) handleBackendResponse(clientAddr string, backendConn *net.UDPConn) {\n\tbuffer := make([]byte, 4096)\n\tclientUDPAddr, err := net.ResolveUDPAddr(\"udp\", clientAddr)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to resolve client address %s: %v\", clientAddr, err)\n\t\treturn\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\n\t\terr := backendConn.SetReadDeadline(time.Now().Add(5 * time.Second))\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error setting read deadline for backend connection: %v\", err)\n\t\t\tp.closeClientConnection(clientAddr)\n\t\t\treturn\n\t\t}\n\n\t\tn, _, err := backendConn.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tvar netErr net.Error\n\t\t\tif errors.As(err, &netErr) && netErr.Timeout() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Printf(\"Error reading from backend for client %s: %v\", clientAddr, err)\n\t\t\tp.closeClientConnection(clientAddr)\n\t\t\treturn\n\t\t}\n\n\t\tp.tracker.mu.Lock()\n\t\tp.tracker.lastActivity[clientAddr] = time.Now()\n\t\tp.tracker.mu.Unlock()\n\n\t\t_, err = p.listener.WriteToUDP(buffer[:n], clientUDPAddr)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error writing to client %s: %v\", clientAddr, err)\n\t\t\tp.closeClientConnection(clientAddr)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *UDPProxy) closeClientConnection(clientAddr string) {\n\tp.tracker.mu.Lock()\n\tdefer p.tracker.mu.Unlock()\n\n\tif conn, exists := p.tracker.connections[clientAddr]; exists {\n\t\t_ = conn.Close()\n\t\tdelete(p.tracker.connections, clientAddr)\n\t\tdelete(p.tracker.lastActivity, clientAddr)\n\t}\n}\n\nfunc (p *UDPProxy) cleanupIdleConnections() {\n\tticker := time.NewTicker(10 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tp.tracker.mu.Lock()\n\t\t\tnow := time.Now()\n\t\t\tfor clientAddr, lastActivity := range p.tracker.lastActivity {\n\t\t\t\tif now.Sub(lastActivity) > p.idleTimeout {\n\t\t\t\t\tif conn, exists := p.tracker.connections[clientAddr]; exists {\n\t\t\t\t\t\t_ = conn.Close()\n\t\t\t\t\t\tdelete(p.tracker.connections, clientAddr)\n\t\t\t\t\t}\n\t\t\t\t\tdelete(p.tracker.lastActivity, clientAddr)\n\t\t\t\t\tlog.Printf(\"Closed idle connection for client %s\", clientAddr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.tracker.mu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (p *UDPProxy) Start() error {\n\tlog.Printf(\"UDP Proxy starting: %s -> %s\", p.frontendAddr, p.backendAddr)\n\tgo p.cleanupIdleConnections()\n\n\tbuffer := make([]byte, 4096)\n\tfor {\n\t\tselect {\n\t\tcase <-p.done:\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\n\t\tn, clientAddr, err := p.listener.ReadFromUDP(buffer)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error reading from frontend: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo p.handleClientPacket(clientAddr, buffer[:n])\n\t}\n}\n\nfunc (p *UDPProxy) handleClientPacket(clientAddr *net.UDPAddr, data []byte) {\n\tbackendConn, err := p.getOrCreateBackendConn(clientAddr.String())\n\tif err != nil {\n\t\tlog.Printf(\"Failed to get/create backend connection for %s: %v\", clientAddr, err)\n\t\treturn\n\t}\n\n\t_, err = backendConn.Write(data)\n\tif err != nil {\n\t\tlog.Printf(\"Error writing to backend for client %s: %v\", clientAddr, err)\n\t\tp.closeClientConnection(clientAddr.String())\n\t}\n}\n\nfunc (p *UDPProxy) Stop() {\n\tclose(p.done)\n\t_ = p.listener.Close()\n\n\tp.tracker.mu.Lock()\n\tfor _, conn := range p.tracker.connections {\n\t\t_ = conn.Close()\n\t}\n\tp.tracker.connections = make(map[string]*net.UDPConn)\n\tp.tracker.lastActivity = make(map[string]time.Time)\n\tp.tracker.mu.Unlock()\n\n\tlog.Println(\"UDP Proxy stopped\")\n}\n\nfunc startEchoServer(addr string) error {\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resolve echo server address: %w\", err)\n\t}\n\n\tconn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to listen on echo server: %w\", err)\n\t}\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\t_ = conn.Close()\n\t\t}()\n\t\tbuffer := make([]byte, 4096)\n\t\tlog.Printf(\"Echo server listening on %s\", addr)\n\t\tfor {\n\t\t\tn, remoteAddr, err := conn.ReadFromUDP(buffer)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Echo server read error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, err = conn.WriteToUDP(buffer[:n], remoteAddr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Echo server write error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\nfunc main() {\n\terr := startEchoServer(\"127.0.0.1:9999\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to start echo server: %v\", err)\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tproxy, err := NewUDPProxy(\"127.0.0.1:8888\", \"127.0.0.1:9999\", 30*time.Second)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create UDP proxy: %v\", err)\n\t}\n\n\tgo func() {\n\t\tif err := proxy.Start(); err != nil {\n\t\t\tlog.Fatalf(\"Proxy error: %v\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tgo func() {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tclientAddr, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:0\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to resolve client address: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tproxyAddr, err := net.ResolveUDPAddr(\"udp\", \"127.0.0.1:8888\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to resolve proxy address: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconn, err := net.DialUDP(\"udp\", clientAddr, proxyAddr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Failed to dial proxy: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmessage := []byte(fmt.Sprintf(\"Hello from client %d\", i))\n\t\t\t_, err = conn.Write(message)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d write error: %v\", i, err)\n\t\t\t\t_ = conn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr = conn.SetReadDeadline(time.Now().Add(2 * time.Second))\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d set deadline error: %v\", i, err)\n\t\t\t\t_ = conn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresponse := make([]byte, 4096)\n\t\t\tn, err := conn.Read(response)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Client %d read error: %v\", i, err)\n\t\t\t\t_ = conn.Close()\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlog.Printf(\"Client %d received: %s\", i, string(response[:n]))\n\t\t\t_ = conn.Close()\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}()\n\n\ttime.Sleep(5 * time.Second)\n\tproxy.Stop()\n\tlog.Println(\"Program finished\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}