{
    "task": "task2.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// LeaseState represents the metadata state of a table lease\ntype LeaseState struct {\n\tTableID    int64\n\tTableName  string\n\tVersion    int64\n\tRefCount   int64\n\tDeleted    bool\n\tmu         sync.RWMutex\n}\n\n// IncrementRefCount safely increments the reference count\nfunc (ls *LeaseState) IncrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"cannot increment refcount on deleted lease\")\n\t}\n\tls.RefCount++\n\treturn nil\n}\n\n// DecrementRefCount safely decrements the reference count\nfunc (ls *LeaseState) DecrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.RefCount <= 0 {\n\t\treturn fmt.Errorf(\"cannot decrement refcount below zero\")\n\t}\n\tls.RefCount--\n\treturn nil\n}\n\n// GetRefCount safely returns the current reference count\nfunc (ls *LeaseState) GetRefCount() int64 {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.RefCount\n}\n\n// IsDeleted safely checks if the lease is marked for deletion\nfunc (ls *LeaseState) IsDeleted() bool {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.Deleted\n}\n\n// MarkDeleted safely marks the lease as deleted\nfunc (ls *LeaseState) MarkDeleted() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"lease already marked as deleted\")\n\t}\n\tls.Deleted = true\n\treturn nil\n}\n\n// LeaseStore defines the backend interface for lease storage\ntype LeaseStore interface {\n\tGetLatestLease(dbID int64, tableName string) (*LeaseState, error)\n\tCleanup(dbID int64, tableID int64, version int64) error\n}\n\n// tableState manages all versions of leases for a specific table\ntype tableState struct {\n\tmu              sync.RWMutex\n\ttableID         int64\n\ttableName       string\n\tversions        map[int64]*LeaseState\n\tlatestVersion   int64\n\tdeleted         bool\n\tcachedLease     *LeaseState\n\tcachedLeaseVersion int64\n}\n\n// GetLatestVersion returns the latest version number for the table\nfunc (ts *tableState) GetLatestVersion() int64 {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.latestVersion\n}\n\n// IsDeleted checks if the table is marked as deleted\nfunc (ts *tableState) IsDeleted() bool {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.deleted\n}\n\n// MarkDeleted marks the table as deleted\nfunc (ts *tableState) MarkDeleted() {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\tts.deleted = true\n}\n\n// AddVersion adds a new lease version for this table\nfunc (ts *tableState) AddVersion(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.versions[lease.Version] = lease\n\tif lease.Version > ts.latestVersion {\n\t\tts.latestVersion = lease.Version\n\t\tts.cachedLease = lease\n\t\tts.cachedLeaseVersion = lease.Version\n\t}\n}\n\n// GetCachedLease returns the cached latest lease if available\nfunc (ts *tableState) GetCachedLease() *LeaseState {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\n\tif ts.cachedLease != nil && ts.cachedLeaseVersion == ts.latestVersion {\n\t\treturn ts.cachedLease\n\t}\n\treturn nil\n}\n\n// SetCachedLease updates the cached lease\nfunc (ts *tableState) SetCachedLease(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.cachedLease = lease\n\tts.cachedLeaseVersion = lease.Version\n}\n\n// RemoveVersion removes a specific lease version\nfunc (ts *tableState) RemoveVersion(version int64) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tdelete(ts.versions, version)\n\tif ts.cachedLeaseVersion == version {\n\t\tts.cachedLease = nil\n\t\tts.cachedLeaseVersion = -1\n\t}\n}\n\n// tableNameCache provides fast lookups by (dbID, tableName)\ntype tableNameCache struct {\n\tmu    sync.RWMutex\n\tcache map[string]int64 // key: dbID:tableName, value: tableID\n}\n\n// Get retrieves a tableID by (dbID, tableName)\nfunc (tnc *tableNameCache) Get(dbID int64, tableName string) (int64, bool) {\n\ttnc.mu.RLock()\n\tdefer tnc.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttableID, exists := tnc.cache[key]\n\treturn tableID, exists\n}\n\n// Set stores a mapping from (dbID, tableName) to tableID\nfunc (tnc *tableNameCache) Set(dbID int64, tableName string, tableID int64) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttnc.cache[key] = tableID\n}\n\n// Delete removes a mapping from the cache\nfunc (tnc *tableNameCache) Delete(dbID int64, tableName string) {\n\ttnc.mu.Lock()\n\tdefer tnc.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tdelete(tnc.cache, key)\n}\n\n// LeaseManager manages all leases for a database\ntype LeaseManager struct {\n\tmu              sync.RWMutex\n\tdbID            int64\n\tstore           LeaseStore\n\ttableStates     map[int64]*tableState\n\tnameCache       *tableNameCache\n\tleasedLeases    map[*LeaseState]bool\n}\n\n// NewLeaseManager creates a new lease manager\nfunc NewLeaseManager(dbID int64, store LeaseStore) *LeaseManager {\n\treturn &LeaseManager{\n\t\tdbID:           dbID,\n\t\tstore:          store,\n\t\ttableStates:    make(map[int64]*tableState),\n\t\tnameCache:      &tableNameCache{cache: make(map[string]int64)},\n\t\tleasedLeases:   make(map[*LeaseState]bool),\n\t}\n}\n\n// AcquireByName returns a lease for a given (dbID, tableName) pair\nfunc (lm *LeaseManager) AcquireByName(tableName string) (*LeaseState, error) {\n\tlm.mu.Lock()\n\n\t// Try to find cached lease by name\n\ttableID, exists := lm.nameCache.Get(lm.dbID, tableName)\n\tif exists {\n\t\tts, ok := lm.tableStates[tableID]\n\t\tif ok && !ts.IsDeleted() {\n\t\t\tcachedLease := ts.GetCachedLease()\n\t\t\tif cachedLease != nil && !cachedLease.IsDeleted() {\n\t\t\t\terr := cachedLease.IncrementRefCount()\n\t\t\t\tif err == nil {\n\t\t\t\t\tlm.leasedLeases[cachedLease] = true\n\t\t\t\t\tlm.mu.Unlock()\n\t\t\t\t\treturn cachedLease, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlm.mu.Unlock()\n\n\t// Fetch latest lease from store\n\tlease, err := lm.store.GetLatestLease(lm.dbID, tableName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch latest lease: %w\", err)\n\t}\n\n\tif lease == nil {\n\t\treturn nil, fmt.Errorf(\"lease not found for table: %s\", tableName)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\t// Check if table was deleted after fetch\n\tif lease.IsDeleted() {\n\t\treturn nil, fmt.Errorf(\"table %s is deleted\", tableName)\n\t}\n\n\t// Cache the lease\n\ttableID = lease.TableID\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\tts = &tableState{\n\t\t\ttableID:   tableID,\n\t\t\ttableName: tableName,\n\t\t\tversions:  make(map[int64]*LeaseState),\n\t\t}\n\t\tlm.tableStates[tableID] = ts\n\t}\n\n\tts.AddVersion(lease)\n\tlm.nameCache.Set(lm.dbID, tableName, tableID)\n\n\t// Increment refcount\n\terr = lease.IncrementRefCount()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to increment refcount: %w\", err)\n\t}\n\n\tlm.leasedLeases[lease] = true\n\treturn lease, nil\n}\n\n// Release decrements refcount and removes lease if appropriate\nfunc (lm *LeaseManager) Release(lease *LeaseState) error {\n\tif lease == nil {\n\t\treturn fmt.Errorf(\"cannot release nil lease\")\n\t}\n\n\terr := lease.DecrementRefCount()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to decrement refcount: %w\", err)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\trefCount := lease.GetRefCount()\n\n\t// If refcount is zero and lease is deleted or not latest version, remove it\n\tif refCount == 0 {\n\t\tts, exists := lm.tableStates[lease.TableID]\n\t\tif exists {\n\t\t\tisDeleted := lease.IsDeleted()\n\t\t\tisLatest := ts.GetLatestVersion() == lease.Version\n\n\t\t\tif isDeleted || !isLatest {\n\t\t\t\t// Remove from cache\n\t\t\t\tts.RemoveVersion(lease.Version)\n\t\t\t\tdelete(lm.leasedLeases, lease)\n\n\t\t\t\t// Notify store for cleanup\n\t\t\t\terr := lm.store.Cleanup(lm.dbID, lease.TableID, lease.Version)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to cleanup lease: %w\", err)\n\t\t\t\t}\n\n\t\t\t\t// If table is deleted and no more versions, remove from tableStates\n\t\t\t\tif isDeleted && len(ts.versions) == 0 {\n\t\t\t\t\tdelete(lm.tableStates, lease.TableID)\n\t\t\t\t\tlm.nameCache.Delete(lm.dbID, lease.TableName)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarkTableDeleted marks a table as deleted\nfunc (lm *LeaseManager) MarkTableDeleted(tableID int64) error {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\treturn fmt.Errorf(\"table not found: %d\", tableID)\n\t}\n\n\tts.MarkDeleted()\n\n\t// Mark all versions as deleted\n\tts.mu.RLock()\n\tversions := make([]*LeaseState, 0, len(ts.versions))\n\tfor _, lease := range ts.versions {\n\t\tversions = append(versions, lease)\n\t}\n\tts.mu.RUnlock()\n\n\tfor _, lease := range versions {\n\t\tlease.MarkDeleted()\n\t}\n\n\treturn nil\n}\n\n// MockLeaseStore is a mock implementation of LeaseStore for testing\ntype MockLeaseStore struct {\n\tmu     sync.RWMutex\n\tleases map[string]*LeaseState\n}\n\n// NewMockLeaseStore creates a new mock lease store\nfunc NewMockLeaseStore() *MockLeaseStore {\n\treturn &MockLeaseStore{\n\t\tleases: make(map[string]*LeaseState),\n\t}\n}\n\n// GetLatestLease returns the latest lease for a table\nfunc (mls *MockLeaseStore) GetLatestLease(dbID int64, tableName string) (*LeaseState, error) {\n\tmls.mu.RLock()\n\tdefer mls.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tlease, exists := mls.leases[key]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"lease not found\")\n\t}\n\treturn lease, nil\n}\n\n// Cleanup handles lease cleanup\nfunc (mls *MockLeaseStore) Cleanup(dbID int64, tableID int64, version int64) error {\n\treturn nil\n}\n\n// AddLease adds a lease to the mock store\nfunc (mls *MockLeaseStore) AddLease(dbID int64, lease *LeaseState) {\n\tmls.mu.Lock()\n\tdefer mls.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, lease.TableName)\n\tmls.leases[key] = lease\n}\n\nfunc main() {\n\tstore := NewMockLeaseStore()\n\n\tlease1 := &LeaseState{\n\t\tTableID:   1,\n\t\tTableName: \"users\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease1)\n\n\tlm := NewLeaseManager(1, store)\n\n\t// Acquire lease by name\n\tacquired1, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired1.TableID, acquired1.TableName, acquired1.Version, acquired1.GetRefCount())\n\n\t// Acquire same lease again (should return cached)\n\tacquired2, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease again: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease again: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired2.TableID, acquired2.TableName, acquired2.Version, acquired2.GetRefCount())\n\n\tif acquired1 == acquired2 {\n\t\tfmt.Println(\"\u2713 Same lease object returned from cache\")\n\t}\n\n\t// Release lease\n\terr = lm.Release(acquired1)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease: RefCount=%d\\n\", acquired1.GetRefCount())\n\n\t// Release second reference\n\terr = lm.Release(acquired2)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease again: RefCount=%d\\n\", acquired2.GetRefCount())\n\n\t// Test deletion\n\tlease2 := &LeaseState{\n\t\tTableID:   2,\n\t\tTableName: \"orders\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease2)\n\n\tacquired3, err := lm.AcquireByName(\"orders\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring orders lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired orders lease: TableID=%d, TableName=%s, RefCount=%",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:73: syntax error: unexpected EOF in argument list; possibly missing comma or )"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:73: syntax error: unexpected EOF in argument list; possibly missing comma or )\n\n\nGolang errors in file: [/tmp/go_synthesis_5pjpcmqi/main.go]:\n\n  > [line 180 : column 12] - tnc.Unlock undefined (type *tableNameCache has no field or method Unlock)\n\n  > [line 447 : column 2] - declared and not used: acquired3\n\n  > [line 452 : column 13] - malformed constant: \"Acquired orders lease: TableID=%d, TableName=%s, RefCount=%\n\n  > [line 452 : column 13] - string literal not terminated\n\n  > [line 452 : column 73] - missing ',' before newline in argument list\n\n  > [line 452 : column 73] - expected '}', found 'EOF'\n\n  > [line 452 : column 73] - expected ';', found 'EOF'\n\n  > [line 452 : column 73] - expected ';', found 'EOF'\n\n  > [line 452 : column 73] - expected ')', found 'EOF'\n\n\n\n[\u001b[37;40m/tmp/go_synthesis_5pjpcmqi/main.go:339\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    338: \tfor _, lease := range versions {\n  > 339: \t\tlease.MarkDeleted()\n    340: \t}\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 452\n  Nosec  : 0\n  Issues : \u001b[1;31m1\u001b[0m\n\n[gosec] 2025/12/01 14:00:48 Including rules: default\n[gosec] 2025/12/01 14:00:48 Excluding rules: default\n[gosec] 2025/12/01 14:00:48 Including analyzers: default\n[gosec] 2025/12/01 14:00:48 Excluding analyzers: default\n[gosec] 2025/12/01 14:00:48 Import directory: /tmp/go_synthesis_5pjpcmqi\n[gosec] 2025/12/01 14:00:48 Checking package: main\n[gosec] 2025/12/01 14:00:48 Checking file: /tmp/go_synthesis_5pjpcmqi/main.go\n[gosec] 2025/12/01 14:00:49 Panic when running SSA analyzer on package: main. Panic: runtime error: invalid memory address or nil pointer dereference\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xecea40?, 0x1998730?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*Program).packageLevelMember(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/source.go:187\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000a69440, 0xc000aae000, {0x11e2648?, 0xc000bd4540}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:820 +0x1b2b\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000a69440, 0xc000aae000, {0x11e2648, 0xc000bd4540})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000a69440, 0xc000aae000, {0x11e26d8?, 0xc000c18c48}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:842 +0x1031\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000a69440, 0xc000aae000, {0x11e26d8, 0xc000c18c48})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).setCallFunc(0xc000a69440?, 0xc000aae000?, 0xc000c1bbc0?, 0xc000bf8e48)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1066 +0x2b6\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc000a69440, 0xc000aae000, 0xc000c1bbc0, 0xc000bf8e48)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1144 +0x2b\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000a69440, 0xc000aae000, {0x11e2df0?, 0xc000bd21d0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2739 +0xef6\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000a69440, 0xc000aae000, {0x11e2eb0?, 0xc000bd0cc0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000a69440, 0xc000aae000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000aae000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000a69440)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc0009fef80)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc00018c240?, 0xc000c12ba0?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc000a9a000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc0008c7520)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc0009fe980, 0xc0008c7520)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc0009fe980, {0x0, 0x0, 0x0}, {0xc000053530, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 14:00:49 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ')', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected '}', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: missing ',' before newline in argument list\n/tmp/go_synthesis_5pjpcmqi/main.go:180:12: tnc.Unlock undefined (type *tableNameCache has no field or method Unlock)\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders lease: TableID=%d, TableName=%s, RefCount=%\n/tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:73: syntax error: unexpected EOF in argument list; possibly missing comma or ) /tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated /tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ')', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected '}', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:73: missing ',' before newline in argument list /tmp/go_synthesis_5pjpcmqi/main.go:180:12: tnc.Unlock undefined (type *tableNameCache has no field or method Unlock) /tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders lease: TableID=%d, TableName=%s, RefCount=% /tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:73: syntax error: unexpected EOF in argument list; possibly missing comma or )\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ')', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: expected '}', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:73: missing ',' before newline in argument list\n/tmp/go_synthesis_5pjpcmqi/main.go:180:12: tnc.Unlock undefined (type *tableNameCache has no field or method Unlock)\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders lease: TableID=%d, TableName=%s, RefCount=%\n/tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:73: syntax error: unexpected EOF in argument list; possibly missing comma or ) (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// LeaseState represents the metadata state of a table lease\ntype LeaseState struct {\n\tTableID   int64\n\tTableName string\n\tVersion   int64\n\tRefCount  int64\n\tDeleted   bool\n\tmu        sync.RWMutex\n}\n\n// IncrementRefCount safely increments the reference count\nfunc (ls *LeaseState) IncrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"cannot increment refcount on deleted lease\")\n\t}\n\tls.RefCount++\n\treturn nil\n}\n\n// DecrementRefCount safely decrements the reference count\nfunc (ls *LeaseState) DecrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.RefCount <= 0 {\n\t\treturn fmt.Errorf(\"cannot decrement refcount below zero\")\n\t}\n\tls.RefCount--\n\treturn nil\n}\n\n// GetRefCount safely returns the current reference count\nfunc (ls *LeaseState) GetRefCount() int64 {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.RefCount\n}\n\n// IsDeleted safely checks if the lease is marked for deletion\nfunc (ls *LeaseState) IsDeleted() bool {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.Deleted\n}\n\n// MarkDeleted safely marks the lease as deleted\nfunc (ls *LeaseState) MarkDeleted() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"lease already marked as deleted\")\n\t}\n\tls.Deleted = true\n\treturn nil\n}\n\n// LeaseStore defines the backend interface for lease storage\ntype LeaseStore interface {\n\tGetLatestLease(dbID int64, tableName string) (*LeaseState, error)\n\tCleanup(dbID int64, tableID int64, version int64) error\n}\n\n// tableState manages all versions of leases for a specific table\ntype tableState struct {\n\tmu                 sync.RWMutex\n\ttableID            int64\n\ttableName          string\n\tversions           map[int64]*LeaseState\n\tlatestVersion      int64\n\tdeleted            bool\n\tcachedLease        *LeaseState\n\tcachedLeaseVersion int64\n}\n\n// GetLatestVersion returns the latest version number for the table\nfunc (ts *tableState) GetLatestVersion() int64 {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.latestVersion\n}\n\n// IsDeleted checks if the table is marked as deleted\nfunc (ts *tableState) IsDeleted() bool {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.deleted\n}\n\n// MarkDeleted marks the table as deleted\nfunc (ts *tableState) MarkDeleted() {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\tts.deleted = true\n}\n\n// AddVersion adds a new lease version for this table\nfunc (ts *tableState) AddVersion(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.versions[lease.Version] = lease\n\tif lease.Version > ts.latestVersion {\n\t\tts.latestVersion = lease.Version\n\t\tts.cachedLease = lease\n\t\tts.cachedLeaseVersion = lease.Version\n\t}\n}\n\n// GetCachedLease returns the cached latest lease if available\nfunc (ts *tableState) GetCachedLease() *LeaseState {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\n\tif ts.cachedLease != nil && ts.cachedLeaseVersion == ts.latestVersion {\n\t\treturn ts.cachedLease\n\t}\n\treturn nil\n}\n\n// SetCachedLease updates the cached lease\nfunc (ts *tableState) SetCachedLease(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.cachedLease = lease\n\tts.cachedLeaseVersion = lease.Version\n}\n\n// RemoveVersion removes a specific lease version\nfunc (ts *tableState) RemoveVersion(version int64) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tdelete(ts.versions, version)\n\tif ts.cachedLeaseVersion == version {\n\t\tts.cachedLease = nil\n\t\tts.cachedLeaseVersion = -1\n\t}\n}\n\n// tableNameCache provides fast lookups by (dbID, tableName)\ntype tableNameCache struct {\n\tmu    sync.RWMutex\n\tcache map[string]int64 // key: dbID:tableName, value: tableID\n}\n\n// Get retrieves a tableID by (dbID, tableName)\nfunc (tnc *tableNameCache) Get(dbID int64, tableName string) (int64, bool) {\n\ttnc.mu.RLock()\n\tdefer tnc.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttableID, exists := tnc.cache[key]\n\treturn tableID, exists\n}\n\n// Set stores a mapping from (dbID, tableName) to tableID\nfunc (tnc *tableNameCache) Set(dbID int64, tableName string, tableID int64) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttnc.cache[key] = tableID\n}\n\n// Delete removes a mapping from the cache\nfunc (tnc *tableNameCache) Delete(dbID int64, tableName string) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tdelete(tnc.cache, key)\n}\n\n// LeaseManager manages all leases for a database\ntype LeaseManager struct {\n\tmu            sync.RWMutex\n\tdbID          int64\n\tstore         LeaseStore\n\ttableStates   map[int64]*tableState\n\tnameCache     *tableNameCache\n\tleasedLeases  map[*LeaseState]bool\n}\n\n// NewLeaseManager creates a new lease manager\nfunc NewLeaseManager(dbID int64, store LeaseStore) *LeaseManager {\n\treturn &LeaseManager{\n\t\tdbID:          dbID,\n\t\tstore:         store,\n\t\ttableStates:   make(map[int64]*tableState),\n\t\tnameCache:     &tableNameCache{cache: make(map[string]int64)},\n\t\tleasedLeases:  make(map[*LeaseState]bool),\n\t}\n}\n\n// AcquireByName returns a lease for a given (dbID, tableName) pair\nfunc (lm *LeaseManager) AcquireByName(tableName string) (*LeaseState, error) {\n\tlm.mu.Lock()\n\n\t// Try to find cached lease by name\n\ttableID, exists := lm.nameCache.Get(lm.dbID, tableName)\n\tif exists {\n\t\tts, ok := lm.tableStates[tableID]\n\t\tif ok && !ts.IsDeleted() {\n\t\t\tcachedLease := ts.GetCachedLease()\n\t\t\tif cachedLease != nil && !cachedLease.IsDeleted() {\n\t\t\t\terr := cachedLease.IncrementRefCount()\n\t\t\t\tif err == nil {\n\t\t\t\t\tlm.leasedLeases[cachedLease] = true\n\t\t\t\t\tlm.mu.Unlock()\n\t\t\t\t\treturn cachedLease, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlm.mu.Unlock()\n\n\t// Fetch latest lease from store\n\tlease, err := lm.store.GetLatestLease(lm.dbID, tableName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch latest lease: %w\", err)\n\t}\n\n\tif lease == nil {\n\t\treturn nil, fmt.Errorf(\"lease not found for table: %s\", tableName)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\t// Check if table was deleted after fetch\n\tif lease.IsDeleted() {\n\t\treturn nil, fmt.Errorf(\"table %s is deleted\", tableName)\n\t}\n\n\t// Cache the lease\n\ttableID = lease.TableID\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\tts = &tableState{\n\t\t\ttableID:    tableID,\n\t\t\ttableName:  tableName,\n\t\t\tversions:   make(map[int64]*LeaseState),\n\t\t}\n\t\tlm.tableStates[tableID] = ts\n\t}\n\n\tts.AddVersion(lease)\n\tlm.nameCache.Set(lm.dbID, tableName, tableID)\n\n\t// Increment refcount\n\terr = lease.IncrementRefCount()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to increment refcount: %w\", err)\n\t}\n\n\tlm.leasedLeases[lease] = true\n\treturn lease, nil\n}\n\n// Release decrements refcount and removes lease if appropriate\nfunc (lm *LeaseManager) Release(lease *LeaseState) error {\n\tif lease == nil {\n\t\treturn fmt.Errorf(\"cannot release nil lease\")\n\t}\n\n\terr := lease.DecrementRefCount()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to decrement refcount: %w\", err)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\trefCount := lease.GetRefCount()\n\n\t// If refcount is zero and lease is deleted or not latest version, remove it\n\tif refCount == 0 {\n\t\tts, exists := lm.tableStates[lease.TableID]\n\t\tif exists {\n\t\t\tisDeleted := lease.IsDeleted()\n\t\t\tisLatest := ts.GetLatestVersion() == lease.Version\n\n\t\t\tif isDeleted || !isLatest {\n\t\t\t\t// Remove from cache\n\t\t\t\tts.RemoveVersion(lease.Version)\n\t\t\t\tdelete(lm.leasedLeases, lease)\n\n\t\t\t\t// Notify store for cleanup\n\t\t\t\tcleanupErr := lm.store.Cleanup(lm.dbID, lease.TableID, lease.Version)\n\t\t\t\tif cleanupErr != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to cleanup lease: %w\", cleanupErr)\n\t\t\t\t}\n\n\t\t\t\t// If table is deleted and no more versions, remove from tableStates\n\t\t\t\tif isDeleted && len(ts.versions) == 0 {\n\t\t\t\t\tdelete(lm.tableStates, lease.TableID)\n\t\t\t\t\tlm.nameCache.Delete(lm.dbID, lease.TableName)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarkTableDeleted marks a table as deleted\nfunc (lm *LeaseManager) MarkTableDeleted(tableID int64) error {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\treturn fmt.Errorf(\"table not found: %d\", tableID)\n\t}\n\n\tts.MarkDeleted()\n\n\t// Mark all versions as deleted\n\tts.mu.RLock()\n\tversions := make([]*LeaseState, 0, len(ts.versions))\n\tfor _, lease := range ts.versions {\n\t\tversions = append(versions, lease)\n\t}\n\tts.mu.RUnlock()\n\n\tfor _, lease := range versions {\n\t\t_ = lease.MarkDeleted()\n\t}\n\n\treturn nil\n}\n\n// MockLeaseStore is a mock implementation of LeaseStore for testing\ntype MockLeaseStore struct {\n\tmu     sync.RWMutex\n\tleases map[string]*LeaseState\n}\n\n// NewMockLeaseStore creates a new mock lease store\nfunc NewMockLeaseStore() *MockLeaseStore {\n\treturn &MockLeaseStore{\n\t\tleases: make(map[string]*LeaseState),\n\t}\n}\n\n// GetLatestLease returns the latest lease for a table\nfunc (mls *MockLeaseStore) GetLatestLease(dbID int64, tableName string) (*LeaseState, error) {\n\tmls.mu.RLock()\n\tdefer mls.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tlease, exists := mls.leases[key]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"lease not found\")\n\t}\n\treturn lease, nil\n}\n\n// Cleanup handles lease cleanup\nfunc (mls *MockLeaseStore) Cleanup(dbID int64, tableID int64, version int64) error {\n\treturn nil\n}\n\n// AddLease adds a lease to the mock store\nfunc (mls *MockLeaseStore) AddLease(dbID int64, lease *LeaseState) {\n\tmls.mu.Lock()\n\tdefer mls.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, lease.TableName)\n\tmls.leases[key] = lease\n}\n\nfunc main() {\n\tstore := NewMockLeaseStore()\n\n\tlease1 := &LeaseState{\n\t\tTableID:   1,\n\t\tTableName: \"users\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease1)\n\n\tlm := NewLeaseManager(1, store)\n\n\t// Acquire lease by name\n\tacquired1, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired1.TableID, acquired1.TableName, acquired1.Version, acquired1.GetRefCount())\n\n\t// Acquire same lease again (should return cached)\n\tacquired2, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease again: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease again: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired2.TableID, acquired2.TableName, acquired2.Version, acquired2.GetRefCount())\n\n\tif acquired1 == acquired2 {\n\t\tfmt.Println(\"\u2713 Same lease object returned from cache\")\n\t}\n\n\t// Release lease\n\terr = lm.Release(acquired1)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease: RefCount=%d\\n\", acquired1.GetRefCount())\n\n\t// Release second reference\n\terr = lm.Release(acquired2)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease again: RefCount=%d\\n\", acquired2.GetRefCount())\n\n\t// Test deletion\n\tlease2 := &LeaseState{\n\t\tTableID:   2,\n\t\tTableName: \"orders\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease2)\n\n\tacquired3, err := lm.AcquireByName(\"orders\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring orders lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired orders",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )\n\n\nGolang errors in file: [/tmp/go_synthesis_5pjpcmqi/main.go]:\n\n  > [line 447 : column 2] - declared and not used: acquired3\n\n  > [line 452 : column 13] - malformed constant: \"Acquired orders\n\n  > [line 452 : column 13] - string literal not terminated\n\n  > [line 452 : column 29] - missing ',' before newline in argument list\n\n  > [line 452 : column 29] - expected '}', found 'EOF'\n\n  > [line 452 : column 29] - expected ';', found 'EOF'\n\n  > [line 452 : column 29] - expected ';', found 'EOF'\n\n  > [line 452 : column 29] - expected ')', found 'EOF'\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 452\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 14:01:11 Including rules: default\n[gosec] 2025/12/01 14:01:11 Excluding rules: default\n[gosec] 2025/12/01 14:01:11 Including analyzers: default\n[gosec] 2025/12/01 14:01:11 Excluding analyzers: default\n[gosec] 2025/12/01 14:01:11 Import directory: /tmp/go_synthesis_5pjpcmqi\n[gosec] 2025/12/01 14:01:11 Checking package: main\n[gosec] 2025/12/01 14:01:11 Checking file: /tmp/go_synthesis_5pjpcmqi/main.go\n[gosec] 2025/12/01 14:01:12 Panic when running SSA analyzer on package: main. Panic: non-constant BasicLit\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xe6fbe0?, 0x11d2c90?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000a876b0, 0xc000ad2400, {0x11e26a8?, 0xc000bd51c0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:652 +0x29c5\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000a876b0, 0xc000ad2400, {0x11e26a8, 0xc000bd51c0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).emitCallArgs(0xc000a876b0, 0xc000ad2400, 0xc000b914c0, 0xc000bd8040, {0x0?, 0x0, 0x78?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1090 +0x105\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc000a876b0, 0xc000ad2400, 0xc000bd8040, 0xc000b46f40)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1151 +0x85\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000a876b0, 0xc000ad2400, {0x11e2708?, 0xc000bd8040}, {0x7, {0x11de938, 0xc000b87128}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:724 +0x2105\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000a876b0, 0xc000ad2400, {0x11e2708, 0xc000bd8040})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000a876b0, 0xc000ad2400, {0x11e2d00?, 0xc000bd61b0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2699 +0xf5f\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000a876b0, 0xc000ad2400, {0x11e2eb0?, 0xc000bd2450?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000a876b0, 0xc000ad2400)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000ad2400)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000a876b0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc000976c00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc000624090?, 0xc000bb70e0?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc000aaa000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc00090b520)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc0009f6980, 0xc00090b520)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc0009f6980, {0x0, 0x0, 0x0}, {0xc000053530, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 14:01:12 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders\n/tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or ) /tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list /tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders /tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders\n/tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or ) (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// LeaseState represents the metadata state of a table lease\ntype LeaseState struct {\n\tTableID   int64\n\tTableName string\n\tVersion   int64\n\tRefCount  int64\n\tDeleted   bool\n\tmu        sync.RWMutex\n}\n\n// IncrementRefCount safely increments the reference count\nfunc (ls *LeaseState) IncrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"cannot increment refcount on deleted lease\")\n\t}\n\tls.RefCount++\n\treturn nil\n}\n\n// DecrementRefCount safely decrements the reference count\nfunc (ls *LeaseState) DecrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.RefCount <= 0 {\n\t\treturn fmt.Errorf(\"cannot decrement refcount below zero\")\n\t}\n\tls.RefCount--\n\treturn nil\n}\n\n// GetRefCount safely returns the current reference count\nfunc (ls *LeaseState) GetRefCount() int64 {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.RefCount\n}\n\n// IsDeleted safely checks if the lease is marked for deletion\nfunc (ls *LeaseState) IsDeleted() bool {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.Deleted\n}\n\n// MarkDeleted safely marks the lease as deleted\nfunc (ls *LeaseState) MarkDeleted() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"lease already marked as deleted\")\n\t}\n\tls.Deleted = true\n\treturn nil\n}\n\n// LeaseStore defines the backend interface for lease storage\ntype LeaseStore interface {\n\tGetLatestLease(dbID int64, tableName string) (*LeaseState, error)\n\tCleanup(dbID int64, tableID int64, version int64) error\n}\n\n// tableState manages all versions of leases for a specific table\ntype tableState struct {\n\tmu                 sync.RWMutex\n\ttableID            int64\n\ttableName          string\n\tversions           map[int64]*LeaseState\n\tlatestVersion      int64\n\tdeleted            bool\n\tcachedLease        *LeaseState\n\tcachedLeaseVersion int64\n}\n\n// GetLatestVersion returns the latest version number for the table\nfunc (ts *tableState) GetLatestVersion() int64 {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.latestVersion\n}\n\n// IsDeleted checks if the table is marked as deleted\nfunc (ts *tableState) IsDeleted() bool {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.deleted\n}\n\n// MarkDeleted marks the table as deleted\nfunc (ts *tableState) MarkDeleted() {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\tts.deleted = true\n}\n\n// AddVersion adds a new lease version for this table\nfunc (ts *tableState) AddVersion(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.versions[lease.Version] = lease\n\tif lease.Version > ts.latestVersion {\n\t\tts.latestVersion = lease.Version\n\t\tts.cachedLease = lease\n\t\tts.cachedLeaseVersion = lease.Version\n\t}\n}\n\n// GetCachedLease returns the cached latest lease if available\nfunc (ts *tableState) GetCachedLease() *LeaseState {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\n\tif ts.cachedLease != nil && ts.cachedLeaseVersion == ts.latestVersion {\n\t\treturn ts.cachedLease\n\t}\n\treturn nil\n}\n\n// SetCachedLease updates the cached lease\nfunc (ts *tableState) SetCachedLease(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.cachedLease = lease\n\tts.cachedLeaseVersion = lease.Version\n}\n\n// RemoveVersion removes a specific lease version\nfunc (ts *tableState) RemoveVersion(version int64) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tdelete(ts.versions, version)\n\tif ts.cachedLeaseVersion == version {\n\t\tts.cachedLease = nil\n\t\tts.cachedLeaseVersion = -1\n\t}\n}\n\n// tableNameCache provides fast lookups by (dbID, tableName)\ntype tableNameCache struct {\n\tmu    sync.RWMutex\n\tcache map[string]int64 // key: dbID:tableName, value: tableID\n}\n\n// Get retrieves a tableID by (dbID, tableName)\nfunc (tnc *tableNameCache) Get(dbID int64, tableName string) (int64, bool) {\n\ttnc.mu.RLock()\n\tdefer tnc.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttableID, exists := tnc.cache[key]\n\treturn tableID, exists\n}\n\n// Set stores a mapping from (dbID, tableName) to tableID\nfunc (tnc *tableNameCache) Set(dbID int64, tableName string, tableID int64) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttnc.cache[key] = tableID\n}\n\n// Delete removes a mapping from the cache\nfunc (tnc *tableNameCache) Delete(dbID int64, tableName string) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tdelete(tnc.cache, key)\n}\n\n// LeaseManager manages all leases for a database\ntype LeaseManager struct {\n\tmu            sync.RWMutex\n\tdbID          int64\n\tstore         LeaseStore\n\ttableStates   map[int64]*tableState\n\tnameCache     *tableNameCache\n\tleasedLeases  map[*LeaseState]bool\n}\n\n// NewLeaseManager creates a new lease manager\nfunc NewLeaseManager(dbID int64, store LeaseStore) *LeaseManager {\n\treturn &LeaseManager{\n\t\tdbID:          dbID,\n\t\tstore:         store,\n\t\ttableStates:   make(map[int64]*tableState),\n\t\tnameCache:     &tableNameCache{cache: make(map[string]int64)},\n\t\tleasedLeases:  make(map[*LeaseState]bool),\n\t}\n}\n\n// AcquireByName returns a lease for a given (dbID, tableName) pair\nfunc (lm *LeaseManager) AcquireByName(tableName string) (*LeaseState, error) {\n\tlm.mu.Lock()\n\n\t// Try to find cached lease by name\n\ttableID, exists := lm.nameCache.Get(lm.dbID, tableName)\n\tif exists {\n\t\tts, ok := lm.tableStates[tableID]\n\t\tif ok && !ts.IsDeleted() {\n\t\t\tcachedLease := ts.GetCachedLease()\n\t\t\tif cachedLease != nil && !cachedLease.IsDeleted() {\n\t\t\t\terr := cachedLease.IncrementRefCount()\n\t\t\t\tif err == nil {\n\t\t\t\t\tlm.leasedLeases[cachedLease] = true\n\t\t\t\t\tlm.mu.Unlock()\n\t\t\t\t\treturn cachedLease, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlm.mu.Unlock()\n\n\t// Fetch latest lease from store\n\tlease, err := lm.store.GetLatestLease(lm.dbID, tableName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch latest lease: %w\", err)\n\t}\n\n\tif lease == nil {\n\t\treturn nil, fmt.Errorf(\"lease not found for table: %s\", tableName)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\t// Check if table was deleted after fetch\n\tif lease.IsDeleted() {\n\t\treturn nil, fmt.Errorf(\"table %s is deleted\", tableName)\n\t}\n\n\t// Cache the lease\n\ttableID = lease.TableID\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\tts = &tableState{\n\t\t\ttableID:    tableID,\n\t\t\ttableName:  tableName,\n\t\t\tversions:   make(map[int64]*LeaseState),\n\t\t}\n\t\tlm.tableStates[tableID] = ts\n\t}\n\n\tts.AddVersion(lease)\n\tlm.nameCache.Set(lm.dbID, tableName, tableID)\n\n\t// Increment refcount\n\terr = lease.IncrementRefCount()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to increment refcount: %w\", err)\n\t}\n\n\tlm.leasedLeases[lease] = true\n\treturn lease, nil\n}\n\n// Release decrements refcount and removes lease if appropriate\nfunc (lm *LeaseManager) Release(lease *LeaseState) error {\n\tif lease == nil {\n\t\treturn fmt.Errorf(\"cannot release nil lease\")\n\t}\n\n\terr := lease.DecrementRefCount()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to decrement refcount: %w\", err)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\trefCount := lease.GetRefCount()\n\n\t// If refcount is zero and lease is deleted or not latest version, remove it\n\tif refCount == 0 {\n\t\tts, exists := lm.tableStates[lease.TableID]\n\t\tif exists {\n\t\t\tisDeleted := lease.IsDeleted()\n\t\t\tisLatest := ts.GetLatestVersion() == lease.Version\n\n\t\t\tif isDeleted || !isLatest {\n\t\t\t\t// Remove from cache\n\t\t\t\tts.RemoveVersion(lease.Version)\n\t\t\t\tdelete(lm.leasedLeases, lease)\n\n\t\t\t\t// Notify store for cleanup\n\t\t\t\tcleanupErr := lm.store.Cleanup(lm.dbID, lease.TableID, lease.Version)\n\t\t\t\tif cleanupErr != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to cleanup lease: %w\", cleanupErr)\n\t\t\t\t}\n\n\t\t\t\t// If table is deleted and no more versions, remove from tableStates\n\t\t\t\tif isDeleted && len(ts.versions) == 0 {\n\t\t\t\t\tdelete(lm.tableStates, lease.TableID)\n\t\t\t\t\tlm.nameCache.Delete(lm.dbID, lease.TableName)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarkTableDeleted marks a table as deleted\nfunc (lm *LeaseManager) MarkTableDeleted(tableID int64) error {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\treturn fmt.Errorf(\"table not found: %d\", tableID)\n\t}\n\n\tts.MarkDeleted()\n\n\t// Mark all versions as deleted\n\tts.mu.RLock()\n\tversions := make([]*LeaseState, 0, len(ts.versions))\n\tfor _, lease := range ts.versions {\n\t\tversions = append(versions, lease)\n\t}\n\tts.mu.RUnlock()\n\n\tfor _, lease := range versions {\n\t\t_ = lease.MarkDeleted()\n\t}\n\n\treturn nil\n}\n\n// MockLeaseStore is a mock implementation of LeaseStore for testing\ntype MockLeaseStore struct {\n\tmu     sync.RWMutex\n\tleases map[string]*LeaseState\n}\n\n// NewMockLeaseStore creates a new mock lease store\nfunc NewMockLeaseStore() *MockLeaseStore {\n\treturn &MockLeaseStore{\n\t\tleases: make(map[string]*LeaseState),\n\t}\n}\n\n// GetLatestLease returns the latest lease for a table\nfunc (mls *MockLeaseStore) GetLatestLease(dbID int64, tableName string) (*LeaseState, error) {\n\tmls.mu.RLock()\n\tdefer mls.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tlease, exists := mls.leases[key]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"lease not found\")\n\t}\n\treturn lease, nil\n}\n\n// Cleanup handles lease cleanup\nfunc (mls *MockLeaseStore) Cleanup(dbID int64, tableID int64, version int64) error {\n\treturn nil\n}\n\n// AddLease adds a lease to the mock store\nfunc (mls *MockLeaseStore) AddLease(dbID int64, lease *LeaseState) {\n\tmls.mu.Lock()\n\tdefer mls.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, lease.TableName)\n\tmls.leases[key] = lease\n}\n\nfunc main() {\n\tstore := NewMockLeaseStore()\n\n\tlease1 := &LeaseState{\n\t\tTableID:   1,\n\t\tTableName: \"users\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease1)\n\n\tlm := NewLeaseManager(1, store)\n\n\t// Acquire lease by name\n\tacquired1, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired1.TableID, acquired1.TableName, acquired1.Version, acquired1.GetRefCount())\n\n\t// Acquire same lease again (should return cached)\n\tacquired2, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease again: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease again: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired2.TableID, acquired2.TableName, acquired2.Version, acquired2.GetRefCount())\n\n\tif acquired1 == acquired2 {\n\t\tfmt.Println(\"\u2713 Same lease object returned from cache\")\n\t}\n\n\t// Release lease\n\terr = lm.Release(acquired1)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease: RefCount=%d\\n\", acquired1.GetRefCount())\n\n\t// Release second reference\n\terr = lm.Release(acquired2)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease again: RefCount=%d\\n\", acquired2.GetRefCount())\n\n\t// Test deletion\n\tlease2 := &LeaseState{\n\t\tTableID:   2,\n\t\tTableName: \"orders\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease2)\n\n\tacquired3, err := lm.AcquireByName(\"orders\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring orders lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired orders",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )\n\n\nGolang errors in file: [/tmp/go_synthesis_5pjpcmqi/main.go]:\n\n  > [line 447 : column 2] - declared and not used: acquired3\n\n  > [line 452 : column 13] - malformed constant: \"Acquired orders\n\n  > [line 452 : column 13] - string literal not terminated\n\n  > [line 452 : column 29] - missing ',' before newline in argument list\n\n  > [line 452 : column 29] - expected '}', found 'EOF'\n\n  > [line 452 : column 29] - expected ';', found 'EOF'\n\n  > [line 452 : column 29] - expected ';', found 'EOF'\n\n  > [line 452 : column 29] - expected ')', found 'EOF'\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 452\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 14:01:33 Including rules: default\n[gosec] 2025/12/01 14:01:33 Excluding rules: default\n[gosec] 2025/12/01 14:01:33 Including analyzers: default\n[gosec] 2025/12/01 14:01:33 Excluding analyzers: default\n[gosec] 2025/12/01 14:01:33 Import directory: /tmp/go_synthesis_5pjpcmqi\n[gosec] 2025/12/01 14:01:33 Checking package: main\n[gosec] 2025/12/01 14:01:33 Checking file: /tmp/go_synthesis_5pjpcmqi/main.go\n[gosec] 2025/12/01 14:01:34 Panic when running SSA analyzer on package: main. Panic: non-constant BasicLit\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xe6fbe0?, 0x11d2c90?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0004f8300, 0xc000539a00, {0x11e26a8?, 0xc000c6e4e0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:652 +0x29c5\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0004f8300, 0xc000539a00, {0x11e26a8, 0xc000c6e4e0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).emitCallArgs(0xc0004f8300, 0xc000539a00, 0xc000d51840, 0xc000c6c3c0, {0x0?, 0x0, 0x78?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1090 +0x105\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc0004f8300, 0xc000539a00, 0xc000c6c3c0, 0xc000b2a140)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1151 +0x85\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc0004f8300, 0xc000539a00, {0x11e2708?, 0xc000c6c3c0}, {0x7, {0x11de938, 0xc000d4cfa8}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:724 +0x2105\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc0004f8300, 0xc000539a00, {0x11e2708, 0xc000c6c3c0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc0004f8300, 0xc000539a00, {0x11e2d00?, 0xc000c6a6d0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2699 +0xf5f\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc0004f8300, 0xc000539a00, {0x11e2eb0?, 0xc000d7ec30?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc0004f8300, 0xc000539a00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000539a00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc0004f8300)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc000c9ea00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc00016e2d0?, 0xc000d62d80?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc0004fc000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc0004fb6c0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc000c9e900, 0xc0004fb6c0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc000c9e900, {0x0, 0x0, 0x0}, {0xc000052540, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 14:01:34 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders\n/tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or ) /tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list /tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders /tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders\n/tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or ) (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// LeaseState represents the metadata state of a table lease\ntype LeaseState struct {\n\tTableID   int64\n\tTableName string\n\tVersion   int64\n\tRefCount  int64\n\tDeleted   bool\n\tmu        sync.RWMutex\n}\n\n// IncrementRefCount safely increments the reference count\nfunc (ls *LeaseState) IncrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"cannot increment refcount on deleted lease\")\n\t}\n\tls.RefCount++\n\treturn nil\n}\n\n// DecrementRefCount safely decrements the reference count\nfunc (ls *LeaseState) DecrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.RefCount <= 0 {\n\t\treturn fmt.Errorf(\"cannot decrement refcount below zero\")\n\t}\n\tls.RefCount--\n\treturn nil\n}\n\n// GetRefCount safely returns the current reference count\nfunc (ls *LeaseState) GetRefCount() int64 {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.RefCount\n}\n\n// IsDeleted safely checks if the lease is marked for deletion\nfunc (ls *LeaseState) IsDeleted() bool {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.Deleted\n}\n\n// MarkDeleted safely marks the lease as deleted\nfunc (ls *LeaseState) MarkDeleted() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"lease already marked as deleted\")\n\t}\n\tls.Deleted = true\n\treturn nil\n}\n\n// LeaseStore defines the backend interface for lease storage\ntype LeaseStore interface {\n\tGetLatestLease(dbID int64, tableName string) (*LeaseState, error)\n\tCleanup(dbID int64, tableID int64, version int64) error\n}\n\n// tableState manages all versions of leases for a specific table\ntype tableState struct {\n\tmu                 sync.RWMutex\n\ttableID            int64\n\ttableName          string\n\tversions           map[int64]*LeaseState\n\tlatestVersion      int64\n\tdeleted            bool\n\tcachedLease        *LeaseState\n\tcachedLeaseVersion int64\n}\n\n// GetLatestVersion returns the latest version number for the table\nfunc (ts *tableState) GetLatestVersion() int64 {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.latestVersion\n}\n\n// IsDeleted checks if the table is marked as deleted\nfunc (ts *tableState) IsDeleted() bool {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.deleted\n}\n\n// MarkDeleted marks the table as deleted\nfunc (ts *tableState) MarkDeleted() {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\tts.deleted = true\n}\n\n// AddVersion adds a new lease version for this table\nfunc (ts *tableState) AddVersion(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.versions[lease.Version] = lease\n\tif lease.Version > ts.latestVersion {\n\t\tts.latestVersion = lease.Version\n\t\tts.cachedLease = lease\n\t\tts.cachedLeaseVersion = lease.Version\n\t}\n}\n\n// GetCachedLease returns the cached latest lease if available\nfunc (ts *tableState) GetCachedLease() *LeaseState {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\n\tif ts.cachedLease != nil && ts.cachedLeaseVersion == ts.latestVersion {\n\t\treturn ts.cachedLease\n\t}\n\treturn nil\n}\n\n// SetCachedLease updates the cached lease\nfunc (ts *tableState) SetCachedLease(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.cachedLease = lease\n\tts.cachedLeaseVersion = lease.Version\n}\n\n// RemoveVersion removes a specific lease version\nfunc (ts *tableState) RemoveVersion(version int64) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tdelete(ts.versions, version)\n\tif ts.cachedLeaseVersion == version {\n\t\tts.cachedLease = nil\n\t\tts.cachedLeaseVersion = -1\n\t}\n}\n\n// tableNameCache provides fast lookups by (dbID, tableName)\ntype tableNameCache struct {\n\tmu    sync.RWMutex\n\tcache map[string]int64 // key: dbID:tableName, value: tableID\n}\n\n// Get retrieves a tableID by (dbID, tableName)\nfunc (tnc *tableNameCache) Get(dbID int64, tableName string) (int64, bool) {\n\ttnc.mu.RLock()\n\tdefer tnc.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttableID, exists := tnc.cache[key]\n\treturn tableID, exists\n}\n\n// Set stores a mapping from (dbID, tableName) to tableID\nfunc (tnc *tableNameCache) Set(dbID int64, tableName string, tableID int64) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttnc.cache[key] = tableID\n}\n\n// Delete removes a mapping from the cache\nfunc (tnc *tableNameCache) Delete(dbID int64, tableName string) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tdelete(tnc.cache, key)\n}\n\n// LeaseManager manages all leases for a database\ntype LeaseManager struct {\n\tmu            sync.RWMutex\n\tdbID          int64\n\tstore         LeaseStore\n\ttableStates   map[int64]*tableState\n\tnameCache     *tableNameCache\n\tleasedLeases  map[*LeaseState]bool\n}\n\n// NewLeaseManager creates a new lease manager\nfunc NewLeaseManager(dbID int64, store LeaseStore) *LeaseManager {\n\treturn &LeaseManager{\n\t\tdbID:          dbID,\n\t\tstore:         store,\n\t\ttableStates:   make(map[int64]*tableState),\n\t\tnameCache:     &tableNameCache{cache: make(map[string]int64)},\n\t\tleasedLeases:  make(map[*LeaseState]bool),\n\t}\n}\n\n// AcquireByName returns a lease for a given (dbID, tableName) pair\nfunc (lm *LeaseManager) AcquireByName(tableName string) (*LeaseState, error) {\n\tlm.mu.Lock()\n\n\t// Try to find cached lease by name\n\ttableID, exists := lm.nameCache.Get(lm.dbID, tableName)\n\tif exists {\n\t\tts, ok := lm.tableStates[tableID]\n\t\tif ok && !ts.IsDeleted() {\n\t\t\tcachedLease := ts.GetCachedLease()\n\t\t\tif cachedLease != nil && !cachedLease.IsDeleted() {\n\t\t\t\terr := cachedLease.IncrementRefCount()\n\t\t\t\tif err == nil {\n\t\t\t\t\tlm.leasedLeases[cachedLease] = true\n\t\t\t\t\tlm.mu.Unlock()\n\t\t\t\t\treturn cachedLease, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlm.mu.Unlock()\n\n\t// Fetch latest lease from store\n\tlease, err := lm.store.GetLatestLease(lm.dbID, tableName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch latest lease: %w\", err)\n\t}\n\n\tif lease == nil {\n\t\treturn nil, fmt.Errorf(\"lease not found for table: %s\", tableName)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\t// Check if table was deleted after fetch\n\tif lease.IsDeleted() {\n\t\treturn nil, fmt.Errorf(\"table %s is deleted\", tableName)\n\t}\n\n\t// Cache the lease\n\ttableID = lease.TableID\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\tts = &tableState{\n\t\t\ttableID:    tableID,\n\t\t\ttableName:  tableName,\n\t\t\tversions:   make(map[int64]*LeaseState),\n\t\t}\n\t\tlm.tableStates[tableID] = ts\n\t}\n\n\tts.AddVersion(lease)\n\tlm.nameCache.Set(lm.dbID, tableName, tableID)\n\n\t// Increment refcount\n\terr = lease.IncrementRefCount()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to increment refcount: %w\", err)\n\t}\n\n\tlm.leasedLeases[lease] = true\n\treturn lease, nil\n}\n\n// Release decrements refcount and removes lease if appropriate\nfunc (lm *LeaseManager) Release(lease *LeaseState) error {\n\tif lease == nil {\n\t\treturn fmt.Errorf(\"cannot release nil lease\")\n\t}\n\n\terr := lease.DecrementRefCount()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to decrement refcount: %w\", err)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\trefCount := lease.GetRefCount()\n\n\t// If refcount is zero and lease is deleted or not latest version, remove it\n\tif refCount == 0 {\n\t\tts, exists := lm.tableStates[lease.TableID]\n\t\tif exists {\n\t\t\tisDeleted := lease.IsDeleted()\n\t\t\tisLatest := ts.GetLatestVersion() == lease.Version\n\n\t\t\tif isDeleted || !isLatest {\n\t\t\t\t// Remove from cache\n\t\t\t\tts.RemoveVersion(lease.Version)\n\t\t\t\tdelete(lm.leasedLeases, lease)\n\n\t\t\t\t// Notify store for cleanup\n\t\t\t\tcleanupErr := lm.store.Cleanup(lm.dbID, lease.TableID, lease.Version)\n\t\t\t\tif cleanupErr != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to cleanup lease: %w\", cleanupErr)\n\t\t\t\t}\n\n\t\t\t\t// If table is deleted and no more versions, remove from tableStates\n\t\t\t\tif isDeleted && len(ts.versions) == 0 {\n\t\t\t\t\tdelete(lm.tableStates, lease.TableID)\n\t\t\t\t\tlm.nameCache.Delete(lm.dbID, lease.TableName)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarkTableDeleted marks a table as deleted\nfunc (lm *LeaseManager) MarkTableDeleted(tableID int64) error {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\treturn fmt.Errorf(\"table not found: %d\", tableID)\n\t}\n\n\tts.MarkDeleted()\n\n\t// Mark all versions as deleted\n\tts.mu.RLock()\n\tversions := make([]*LeaseState, 0, len(ts.versions))\n\tfor _, lease := range ts.versions {\n\t\tversions = append(versions, lease)\n\t}\n\tts.mu.RUnlock()\n\n\tfor _, lease := range versions {\n\t\t_ = lease.MarkDeleted()\n\t}\n\n\treturn nil\n}\n\n// MockLeaseStore is a mock implementation of LeaseStore for testing\ntype MockLeaseStore struct {\n\tmu     sync.RWMutex\n\tleases map[string]*LeaseState\n}\n\n// NewMockLeaseStore creates a new mock lease store\nfunc NewMockLeaseStore() *MockLeaseStore {\n\treturn &MockLeaseStore{\n\t\tleases: make(map[string]*LeaseState),\n\t}\n}\n\n// GetLatestLease returns the latest lease for a table\nfunc (mls *MockLeaseStore) GetLatestLease(dbID int64, tableName string) (*LeaseState, error) {\n\tmls.mu.RLock()\n\tdefer mls.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tlease, exists := mls.leases[key]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"lease not found\")\n\t}\n\treturn lease, nil\n}\n\n// Cleanup handles lease cleanup\nfunc (mls *MockLeaseStore) Cleanup(dbID int64, tableID int64, version int64) error {\n\treturn nil\n}\n\n// AddLease adds a lease to the mock store\nfunc (mls *MockLeaseStore) AddLease(dbID int64, lease *LeaseState) {\n\tmls.mu.Lock()\n\tdefer mls.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, lease.TableName)\n\tmls.leases[key] = lease\n}\n\nfunc main() {\n\tstore := NewMockLeaseStore()\n\n\tlease1 := &LeaseState{\n\t\tTableID:   1,\n\t\tTableName: \"users\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease1)\n\n\tlm := NewLeaseManager(1, store)\n\n\t// Acquire lease by name\n\tacquired1, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired1.TableID, acquired1.TableName, acquired1.Version, acquired1.GetRefCount())\n\n\t// Acquire same lease again (should return cached)\n\tacquired2, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease again: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease again: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired2.TableID, acquired2.TableName, acquired2.Version, acquired2.GetRefCount())\n\n\tif acquired1 == acquired2 {\n\t\tfmt.Println(\"\u2713 Same lease object returned from cache\")\n\t}\n\n\t// Release lease\n\terr = lm.Release(acquired1)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease: RefCount=%d\\n\", acquired1.GetRefCount())\n\n\t// Release second reference\n\terr = lm.Release(acquired2)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease again: RefCount=%d\\n\", acquired2.GetRefCount())\n\n\t// Test deletion\n\tlease2 := &LeaseState{\n\t\tTableID:   2,\n\t\tTableName: \"orders\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease2)\n\n\tacquired3, err := lm.AcquireByName(\"orders\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring orders lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired orders",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )\n\n\nGolang errors in file: [/tmp/go_synthesis_5pjpcmqi/main.go]:\n\n  > [line 447 : column 2] - declared and not used: acquired3\n\n  > [line 452 : column 13] - malformed constant: \"Acquired orders\n\n  > [line 452 : column 13] - string literal not terminated\n\n  > [line 452 : column 29] - missing ',' before newline in argument list\n\n  > [line 452 : column 29] - expected '}', found 'EOF'\n\n  > [line 452 : column 29] - expected ';', found 'EOF'\n\n  > [line 452 : column 29] - expected ';', found 'EOF'\n\n  > [line 452 : column 29] - expected ')', found 'EOF'\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 452\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 14:01:55 Including rules: default\n[gosec] 2025/12/01 14:01:55 Excluding rules: default\n[gosec] 2025/12/01 14:01:55 Including analyzers: default\n[gosec] 2025/12/01 14:01:55 Excluding analyzers: default\n[gosec] 2025/12/01 14:01:55 Import directory: /tmp/go_synthesis_5pjpcmqi\n[gosec] 2025/12/01 14:01:55 Checking package: main\n[gosec] 2025/12/01 14:01:55 Checking file: /tmp/go_synthesis_5pjpcmqi/main.go\n[gosec] 2025/12/01 14:01:56 Panic when running SSA analyzer on package: main. Panic: non-constant BasicLit\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xe6fbe0?, 0x11d2c90?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000ca2cc0, 0xc000ce8000, {0x11e26a8?, 0xc000036340}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:652 +0x29c5\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000ca2cc0, 0xc000ce8000, {0x11e26a8, 0xc000036340})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).emitCallArgs(0xc000ca2cc0, 0xc000ce8000, 0xc000f47000, 0xc0001ea8c0, {0x0?, 0x0, 0x78?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1090 +0x105\ngolang.org/x/tools/go/ssa.(*builder).setCall(0xc000ca2cc0, 0xc000ce8000, 0xc0001ea8c0, 0xc000da9cc0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1151 +0x85\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000ca2cc0, 0xc000ce8000, {0x11e2708?, 0xc0001ea8c0}, {0x7, {0x11de938, 0xc000f40d68}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:724 +0x2105\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000ca2cc0, 0xc000ce8000, {0x11e2708, 0xc0001ea8c0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000ca2cc0, 0xc000ce8000, {0x11e2d00?, 0xc0005e1d00?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2699 +0xf5f\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000ca2cc0, 0xc000ce8000, {0x11e2eb0?, 0xc000cb53e0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000ca2cc0, 0xc000ce8000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000ce8000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000ca2cc0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc0001efb80)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc000f58a20?, 0xc000510900?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc000cb2000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc000c52340)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc000374980, 0xc000c52340)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc000374980, {0x0, 0x0, 0x0}, {0xc000052d50, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 14:01:56 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders\n/tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or ) /tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list /tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders /tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or )\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: string literal not terminated\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ')', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: expected '}', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:29: missing ',' before newline in argument list\n/tmp/go_synthesis_5pjpcmqi/main.go:452:13: malformed constant: \"Acquired orders\n/tmp/go_synthesis_5pjpcmqi/main.go:447:2: declared and not used: acquired3\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:452:13: string not terminated\n./main.go:452:29: syntax error: unexpected EOF in argument list; possibly missing comma or ) (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// LeaseState represents the metadata state of a table lease\ntype LeaseState struct {\n\tTableID   int64\n\tTableName string\n\tVersion   int64\n\tRefCount  int64\n\tDeleted   bool\n\tmu        sync.RWMutex\n}\n\n// IncrementRefCount safely increments the reference count\nfunc (ls *LeaseState) IncrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"cannot increment refcount on deleted lease\")\n\t}\n\tls.RefCount++\n\treturn nil\n}\n\n// DecrementRefCount safely decrements the reference count\nfunc (ls *LeaseState) DecrementRefCount() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.RefCount <= 0 {\n\t\treturn fmt.Errorf(\"cannot decrement refcount below zero\")\n\t}\n\tls.RefCount--\n\treturn nil\n}\n\n// GetRefCount safely returns the current reference count\nfunc (ls *LeaseState) GetRefCount() int64 {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.RefCount\n}\n\n// IsDeleted safely checks if the lease is marked for deletion\nfunc (ls *LeaseState) IsDeleted() bool {\n\tls.mu.RLock()\n\tdefer ls.mu.RUnlock()\n\treturn ls.Deleted\n}\n\n// MarkDeleted safely marks the lease as deleted\nfunc (ls *LeaseState) MarkDeleted() error {\n\tls.mu.Lock()\n\tdefer ls.mu.Unlock()\n\n\tif ls.Deleted {\n\t\treturn fmt.Errorf(\"lease already marked as deleted\")\n\t}\n\tls.Deleted = true\n\treturn nil\n}\n\n// LeaseStore defines the backend interface for lease storage\ntype LeaseStore interface {\n\tGetLatestLease(dbID int64, tableName string) (*LeaseState, error)\n\tCleanup(dbID int64, tableID int64, version int64) error\n}\n\n// tableState manages all versions of leases for a specific table\ntype tableState struct {\n\tmu                 sync.RWMutex\n\ttableID            int64\n\ttableName          string\n\tversions           map[int64]*LeaseState\n\tlatestVersion      int64\n\tdeleted            bool\n\tcachedLease        *LeaseState\n\tcachedLeaseVersion int64\n}\n\n// GetLatestVersion returns the latest version number for the table\nfunc (ts *tableState) GetLatestVersion() int64 {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.latestVersion\n}\n\n// IsDeleted checks if the table is marked as deleted\nfunc (ts *tableState) IsDeleted() bool {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn ts.deleted\n}\n\n// MarkDeleted marks the table as deleted\nfunc (ts *tableState) MarkDeleted() {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\tts.deleted = true\n}\n\n// AddVersion adds a new lease version for this table\nfunc (ts *tableState) AddVersion(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.versions[lease.Version] = lease\n\tif lease.Version > ts.latestVersion {\n\t\tts.latestVersion = lease.Version\n\t\tts.cachedLease = lease\n\t\tts.cachedLeaseVersion = lease.Version\n\t}\n}\n\n// GetCachedLease returns the cached latest lease if available\nfunc (ts *tableState) GetCachedLease() *LeaseState {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\n\tif ts.cachedLease != nil && ts.cachedLeaseVersion == ts.latestVersion {\n\t\treturn ts.cachedLease\n\t}\n\treturn nil\n}\n\n// SetCachedLease updates the cached lease\nfunc (ts *tableState) SetCachedLease(lease *LeaseState) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tts.cachedLease = lease\n\tts.cachedLeaseVersion = lease.Version\n}\n\n// RemoveVersion removes a specific lease version\nfunc (ts *tableState) RemoveVersion(version int64) {\n\tts.mu.Lock()\n\tdefer ts.mu.Unlock()\n\n\tdelete(ts.versions, version)\n\tif ts.cachedLeaseVersion == version {\n\t\tts.cachedLease = nil\n\t\tts.cachedLeaseVersion = -1\n\t}\n}\n\n// GetVersionsCount returns the count of versions\nfunc (ts *tableState) GetVersionsCount() int {\n\tts.mu.RLock()\n\tdefer ts.mu.RUnlock()\n\treturn len(ts.versions)\n}\n\n// tableNameCache provides fast lookups by (dbID, tableName)\ntype tableNameCache struct {\n\tmu    sync.RWMutex\n\tcache map[string]int64 // key: dbID:tableName, value: tableID\n}\n\n// Get retrieves a tableID by (dbID, tableName)\nfunc (tnc *tableNameCache) Get(dbID int64, tableName string) (int64, bool) {\n\ttnc.mu.RLock()\n\tdefer tnc.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttableID, exists := tnc.cache[key]\n\treturn tableID, exists\n}\n\n// Set stores a mapping from (dbID, tableName) to tableID\nfunc (tnc *tableNameCache) Set(dbID int64, tableName string, tableID int64) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\ttnc.cache[key] = tableID\n}\n\n// Delete removes a mapping from the cache\nfunc (tnc *tableNameCache) Delete(dbID int64, tableName string) {\n\ttnc.mu.Lock()\n\tdefer tnc.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tdelete(tnc.cache, key)\n}\n\n// LeaseManager manages all leases for a database\ntype LeaseManager struct {\n\tmu            sync.RWMutex\n\tdbID          int64\n\tstore         LeaseStore\n\ttableStates   map[int64]*tableState\n\tnameCache     *tableNameCache\n\tleasedLeases  map[*LeaseState]bool\n}\n\n// NewLeaseManager creates a new lease manager\nfunc NewLeaseManager(dbID int64, store LeaseStore) *LeaseManager {\n\treturn &LeaseManager{\n\t\tdbID:          dbID,\n\t\tstore:         store,\n\t\ttableStates:   make(map[int64]*tableState),\n\t\tnameCache:     &tableNameCache{cache: make(map[string]int64)},\n\t\tleasedLeases:  make(map[*LeaseState]bool),\n\t}\n}\n\n// AcquireByName returns a lease for a given (dbID, tableName) pair\nfunc (lm *LeaseManager) AcquireByName(tableName string) (*LeaseState, error) {\n\tlm.mu.Lock()\n\n\t// Try to find cached lease by name\n\ttableID, exists := lm.nameCache.Get(lm.dbID, tableName)\n\tif exists {\n\t\tts, ok := lm.tableStates[tableID]\n\t\tif ok && !ts.IsDeleted() {\n\t\t\tcachedLease := ts.GetCachedLease()\n\t\t\tif cachedLease != nil && !cachedLease.IsDeleted() {\n\t\t\t\terr := cachedLease.IncrementRefCount()\n\t\t\t\tif err == nil {\n\t\t\t\t\tlm.leasedLeases[cachedLease] = true\n\t\t\t\t\tlm.mu.Unlock()\n\t\t\t\t\treturn cachedLease, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlm.mu.Unlock()\n\n\t// Fetch latest lease from store\n\tlease, err := lm.store.GetLatestLease(lm.dbID, tableName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch latest lease: %w\", err)\n\t}\n\n\tif lease == nil {\n\t\treturn nil, fmt.Errorf(\"lease not found for table: %s\", tableName)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\t// Check if table was deleted after fetch\n\tif lease.IsDeleted() {\n\t\treturn nil, fmt.Errorf(\"table %s is deleted\", tableName)\n\t}\n\n\t// Cache the lease\n\ttableID = lease.TableID\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\tts = &tableState{\n\t\t\ttableID:    tableID,\n\t\t\ttableName:  tableName,\n\t\t\tversions:   make(map[int64]*LeaseState),\n\t\t}\n\t\tlm.tableStates[tableID] = ts\n\t}\n\n\tts.AddVersion(lease)\n\tlm.nameCache.Set(lm.dbID, tableName, tableID)\n\n\t// Increment refcount\n\terr = lease.IncrementRefCount()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to increment refcount: %w\", err)\n\t}\n\n\tlm.leasedLeases[lease] = true\n\treturn lease, nil\n}\n\n// Release decrements refcount and removes lease if appropriate\nfunc (lm *LeaseManager) Release(lease *LeaseState) error {\n\tif lease == nil {\n\t\treturn fmt.Errorf(\"cannot release nil lease\")\n\t}\n\n\terr := lease.DecrementRefCount()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to decrement refcount: %w\", err)\n\t}\n\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\trefCount := lease.GetRefCount()\n\n\t// If refcount is zero and lease is deleted or not latest version, remove it\n\tif refCount == 0 {\n\t\tts, exists := lm.tableStates[lease.TableID]\n\t\tif exists {\n\t\t\tisDeleted := lease.IsDeleted()\n\t\t\tisLatest := ts.GetLatestVersion() == lease.Version\n\n\t\t\tif isDeleted || !isLatest {\n\t\t\t\t// Remove from cache\n\t\t\t\tts.RemoveVersion(lease.Version)\n\t\t\t\tdelete(lm.leasedLeases, lease)\n\n\t\t\t\t// Notify store for cleanup\n\t\t\t\tcleanupErr := lm.store.Cleanup(lm.dbID, lease.TableID, lease.Version)\n\t\t\t\tif cleanupErr != nil {\n\t\t\t\t\treturn fmt.Errorf(\"failed to cleanup lease: %w\", cleanupErr)\n\t\t\t\t}\n\n\t\t\t\t// If table is deleted and no more versions, remove from tableStates\n\t\t\t\tif isDeleted && ts.GetVersionsCount() == 0 {\n\t\t\t\t\tdelete(lm.tableStates, lease.TableID)\n\t\t\t\t\tlm.nameCache.Delete(lm.dbID, lease.TableName)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// MarkTableDeleted marks a table as deleted\nfunc (lm *LeaseManager) MarkTableDeleted(tableID int64) error {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tts, exists := lm.tableStates[tableID]\n\tif !exists {\n\t\treturn fmt.Errorf(\"table not found: %d\", tableID)\n\t}\n\n\tts.MarkDeleted()\n\n\t// Mark all versions as deleted\n\tts.mu.RLock()\n\tversions := make([]*LeaseState, 0, len(ts.versions))\n\tfor _, lease := range ts.versions {\n\t\tversions = append(versions, lease)\n\t}\n\tts.mu.RUnlock()\n\n\tfor _, lease := range versions {\n\t\t_ = lease.MarkDeleted()\n\t}\n\n\treturn nil\n}\n\n// MockLeaseStore is a mock implementation of LeaseStore for testing\ntype MockLeaseStore struct {\n\tmu     sync.RWMutex\n\tleases map[string]*LeaseState\n}\n\n// NewMockLeaseStore creates a new mock lease store\nfunc NewMockLeaseStore() *MockLeaseStore {\n\treturn &MockLeaseStore{\n\t\tleases: make(map[string]*LeaseState),\n\t}\n}\n\n// GetLatestLease returns the latest lease for a table\nfunc (mls *MockLeaseStore) GetLatestLease(dbID int64, tableName string) (*LeaseState, error) {\n\tmls.mu.RLock()\n\tdefer mls.mu.RUnlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, tableName)\n\tlease, exists := mls.leases[key]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"lease not found\")\n\t}\n\treturn lease, nil\n}\n\n// Cleanup handles lease cleanup\nfunc (mls *MockLeaseStore) Cleanup(dbID int64, tableID int64, version int64) error {\n\treturn nil\n}\n\n// AddLease adds a lease to the mock store\nfunc (mls *MockLeaseStore) AddLease(dbID int64, lease *LeaseState) {\n\tmls.mu.Lock()\n\tdefer mls.mu.Unlock()\n\n\tkey := fmt.Sprintf(\"%d:%s\", dbID, lease.TableName)\n\tmls.leases[key] = lease\n}\n\nfunc main() {\n\tstore := NewMockLeaseStore()\n\n\tlease1 := &LeaseState{\n\t\tTableID:   1,\n\t\tTableName: \"users\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease1)\n\n\tlm := NewLeaseManager(1, store)\n\n\t// Acquire lease by name\n\tacquired1, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired1.TableID, acquired1.TableName, acquired1.Version, acquired1.GetRefCount())\n\n\t// Acquire same lease again (should return cached)\n\tacquired2, err := lm.AcquireByName(\"users\")\n\tif err != nil {\n\t\tfmt.Printf(\"Error acquiring lease again: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Acquired lease again: TableID=%d, TableName=%s, Version=%d, RefCount=%d\\n\",\n\t\tacquired2.TableID, acquired2.TableName, acquired2.Version, acquired2.GetRefCount())\n\n\tif acquired1 == acquired2 {\n\t\tfmt.Println(\"\u2713 Same lease object returned from cache\")\n\t}\n\n\t// Release lease\n\terr = lm.Release(acquired1)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease: RefCount=%d\\n\", acquired1.GetRefCount())\n\n\t// Release second reference\n\terr = lm.Release(acquired2)\n\tif err != nil {\n\t\tfmt.Printf(\"Error releasing lease: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Released lease again: RefCount=%d\\n\", acquired2.GetRefCount())\n\n\t// Test deletion\n\tlease2 := &LeaseState{\n\t\tTableID:   2,\n\t\tTableName: \"orders\",\n\t\tVersion:   1,\n\t\tRefCount:  0,\n\t\tDeleted:   false,\n\t}\n\tstore.AddLease(1, lease2)",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:452:27: syntax error: unexpected EOF, expected }"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:452:27: syntax error: unexpected EOF, expected }\n\n\nGolang errors in file: [/tmp/go_synthesis_5pjpcmqi/main.go]:\n\n  > [line 452 : column 27] - expected '}', found 'EOF'\n\n  > [line 452 : column 27] - expected ';', found 'EOF'\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 452\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 14:02:17 Including rules: default\n[gosec] 2025/12/01 14:02:17 Excluding rules: default\n[gosec] 2025/12/01 14:02:17 Including analyzers: default\n[gosec] 2025/12/01 14:02:17 Excluding analyzers: default\n[gosec] 2025/12/01 14:02:17 Import directory: /tmp/go_synthesis_5pjpcmqi\n[gosec] 2025/12/01 14:02:17 Checking package: main\n[gosec] 2025/12/01 14:02:17 Checking file: /tmp/go_synthesis_5pjpcmqi/main.go"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_5pjpcmqi/main.go:452:27: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:27: expected '}', found 'EOF'\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:452:27: syntax error: unexpected EOF, expected } /tmp/go_synthesis_5pjpcmqi/main.go:452:27: expected ';', found 'EOF' /tmp/go_synthesis_5pjpcmqi/main.go:452:27: expected '}', found 'EOF']"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:452:27: syntax error: unexpected EOF, expected }\n/tmp/go_synthesis_5pjpcmqi/main.go:452:27: expected ';', found 'EOF'\n/tmp/go_synthesis_5pjpcmqi/main.go:452:27: expected '}', found 'EOF'\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:452:27: syntax error: unexpected EOF, expected } (compile)"
                }
            ]
        }
    ],
    "passed": false
}