{
    "task": "task1.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"unsafe\"\n)\n\nconst (\n\tpageSize      = 4096\n\tmetaPageSize  = 1024\n\tmaxMapSize    = 1073741824 // 1GB\n\tmetaPage0     = 0\n\tmetaPage1     = 1\n\tdataPageStart = 2\n)\n\nvar (\n\terrTxnInProgress = errors.New(\"transaction already in progress\")\n\terrNotTxn        = errors.New(\"not in a transaction\")\n\terrReadOnly      = errors.New(\"read-only transaction cannot write\")\n\terrFileClosed    = errors.New(\"database file is closed\")\n\terrInvalidMeta   = errors.New(\"invalid metadata\")\n)\n\ntype Meta struct {\n\tVersion   uint32\n\tPageSize  uint32\n\tFreeSpace uint64\n\tPageCount uint64\n\tChecksum  uint32\n}\n\nfunc (m *Meta) Encode() []byte {\n\tbuf := new(bytes.Buffer)\n\tbinary.Write(buf, binary.LittleEndian, m.Version)\n\tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\tdata := buf.Bytes()\n\tchecksum := calculateChecksum(data)\n\tbinary.Write(buf, binary.LittleEndian, checksum)\n\treturn buf.Bytes()\n}\n\nfunc DecodeMeta(data []byte) (*Meta, error) {\n\tif len(data) < 24 {\n\t\treturn nil, errInvalidMeta\n\t}\n\tbuf := bytes.NewReader(data[:24])\n\tm := &Meta{}\n\tbinary.Read(buf, binary.LittleEndian, &m.Version)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\n\texpectedChecksum := calculateChecksum(data[:20])\n\tif m.Checksum != expectedChecksum {\n\t\treturn nil, errInvalidMeta\n\t}\n\treturn m, nil\n}\n\nfunc calculateChecksum(data []byte) uint32 {\n\tvar checksum uint32\n\tfor _, b := range data {\n\t\tchecksum += uint32(b)\n\t}\n\treturn checksum\n}\n\ntype Transaction interface {\n\tReadPage(pageNum uint64) ([]byte, error)\n\tWritePage(pageNum uint64, data []byte) error\n\tGetMeta() *Meta\n\tCommit() error\n\tRollback() error\n\tIsReadOnly() bool\n\tID() uint64\n}\n\ntype ReadTransaction struct {\n\tid       uint64\n\tdb       *Database\n\tmeta     *Meta\n\tmapData  []byte\n\tmapSize  uint64\n\tclosed   bool\n\tmu       sync.Mutex\n}\n\nfunc (rt *ReadTransaction) ID() uint64 {\n\treturn rt.id\n}\n\nfunc (rt *ReadTransaction) IsReadOnly() bool {\n\treturn true\n}\n\nfunc (rt *ReadTransaction) GetMeta() *Meta {\n\treturn rt.meta\n}\n\nfunc (rt *ReadTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > rt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, rt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (rt *ReadTransaction) WritePage(pageNum uint64, data []byte) error {\n\treturn errReadOnly\n}\n\nfunc (rt *ReadTransaction) Commit() error {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn errNotTxn\n\t}\n\n\trt.closed = true\n\trt.db.removeTransaction(rt.id)\n\treturn nil\n}\n\nfunc (rt *ReadTransaction) Rollback() error {\n\treturn rt.Commit()\n}\n\ntype WriteTransaction struct {\n\tid           uint64\n\tdb           *Database\n\tmeta         *Meta\n\toriginalMeta *Meta\n\tmapData      []byte\n\tmapSize      uint64\n\twriteBuffer  map[uint64][]byte\n\tclosed       bool\n\tmu           sync.Mutex\n}\n\nfunc (wt *WriteTransaction) ID() uint64 {\n\treturn wt.id\n}\n\nfunc (wt *WriteTransaction) IsReadOnly() bool {\n\treturn false\n}\n\nfunc (wt *WriteTransaction) GetMeta() *Meta {\n\treturn wt.meta\n}\n\nfunc (wt *WriteTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\tif cached, ok := wt.writeBuffer[pageNum]; ok {\n\t\tpage := make([]byte, pageSize)\n\t\tcopy(page, cached)\n\t\treturn page, nil\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > wt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, wt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (wt *WriteTransaction) WritePage(pageNum uint64, data []byte) error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\tif len(data) > pageSize {\n\t\treturn fmt.Errorf(\"data exceeds page size\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, data)\n\twt.writeBuffer[pageNum] = page\n\n\tif pageNum >= wt.meta.PageCount {\n\t\twt.meta.PageCount = pageNum + 1\n\t}\n\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Commit() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.db.writeMu.Lock()\n\tdefer wt.db.writeMu.Unlock()\n\n\trequiredSize := wt.meta.PageCount * uint64(pageSize)\n\tif requiredSize > wt.mapSize {\n\t\tnewSize := ((requiredSize + maxMapSize - 1) / maxMapSize) * maxMapSize\n\t\tif newSize > maxMapSize {\n\t\t\tnewSize = maxMapSize\n\t\t}\n\t\tif err := wt.db.expandAndRemap(wt, newSize); err != nil {\n\t\t\twt.closed = true\n\t\t\twt.db.removeTransaction(wt.id)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor pageNum, data := range wt.writeBuffer {\n\t\toffset := pageNum * uint64(pageSize)\n\t\tcopy(wt.mapData[offset:offset+uint64(pageSize)], data)\n\t}\n\n\tif err := wt.db.syncMetaPage(wt.meta); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\tif err := wt.db.syncFile(); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Rollback() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.writeBuffer = make(map[uint64][]byte)\n\twt.meta = &Meta{\n\t\tVersion:   wt.originalMeta.Version,\n\t\tPageSize:  wt.originalMeta.PageSize,\n\t\tFreeSpace: wt.originalMeta.FreeSpace,\n\t\tPageCount: wt.originalMeta.PageCount,\n\t}\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\ntype Database struct {\n\tfile             *os.File\n\tfilename         string\n\tmapData          []byte\n\tmapSize          uint64\n\tpageSize         uint32\n\tclosed           bool\n\treadTxnCount     int32\n\tactiveTransactions map[uint64]Transaction\n\ttxnMu            sync.RWMutex\n\tmapMu            sync.RWMutex\n\twriteMu          sync.Mutex\n\tnextTxnID        uint64\n\ttxnIDMu          sync.Mutex\n\tremapWaiters     int32\n\tremapWaitersCond *sync.Cond\n}\n\nfunc (db *Database) nextTransactionID() uint64 {\n\tdb.txnIDMu.Lock()\n\tdefer db.txnIDMu.Unlock()\n\tdb.nextTxnID++\n\treturn db.nextTxnID\n}\n\nfunc (db *Database) addTransaction(txn Transaction) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdb.activeTransactions[txn.ID()] = txn\n}\n\nfunc (db *Database) removeTransaction(id uint64) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdelete(db.activeTransactions, id)\n}\n\nfunc (db *Database) getActiveTransactions() map[uint64]Transaction {\n\tdb.txnMu.RLock()\n\tdefer db.txnMu.RUnlock()\n\ttxns := make(map[uint64]Transaction)\n\tfor k, v := range db.activeTransactions {\n\t\ttxns[k] = v\n\t}\n\treturn txns\n}\n\nfunc OpenDatabase(filename string) (*Database, error) {\n\tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo, err := file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tvar initialSize int64 = pageSize * 100\n\tif info.Size() == 0 {\n\t\tif err := file.Truncate(initialSize); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tinfo, err = file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tdb := &Database{\n\t\tfile:               file,\n\t\tfilename:           filename,\n\t\tpageSize:           uint32(pageSize),\n\t\tmapSize:            uint64(info.Size()),\n\t\tactiveTransactions: make(map[uint64]Transaction),\n\t\tremapWaitersCond:   sync.NewCond(&sync.Mutex{}),\n\t}\n\n\tif err := db.mapFile(); err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tif info.Size() == initialSize {\n\t\tmeta := &Meta{\n\t\t\tVersion:   1,\n\t\t\tPageSize:  uint32(pageSize),\n\t\t\tFreeSpace: 0,\n\t\t\tPageCount: uint64(dataPageStart),\n\t\t}\n\t\tif err := db.initializeMeta(meta); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn db, nil\n}\n\nfunc (db *Database) mapFile() error {\n\tdb.mapMu.Lock()\n\tdefer db.mapMu.Unlock()\n\n\tif len(db.mapData) > 0 {\n\t\treturn nil\n\t}\n\n\tdata, err := mmap(db.file, int(db.mapSize))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapData = data\n\treturn nil\n}\n\nfunc (db *Database) initializeMeta(meta *Meta) error {\n\tdb.writeMu.Lock()\n\tdefer db.writeMu.Unlock()\n\n\tmetaPage0Data := meta.Encode()\n\tmetaPage1Data := meta.Encode()\n\n\tcopy(db.mapData[0:len(metaPage0Data)], metaPage0Data)\n\tcopy(db.mapData[pageSize:pageSize+len(metaPage1Data)], metaPage1Data)\n\n\treturn db.syncFile()\n}\n\nfunc (db *Database) syncMetaPage(meta *Meta) error {\n\tmetaData := meta.Encode()\n\tcopy(db.mapData[0:len(metaData)], metaData)\n\tcopy(db.mapData[pageSize:pageSize+len(metaData)], metaData)\n\treturn nil\n}\n\nfunc (db *Database) syncFile() error {\n\tif err := db.file.Sync(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (db *Database) expandAndRemap(wt *WriteTransaction, newSize uint64) error {\n\tatomic.AddInt32(&db.remapWaiters, 1)\n\tdefer atomic.AddInt32(&db.remapWaiters, -1)\n\n\tif err := db.file.Truncate(int64(newSize)); err != nil {\n\t\treturn err\n\t}\n\n\toldMapData := db.mapData\n\toldMapSize := db.mapSize\n\n\tdb.mapMu.Lock()\n\tdb.mapSize = newSize\n\tdb.mapData = nil\n\tdb.mapMu.Unlock()\n\n\tactiveTxns := db.getActiveTransactions()\n\tfor {\n\t\tallDone := true\n\t\tfor _, txn := range activeTxns {\n\t\t\tif txn.ID() != wt.ID() {\n\t\t\t\tallDone = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif allDone {\n\t\t\tbreak\n\t\t}\n\t\tactiveTxns = db.getActiveTransactions()\n\t}\n\n\tif err := db.mapFile(); err != nil {\n\t\tdb.mapMu.Lock()\n\t\tdb.mapData = oldMapData\n\t\tdb.mapSize = oldMapSize\n\t\tdb.mapMu.Unlock()\n\t\treturn err\n\t}\n\n\twt.mu.Lock()\n\twt.mapData = db.mapData\n\twt.mapSize = db.mapSize\n\twt.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (db *Database) BeginReadTransaction() (Transaction, error) {\n\tif db.closed {\n\t\treturn nil, errFileClosed\n\t}\n\n\tdb.mapMu.RLock()\n\tmapData := db.mapData\n\tmapSize := db.mapSize\n\tdb.mapMu.RUnlock()\n\n\tmetaData := make([]byte, 24)\n\tcopy(metaData, mapData[0:24])\n\n\tmeta, err := DecodeMeta(metaData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trt := &ReadTransaction{\n\t\tid:      db.nextTransactionID(),\n\t\tdb:      db,\n\t\tmeta:    meta,\n\t\tmapData: mapData,\n\t\tmapSize: mapSize,\n\t}\n\n\tdb.addTransaction(rt)\n\treturn rt, nil\n}\n\nfunc",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:510:5: syntax error: unexpected EOF, expected name or ("
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:510:5: syntax error: unexpected EOF, expected name or (\n\n\nGolang errors in file: [/tmp/go_synthesis_4wr5_e8z/main.go]:\n\n  > [line 11 : column 2] - \"unsafe\" imported and not used\n\n  > [line 397 : column 15] - undefined: mmap\n\n  > [line 510 : column 5] - expected 'IDENT', found 'EOF'\n\n  > [line 510 : column 5] - expected ';', found 'EOF'\n\n  > [line 510 : column 5] - expected ')', found 'EOF'\n\n  > [line 510 : column 5] - expected '(', found 'EOF'\n\n\n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:334\u001b[0m] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)\n    333: func OpenDatabase(filename string) (*Database, error) {\n  > 334: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    335: \tif err != nil {\n\nAutofix: Consider using os.Root to scope file access under a fixed root (Go >=1.24). Prefer root.Open/root.Stat over os.Open/os.Stat to prevent directory traversal.\n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:334\u001b[0m] - G302 (CWE-276): Expect file permissions to be 0600 or less (Confidence: HIGH, Severity: MEDIUM)\n    333: func OpenDatabase(filename string) (*Database, error) {\n  > 334: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    335: \tif err != nil {\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:381\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    380: \t\tif err := db.initializeMeta(meta); err != nil {\n  > 381: \t\t\tfile.Close()\n    382: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:369\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    368: \tif err := db.mapFile(); err != nil {\n  > 369: \t\tfile.Close()\n    370: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:355\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    354: \tif err != nil {\n  > 355: \t\tfile.Close()\n    356: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:348\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    347: \t\tif err := file.Truncate(initialSize); err != nil {\n  > 348: \t\t\tfile.Close()\n    349: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:341\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    340: \tif err != nil {\n  > 341: \t\tfile.Close()\n    342: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:61\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n  > 61: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n    62: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:60\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n  > 60: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:59\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    58: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n  > 59: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:58\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    57: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n  > 58: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:57\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    56: \tm := &Meta{}\n  > 57: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n    58: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:47\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    46: \tchecksum := calculateChecksum(data)\n  > 47: \tbinary.Write(buf, binary.LittleEndian, checksum)\n    48: \treturn buf.Bytes()\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:44\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    43: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n  > 44: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n    45: \tdata := buf.Bytes()\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:43\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n  > 43: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n    44: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:42\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    41: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n  > 42: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n    43: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:41\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    40: \tbuf := new(bytes.Buffer)\n  > 41: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 510\n  Nosec  : 0\n  Issues : \u001b[1;31m17\u001b[0m\n\n[gosec] 2025/12/01 13:58:54 Including rules: default\n[gosec] 2025/12/01 13:58:54 Excluding rules: default\n[gosec] 2025/12/01 13:58:54 Including analyzers: default\n[gosec] 2025/12/01 13:58:54 Excluding analyzers: default\n[gosec] 2025/12/01 13:58:54 Import directory: /tmp/go_synthesis_4wr5_e8z\n[gosec] 2025/12/01 13:58:54 Checking package: main\n[gosec] 2025/12/01 13:58:54 Checking file: /tmp/go_synthesis_4wr5_e8z/main.go\n[gosec] 2025/12/01 13:58:56 Panic when running SSA analyzer on package: main. Panic: no type for *ast.CallExpr @ /tmp/go_synthesis_4wr5_e8z/main.go:397:15\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xe6fbe0?, 0xc0010210b0?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*Function).typeOf(0xc001004000, {0x11e2708, 0xc000bf4cc0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/func.go:39 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).exprN(0xc000fb61b0, 0xc001004000, {0x11e2708, 0xc000bf4cc0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:282 +0x45\ngolang.org/x/tools/go/ssa.(*builder).assignStmt(0xc000fb61b0, 0xc001004000, {0xc000bf6f40, 0x2, 0xc0010268f0?}, {0xc000bb1c60, 0x1, 0x0?}, 0x1)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1234 +0x369\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000fb61b0, 0xc001004000, {0x11e2d90?, 0xc000bf4d00?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2720 +0x5b5\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000fb61b0, 0xc001004000, {0x11e2eb0?, 0xc000bf2c60?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000fb61b0, 0xc001004000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc001004000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000fb61b0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc000e82000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc000392120?, 0xc0010a3740?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc000cbe000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc000bd31e0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc0003c6980, 0xc000bd31e0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc0003c6980, {0x0, 0x0, 0x0}, {0xc000052d30, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 13:58:56 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected '(', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected ')', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected 'IDENT', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:397:15: undefined: mmap\n/tmp/go_synthesis_4wr5_e8z/main.go:11:2: \"unsafe\" imported and not used\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:510:5: syntax error: unexpected EOF, expected name or ( /tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected '(', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected ')', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected ';', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected 'IDENT', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:397:15: undefined: mmap /tmp/go_synthesis_4wr5_e8z/main.go:11:2: \"unsafe\" imported and not used]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:510:5: syntax error: unexpected EOF, expected name or (\n/tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected '(', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected ')', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:510:5: expected 'IDENT', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:397:15: undefined: mmap\n/tmp/go_synthesis_4wr5_e8z/main.go:11:2: \"unsafe\" imported and not used\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:510:5: syntax error: unexpected EOF, expected name or ( (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"golang.org/x/exp/mmap\"\n)\n\nconst (\n\tpageSize      = 4096\n\tmetaPageSize  = 1024\n\tmaxMapSize    = 1073741824\n\tmetaPage0     = 0\n\tmetaPage1     = 1\n\tdataPageStart = 2\n)\n\nvar (\n\terrTxnInProgress = errors.New(\"transaction already in progress\")\n\terrNotTxn        = errors.New(\"not in a transaction\")\n\terrReadOnly      = errors.New(\"read-only transaction cannot write\")\n\terrFileClosed    = errors.New(\"database file is closed\")\n\terrInvalidMeta   = errors.New(\"invalid metadata\")\n)\n\ntype Meta struct {\n\tVersion   uint32\n\tPageSize  uint32\n\tFreeSpace uint64\n\tPageCount uint64\n\tChecksum  uint32\n}\n\nfunc (m *Meta) Encode() []byte {\n\tbuf := new(bytes.Buffer)\n\tbinary.Write(buf, binary.LittleEndian, m.Version)\n\tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\tdata := buf.Bytes()\n\tchecksum := calculateChecksum(data)\n\tbinary.Write(buf, binary.LittleEndian, checksum)\n\treturn buf.Bytes()\n}\n\nfunc DecodeMeta(data []byte) (*Meta, error) {\n\tif len(data) < 24 {\n\t\treturn nil, errInvalidMeta\n\t}\n\tbuf := bytes.NewReader(data[:24])\n\tm := &Meta{}\n\tbinary.Read(buf, binary.LittleEndian, &m.Version)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\n\texpectedChecksum := calculateChecksum(data[:20])\n\tif m.Checksum != expectedChecksum {\n\t\treturn nil, errInvalidMeta\n\t}\n\treturn m, nil\n}\n\nfunc calculateChecksum(data []byte) uint32 {\n\tvar checksum uint32\n\tfor _, b := range data {\n\t\tchecksum += uint32(b)\n\t}\n\treturn checksum\n}\n\ntype Transaction interface {\n\tReadPage(pageNum uint64) ([]byte, error)\n\tWritePage(pageNum uint64, data []byte) error\n\tGetMeta() *Meta\n\tCommit() error\n\tRollback() error\n\tIsReadOnly() bool\n\tID() uint64\n}\n\ntype ReadTransaction struct {\n\tid       uint64\n\tdb       *Database\n\tmeta     *Meta\n\tmapData  []byte\n\tmapSize  uint64\n\tclosed   bool\n\tmu       sync.Mutex\n}\n\nfunc (rt *ReadTransaction) ID() uint64 {\n\treturn rt.id\n}\n\nfunc (rt *ReadTransaction) IsReadOnly() bool {\n\treturn true\n}\n\nfunc (rt *ReadTransaction) GetMeta() *Meta {\n\treturn rt.meta\n}\n\nfunc (rt *ReadTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > rt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, rt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (rt *ReadTransaction) WritePage(pageNum uint64, data []byte) error {\n\treturn errReadOnly\n}\n\nfunc (rt *ReadTransaction) Commit() error {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn errNotTxn\n\t}\n\n\trt.closed = true\n\trt.db.removeTransaction(rt.id)\n\treturn nil\n}\n\nfunc (rt *ReadTransaction) Rollback() error {\n\treturn rt.Commit()\n}\n\ntype WriteTransaction struct {\n\tid           uint64\n\tdb           *Database\n\tmeta         *Meta\n\toriginalMeta *Meta\n\tmapData      []byte\n\tmapSize      uint64\n\twriteBuffer  map[uint64][]byte\n\tclosed       bool\n\tmu           sync.Mutex\n}\n\nfunc (wt *WriteTransaction) ID() uint64 {\n\treturn wt.id\n}\n\nfunc (wt *WriteTransaction) IsReadOnly() bool {\n\treturn false\n}\n\nfunc (wt *WriteTransaction) GetMeta() *Meta {\n\treturn wt.meta\n}\n\nfunc (wt *WriteTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\tif cached, ok := wt.writeBuffer[pageNum]; ok {\n\t\tpage := make([]byte, pageSize)\n\t\tcopy(page, cached)\n\t\treturn page, nil\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > wt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, wt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (wt *WriteTransaction) WritePage(pageNum uint64, data []byte) error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\tif len(data) > pageSize {\n\t\treturn fmt.Errorf(\"data exceeds page size\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, data)\n\twt.writeBuffer[pageNum] = page\n\n\tif pageNum >= wt.meta.PageCount {\n\t\twt.meta.PageCount = pageNum + 1\n\t}\n\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Commit() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.db.writeMu.Lock()\n\tdefer wt.db.writeMu.Unlock()\n\n\trequiredSize := wt.meta.PageCount * uint64(pageSize)\n\tif requiredSize > wt.mapSize {\n\t\tnewSize := ((requiredSize + maxMapSize - 1) / maxMapSize) * maxMapSize\n\t\tif newSize > maxMapSize {\n\t\t\tnewSize = maxMapSize\n\t\t}\n\t\tif err := wt.db.expandAndRemap(wt, newSize); err != nil {\n\t\t\twt.closed = true\n\t\t\twt.db.removeTransaction(wt.id)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor pageNum, data := range wt.writeBuffer {\n\t\toffset := pageNum * uint64(pageSize)\n\t\tcopy(wt.mapData[offset:offset+uint64(pageSize)], data)\n\t}\n\n\tif err := wt.db.syncMetaPage(wt.meta); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\tif err := wt.db.syncFile(); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Rollback() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.writeBuffer = make(map[uint64][]byte)\n\twt.meta = &Meta{\n\t\tVersion:   wt.originalMeta.Version,\n\t\tPageSize:  wt.originalMeta.PageSize,\n\t\tFreeSpace: wt.originalMeta.FreeSpace,\n\t\tPageCount: wt.originalMeta.PageCount,\n\t}\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\ntype Database struct {\n\tfile               *os.File\n\tfilename           string\n\tmapData            []byte\n\tmapSize            uint64\n\tpageSize           uint32\n\tclosed             bool\n\tactiveTransactions map[uint64]Transaction\n\ttxnMu              sync.RWMutex\n\tmapMu              sync.RWMutex\n\twriteMu            sync.Mutex\n\tnextTxnID          uint64\n\ttxnIDMu            sync.Mutex\n\tremapWaiters       int32\n\tremapWaitersCond   *sync.Cond\n}\n\nfunc (db *Database) nextTransactionID() uint64 {\n\tdb.txnIDMu.Lock()\n\tdefer db.txnIDMu.Unlock()\n\tdb.nextTxnID++\n\treturn db.nextTxnID\n}\n\nfunc (db *Database) addTransaction(txn Transaction) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdb.activeTransactions[txn.ID()] = txn\n}\n\nfunc (db *Database) removeTransaction(id uint64) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdelete(db.activeTransactions, id)\n}\n\nfunc (db *Database) getActiveTransactions() map[uint64]Transaction {\n\tdb.txnMu.RLock()\n\tdefer db.txnMu.RUnlock()\n\ttxns := make(map[uint64]Transaction)\n\tfor k, v := range db.activeTransactions {\n\t\ttxns[k] = v\n\t}\n\treturn txns\n}\n\nfunc OpenDatabase(filename string) (*Database, error) {\n\tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo, err := file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tvar initialSize int64 = pageSize * 100\n\tif info.Size() == 0 {\n\t\tif err := file.Truncate(initialSize); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tinfo, err = file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tdb := &Database{\n\t\tfile:               file,\n\t\tfilename:           filename,\n\t\tpageSize:           uint32(pageSize),\n\t\tmapSize:            uint64(info.Size()),\n\t\tactiveTransactions: make(map[uint64]Transaction),\n\t\tremapWaitersCond:   sync.NewCond(&sync.Mutex{}),\n\t}\n\n\tif err := db.mapFile(); err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tif info.Size() == initialSize {\n\t\tmeta := &Meta{\n\t\t\tVersion:   1,\n\t\t\tPageSize:  uint32(pageSize),\n\t\t\tFreeSpace: 0,\n\t\t\tPageCount: uint64(dataPageStart),\n\t\t}\n\t\tif err := db.initializeMeta(meta); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn db, nil\n}\n\nfunc (db *Database) mapFile() error {\n\tdb.mapMu.Lock()\n\tdefer db.mapMu.Unlock()\n\n\tif len(db.mapData) > 0 {\n\t\treturn nil\n\t}\n\n\tdata, err := mmap.Open(db.file)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapData = data\n\treturn nil\n}\n\nfunc (db *Database) unmapFile() error {\n\tif len(db.mapData) == 0 {\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (db *Database) initializeMeta(meta *Meta) error {\n\tdb.writeMu.Lock()\n\tdefer db.writeMu.Unlock()\n\n\tmetaPage0Data := meta.Encode()\n\tmetaPage1Data := meta.Encode()\n\n\tcopy(db.mapData[0:len(metaPage0Data)], metaPage0Data)\n\tcopy(db.mapData[pageSize:pageSize+len(metaPage1Data)], metaPage1Data)\n\n\treturn db.syncFile()\n}\n\nfunc (db *Database) syncMetaPage(meta *Meta) error {\n\tmetaData := meta.Encode()\n\tcopy(db.mapData[0:len(metaData)], metaData)\n\tcopy(db.mapData[pageSize:pageSize+len(metaData)], metaData)\n\treturn nil\n}\n\nfunc (db *Database) syncFile() error {\n\tif err := db.file.Sync(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (db *Database) expandAndRemap(wt *WriteTransaction, newSize uint64) error {\n\tatomic.AddInt32(&db.remapWaiters, 1)\n\tdefer atomic.AddInt32(&db.remapWaiters, -1)\n\n\tif err := db.file.Truncate(int64(newSize)); err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapMu.Lock()\n\toldMapData := db.mapData\n\tdb.mapData = nil\n\tdb.mapSize = newSize\n\tdb.mapMu.Unlock()\n\n\tactiveTxns := db.getActiveTransactions()\n\tfor len(activeTxns) > 1 || (len(activeTxns) == 1 && activeTxns[0] == nil) {\n\t\tactiveTxns = db.getActiveTransactions()\n\t}\n\n\tif err := db.mapFile(); err != nil {\n\t\tdb.mapMu.Lock()\n\t\tdb.mapData = oldMapData\n\t\tdb.mapMu.Unlock()\n\t\treturn err\n\t}\n\n\twt.mu.Lock()\n\twt.mapData = db.mapData\n\twt.mapSize = db.mapSize\n\twt.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (db *Database) BeginReadTransaction() (Transaction, error) {\n\tif db.closed {\n\t\treturn nil, errFileClosed\n\t}\n\n\tdb.mapMu.RLock()\n\tmapData := db.mapData\n\tmapSize := db.mapSize\n\tdb.mapMu.RUnlock()\n\n\tmetaData := make([]byte, 24)\n\tcopy(metaData, mapData[0:24])\n\n\tmeta, err := DecodeMeta(metaData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trt := &ReadTransaction{\n\t\tid:      db.nextTransactionID(),\n\t\tdb:      db,\n\t\tmeta:    meta,\n\t\tmapData: mapData,\n\t\tmapSize: mapSize,\n\t}\n\n\tdb.addTransaction(rt)\n\treturn rt, nil\n}\n\nfunc (db *Database) BeginWriteTransaction() (Transaction, error) {",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:504:67: syntax error: unexpected EOF, expected }"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:504:67: syntax error: unexpected EOF, expected }\n\n\nGolang errors in file: [-]:\n\n  > [line 0 : column 0] - missing return\n\n\nGolang errors in file: [/tmp/go_synthesis_4wr5_e8z/main.go]:\n\n  > [line 397 : column 25] - cannot use db.file (variable of type *os.File) as string value in argument to mmap.Open\n\n  > [line 402 : column 15] - cannot use data (variable of type *mmap.ReaderAt) as []byte value in assignment\n\n  > [line 504 : column 67] - expected '}', found 'EOF'\n\n  > [line 504 : column 67] - expected ';', found 'EOF'\n\n\n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:334\u001b[0m] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)\n    333: func OpenDatabase(filename string) (*Database, error) {\n  > 334: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    335: \tif err != nil {\n\nAutofix: Consider using os.Root to scope file access under a fixed root (Go >=1.24). Prefer root.Open/root.Stat over os.Open/os.Stat to prevent directory traversal.\n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:334\u001b[0m] - G302 (CWE-276): Expect file permissions to be 0600 or less (Confidence: HIGH, Severity: MEDIUM)\n    333: func OpenDatabase(filename string) (*Database, error) {\n  > 334: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    335: \tif err != nil {\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:381\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    380: \t\tif err := db.initializeMeta(meta); err != nil {\n  > 381: \t\t\tfile.Close()\n    382: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:369\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    368: \tif err := db.mapFile(); err != nil {\n  > 369: \t\tfile.Close()\n    370: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:355\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    354: \tif err != nil {\n  > 355: \t\tfile.Close()\n    356: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:348\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    347: \t\tif err := file.Truncate(initialSize); err != nil {\n  > 348: \t\t\tfile.Close()\n    349: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:341\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    340: \tif err != nil {\n  > 341: \t\tfile.Close()\n    342: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:62\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n  > 62: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n    63: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:61\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n  > 61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n    62: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:60\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n  > 60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:59\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    58: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n  > 59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:58\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    57: \tm := &Meta{}\n  > 58: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:48\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    47: \tchecksum := calculateChecksum(data)\n  > 48: \tbinary.Write(buf, binary.LittleEndian, checksum)\n    49: \treturn buf.Bytes()\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:45\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    44: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n  > 45: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n    46: \tdata := buf.Bytes()\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:44\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    43: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n  > 44: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n    45: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:43\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n  > 43: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n    44: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:42\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    41: \tbuf := new(bytes.Buffer)\n  > 42: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n    43: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 504\n  Nosec  : 0\n  Issues : \u001b[1;31m17\u001b[0m\n\n[gosec] 2025/12/01 13:59:18 Including rules: default\n[gosec] 2025/12/01 13:59:18 Excluding rules: default\n[gosec] 2025/12/01 13:59:18 Including analyzers: default\n[gosec] 2025/12/01 13:59:18 Excluding analyzers: default\n[gosec] 2025/12/01 13:59:18 Import directory: /tmp/go_synthesis_4wr5_e8z\n[gosec] 2025/12/01 13:59:18 Checking package: main\n[gosec] 2025/12/01 13:59:18 Checking file: /tmp/go_synthesis_4wr5_e8z/main.go\n[gosec] 2025/12/01 13:59:20 Panic when running SSA analyzer on package: main. Panic: in (*command-line-arguments.Database).mapFile: cannot convert term *t0 (*golang.org/x/exp/mmap.ReaderAt [within *golang.org/x/exp/mmap.ReaderAt]) to type []byte [within []byte]\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xe6fbe0?, 0xc00108bc00?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.emitConv.func1({0x11de848, 0xc000a5e7a0}, {0x11df508, 0xc000f81220})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/emit.go:311 +0x359\ngolang.org/x/tools/go/ssa.emitConv.func2.1({0x11df508?, 0xc000f81220?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/emit.go:320 +0x4c\ngolang.org/x/tools/go/ssa.underIs.func1({0x7f7d44347d80?, 0x7f7d8c2a75c0?}, {0x11df508?, 0xc000f81220?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/typeset.go:100 +0x34\ngolang.org/x/tools/go/ssa.typeset({0x11df508?, 0xc000f81220?}, 0xc000d2acb8)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/typeset.go:45 +0x103\ngolang.org/x/tools/go/ssa.underIs({0x11df508?, 0xc000f81220?}, 0x20?)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/typeset.go:99 +0x45\ngolang.org/x/tools/go/ssa.emitConv.func2({0x11de848?, 0xc000a5e7a0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/emit.go:318 +0x58\ngolang.org/x/tools/go/ssa.underIs.func1({0xc000d2ae01?, 0x11ec4d8?}, {0x11de848?, 0xc000a5e7a0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/typeset.go:100 +0x34\ngolang.org/x/tools/go/ssa.typeset({0x11de848?, 0xc000a5e7a0?}, 0xc000d2add8)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/typeset.go:45 +0x103\ngolang.org/x/tools/go/ssa.underIs({0x11de848?, 0xc000a5e7a0?}, 0xc000a5e7a0?)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/typeset.go:99 +0x45\ngolang.org/x/tools/go/ssa.emitConv(0xc00105aa00, {0x11ec4d8, 0xc00109cde0}, {0x11df508, 0xc000f81220})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/emit.go:317 +0x65a\ngolang.org/x/tools/go/ssa.emitStore(0xc00105aa00, {0x11ec5b0, 0xc00109ce40}, {0x11ec4d8, 0xc00109cde0}, 0x6e2035)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/emit.go:418 +0x58\ngolang.org/x/tools/go/ssa.(*lazyAddress).store(0xc001095ec0, 0xc00105aa00, {0x11ec4d8, 0xc00109cde0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/lvalue.go:117 +0x50\ngolang.org/x/tools/go/ssa.(*storebuf).emit(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:551\ngolang.org/x/tools/go/ssa.(*builder).assignStmt(0xc000f70a20, 0xc00105aa00, {0xc0001edae0, 0x1, 0xc001098bb0?}, {0xc0001edaf0, 0x1, 0x0?}, 0x0)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1231 +0x50f\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000f70a20, 0xc00105aa00, {0x11e2d90?, 0xc0005b9300?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2720 +0x5b5\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000f70a20, 0xc00105aa00, {0x11e2eb0?, 0xc000fd3e90?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000f70a20, 0xc00105aa00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc00105aa00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000f70a20)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc00005d700)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc000f7a000?, 0xc00054ae40?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc0002d4000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc000c07ba0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc0004f4980, 0xc000c07ba0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc0004f4980, {0x0, 0x0, 0x0}, {0xc00012d4d0, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 13:59:20 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_4wr5_e8z/main.go:504:67: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:504:67: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:397:25: cannot use db.file (variable of type *os.File) as string value in argument to mmap.Open\n/tmp/go_synthesis_4wr5_e8z/main.go:402:15: cannot use data (variable of type *mmap.ReaderAt) as []byte value in assignment\n-: missing return\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:504:67: syntax error: unexpected EOF, expected } /tmp/go_synthesis_4wr5_e8z/main.go:504:67: expected ';', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:504:67: expected '}', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:397:25: cannot use db.file (variable of type *os.File) as string value in argument to mmap.Open /tmp/go_synthesis_4wr5_e8z/main.go:402:15: cannot use data (variable of type *mmap.ReaderAt) as []byte value in assignment -: missing return]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:504:67: syntax error: unexpected EOF, expected }\n/tmp/go_synthesis_4wr5_e8z/main.go:504:67: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:504:67: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:397:25: cannot use db.file (variable of type *os.File) as string value in argument to mmap.Open\n/tmp/go_synthesis_4wr5_e8z/main.go:402:15: cannot use data (variable of type *mmap.ReaderAt) as []byte value in assignment\n-: missing return\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:504:67: syntax error: unexpected EOF, expected } (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\nconst (\n\tpageSize      = 4096\n\tmetaPageSize  = 1024\n\tmaxMapSize    = 1073741824\n\tmetaPage0     = 0\n\tmetaPage1     = 1\n\tdataPageStart = 2\n)\n\nvar (\n\terrTxnInProgress = errors.New(\"transaction already in progress\")\n\terrNotTxn        = errors.New(\"not in a transaction\")\n\terrReadOnly      = errors.New(\"read-only transaction cannot write\")\n\terrFileClosed    = errors.New(\"database file is closed\")\n\terrInvalidMeta   = errors.New(\"invalid metadata\")\n)\n\ntype Meta struct {\n\tVersion   uint32\n\tPageSize  uint32\n\tFreeSpace uint64\n\tPageCount uint64\n\tChecksum  uint32\n}\n\nfunc (m *Meta) Encode() []byte {\n\tbuf := new(bytes.Buffer)\n\tbinary.Write(buf, binary.LittleEndian, m.Version)\n\tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\tdata := buf.Bytes()\n\tchecksum := calculateChecksum(data)\n\tbuf.Write(make([]byte, 4))\n\tfullData := buf.Bytes()\n\tbinary.LittleEndian.PutUint32(fullData[20:24], checksum)\n\treturn fullData[:24]\n}\n\nfunc DecodeMeta(data []byte) (*Meta, error) {\n\tif len(data) < 24 {\n\t\treturn nil, errInvalidMeta\n\t}\n\tbuf := bytes.NewReader(data[:24])\n\tm := &Meta{}\n\tbinary.Read(buf, binary.LittleEndian, &m.Version)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\n\texpectedChecksum := calculateChecksum(data[:20])\n\tif m.Checksum != expectedChecksum {\n\t\treturn nil, errInvalidMeta\n\t}\n\treturn m, nil\n}\n\nfunc calculateChecksum(data []byte) uint32 {\n\tvar checksum uint32\n\tfor _, b := range data {\n\t\tchecksum += uint32(b)\n\t}\n\treturn checksum\n}\n\ntype Transaction interface {\n\tReadPage(pageNum uint64) ([]byte, error)\n\tWritePage(pageNum uint64, data []byte) error\n\tGetMeta() *Meta\n\tCommit() error\n\tRollback() error\n\tIsReadOnly() bool\n\tID() uint64\n}\n\ntype ReadTransaction struct {\n\tid       uint64\n\tdb       *Database\n\tmeta     *Meta\n\tmapData  []byte\n\tmapSize  uint64\n\tclosed   bool\n\tmu       sync.Mutex\n}\n\nfunc (rt *ReadTransaction) ID() uint64 {\n\treturn rt.id\n}\n\nfunc (rt *ReadTransaction) IsReadOnly() bool {\n\treturn true\n}\n\nfunc (rt *ReadTransaction) GetMeta() *Meta {\n\treturn rt.meta\n}\n\nfunc (rt *ReadTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > rt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, rt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (rt *ReadTransaction) WritePage(pageNum uint64, data []byte) error {\n\treturn errReadOnly\n}\n\nfunc (rt *ReadTransaction) Commit() error {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn errNotTxn\n\t}\n\n\trt.closed = true\n\trt.db.removeTransaction(rt.id)\n\treturn nil\n}\n\nfunc (rt *ReadTransaction) Rollback() error {\n\treturn rt.Commit()\n}\n\ntype WriteTransaction struct {\n\tid           uint64\n\tdb           *Database\n\tmeta         *Meta\n\toriginalMeta *Meta\n\tmapData      []byte\n\tmapSize      uint64\n\twriteBuffer  map[uint64][]byte\n\tclosed       bool\n\tmu           sync.Mutex\n}\n\nfunc (wt *WriteTransaction) ID() uint64 {\n\treturn wt.id\n}\n\nfunc (wt *WriteTransaction) IsReadOnly() bool {\n\treturn false\n}\n\nfunc (wt *WriteTransaction) GetMeta() *Meta {\n\treturn wt.meta\n}\n\nfunc (wt *WriteTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\tif cached, ok := wt.writeBuffer[pageNum]; ok {\n\t\tpage := make([]byte, pageSize)\n\t\tcopy(page, cached)\n\t\treturn page, nil\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > wt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, wt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (wt *WriteTransaction) WritePage(pageNum uint64, data []byte) error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\tif len(data) > pageSize {\n\t\treturn fmt.Errorf(\"data exceeds page size\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, data)\n\twt.writeBuffer[pageNum] = page\n\n\tif pageNum >= wt.meta.PageCount {\n\t\twt.meta.PageCount = pageNum + 1\n\t}\n\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Commit() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.db.writeMu.Lock()\n\tdefer wt.db.writeMu.Unlock()\n\n\trequiredSize := wt.meta.PageCount * uint64(pageSize)\n\tif requiredSize > wt.mapSize {\n\t\tnewSize := ((requiredSize + maxMapSize - 1) / maxMapSize) * maxMapSize\n\t\tif newSize > maxMapSize {\n\t\t\tnewSize = maxMapSize\n\t\t}\n\t\tif err := wt.db.expandAndRemap(wt, newSize); err != nil {\n\t\t\twt.closed = true\n\t\t\twt.db.removeTransaction(wt.id)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor pageNum, data := range wt.writeBuffer {\n\t\toffset := pageNum * uint64(pageSize)\n\t\tcopy(wt.mapData[offset:offset+uint64(pageSize)], data)\n\t}\n\n\tif err := wt.db.syncMetaPage(wt.meta); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\tif err := wt.db.syncFile(); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Rollback() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.writeBuffer = make(map[uint64][]byte)\n\twt.meta = &Meta{\n\t\tVersion:   wt.originalMeta.Version,\n\t\tPageSize:  wt.originalMeta.PageSize,\n\t\tFreeSpace: wt.originalMeta.FreeSpace,\n\t\tPageCount: wt.originalMeta.PageCount,\n\t}\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\ntype Database struct {\n\tfile               *os.File\n\tfilename           string\n\tmapData            []byte\n\tmapSize            uint64\n\tpageSize           uint32\n\tclosed             bool\n\tactiveTransactions map[uint64]Transaction\n\ttxnMu              sync.RWMutex\n\tmapMu              sync.RWMutex\n\twriteMu            sync.Mutex\n\tnextTxnID          uint64\n\ttxnIDMu            sync.Mutex\n\tremapWaiters       int32\n\tremapWaitersCond   *sync.Cond\n}\n\nfunc (db *Database) nextTransactionID() uint64 {\n\tdb.txnIDMu.Lock()\n\tdefer db.txnIDMu.Unlock()\n\tdb.nextTxnID++\n\treturn db.nextTxnID\n}\n\nfunc (db *Database) addTransaction(txn Transaction) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdb.activeTransactions[txn.ID()] = txn\n}\n\nfunc (db *Database) removeTransaction(id uint64) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdelete(db.activeTransactions, id)\n\tdb.remapWaitersCond.Broadcast()\n}\n\nfunc (db *Database) getActiveTransactions() map[uint64]Transaction {\n\tdb.txnMu.RLock()\n\tdefer db.txnMu.RUnlock()\n\ttxns := make(map[uint64]Transaction)\n\tfor k, v := range db.activeTransactions {\n\t\ttxns[k] = v\n\t}\n\treturn txns\n}\n\nfunc OpenDatabase(filename string) (*Database, error) {\n\tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo, err := file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tvar initialSize int64 = pageSize * 100\n\tif info.Size() == 0 {\n\t\tif err := file.Truncate(initialSize); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tinfo, err = file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tdb := &Database{\n\t\tfile:               file,\n\t\tfilename:           filename,\n\t\tpageSize:           uint32(pageSize),\n\t\tmapSize:            uint64(info.Size()),\n\t\tactiveTransactions: make(map[uint64]Transaction),\n\t\tremapWaitersCond:   sync.NewCond(&sync.Mutex{}),\n\t}\n\n\tif err := db.mapFile(); err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tif info.Size() == initialSize {\n\t\tmeta := &Meta{\n\t\t\tVersion:   1,\n\t\t\tPageSize:  uint32(pageSize),\n\t\t\tFreeSpace: 0,\n\t\t\tPageCount: uint64(dataPageStart),\n\t\t}\n\t\tif err := db.initializeMeta(meta); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn db, nil\n}\n\nfunc (db *Database) mapFile() error {\n\tdb.mapMu.Lock()\n\tdefer db.mapMu.Unlock()\n\n\tif len(db.mapData) > 0 {\n\t\treturn nil\n\t}\n\n\tdata, err := os.ReadFile(db.filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapData = data\n\tdb.mapSize = uint64(len(data))\n\treturn nil\n}\n\nfunc (db *Database) unmapFile() error {\n\tif len(db.mapData) == 0 {\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (db *Database) initializeMeta(meta *Meta) error {\n\tdb.writeMu.Lock()\n\tdefer db.writeMu.Unlock()\n\n\tmetaData := meta.Encode()\n\tcopy(db.mapData[0:len(metaData)], metaData)\n\tcopy(db.mapData[pageSize:pageSize+len(metaData)], metaData)\n\n\treturn db.syncFile()\n}\n\nfunc (db *Database) syncMetaPage(meta *Meta) error {\n\tmetaData := meta.Encode()\n\tcopy(db.mapData[0:len(metaData)], metaData)\n\tcopy(db.mapData[pageSize:pageSize+len(metaData)], metaData)\n\treturn nil\n}\n\nfunc (db *Database) syncFile() error {\n\tif err := db.file.Sync(); err != nil {\n\t\treturn err\n\t}\n\treturn os.WriteFile(db.filename, db.mapData, 0644)\n}\n\nfunc (db *Database) expandAndRemap(wt *WriteTransaction, newSize uint64) error {\n\tatomic.AddInt32(&db.remapWaiters, 1)\n\tdefer atomic.AddInt32(&db.remapWaiters, -1)\n\n\tif err := db.file.Truncate(int64(newSize)); err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapMu.Lock()\n\tdb.mapData = make([]byte, newSize)\n\tdb.mapSize = newSize\n\tdb.mapMu.Unlock()\n\n\tdb.remapWaitersCond.L.Lock()\n\tfor {\n\t\tactiveTxns := db.getActiveTransactions()\n\t\tif len(activeTxns) <= 1 {\n\t\t\tbreak\n\t\t}\n\t\tdb.remapWaitersCond.Wait()\n\t}\n\tdb.remapWaitersCond.L.Unlock()\n\n\tif err := db.mapFile(); err != nil {\n\t\treturn err\n\t}\n\n\twt.mu.Lock()\n\tdb.mapMu.RLock()\n\twt.mapData = db.mapData\n\twt.mapSize = db.mapSize\n\tdb.mapMu.RUnlock()\n\twt.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (db *Database) BeginReadTransaction() (Transaction, error) {\n\tif db.closed {\n\t\treturn nil, errFileClosed\n\t}\n\n\tdb.mapMu.RLock()\n\tmapData := make([]byte, len(db.mapData))\n\tcopy(mapData, db.mapData)\n\tmapSize := db.mapSize\n\tdb.mapMu.RUnlock()\n\n\tmetaData := make([]byte, 24)\n\tcopy(metaData, mapData[0:24])\n\n\tmeta, err := DecodeMeta(metaData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trt := &ReadTransaction{\n\t\tid:      db.nextTransactionID(),",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected }"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected }\n\n\nGolang errors in file: [-]:\n\n  > [line 0 : column 0] - missing return\n\n\nGolang errors in file: [/tmp/go_synthesis_4wr5_e8z/main.go]:\n\n  > [line 485 : column 2] - declared and not used: mapSize\n\n  > [line 491 : column 2] - declared and not used: meta\n\n  > [line 496 : column 2] - declared and not used: rt\n\n  > [line 497 : column 35] - expected '}', found 'EOF'\n\n  > [line 497 : column 35] - expected '}', found 'EOF'\n\n  > [line 497 : column 35] - expected ';', found 'EOF'\n\n  > [line 497 : column 35] - expected ';', found 'EOF'\n\n\n\n[\u001b[97;41m/tmp/go_synthesis_4wr5_e8z/main.go:444\u001b[0m] - G115 (CWE-190): integer overflow conversion uint64 -> int64 (Confidence: MEDIUM, Severity: HIGH)\n    443: \n  > 444: \tif err := db.file.Truncate(int64(newSize)); err != nil {\n    445: \t\treturn err\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_4wr5_e8z/main.go:364\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    363: \t\tpageSize:           uint32(pageSize),\n  > 364: \t\tmapSize:            uint64(info.Size()),\n    365: \t\tactiveTransactions: make(map[uint64]Transaction),\n\nAutofix: \n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:335\u001b[0m] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)\n    334: func OpenDatabase(filename string) (*Database, error) {\n  > 335: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    336: \tif err != nil {\n\nAutofix: Consider using os.Root to scope file access under a fixed root (Go >=1.24). Prefer root.Open/root.Stat over os.Open/os.Stat to prevent directory traversal.\n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:335\u001b[0m] - G302 (CWE-276): Expect file permissions to be 0600 or less (Confidence: HIGH, Severity: MEDIUM)\n    334: func OpenDatabase(filename string) (*Database, error) {\n  > 335: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    336: \tif err != nil {\n\nAutofix: \n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:437\u001b[0m] - G306 (CWE-276): Expect WriteFile permissions to be 0600 or less (Confidence: HIGH, Severity: MEDIUM)\n    436: \t}\n  > 437: \treturn os.WriteFile(db.filename, db.mapData, 0644)\n    438: }\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:382\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    381: \t\tif err := db.initializeMeta(meta); err != nil {\n  > 382: \t\t\tfile.Close()\n    383: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:370\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    369: \tif err := db.mapFile(); err != nil {\n  > 370: \t\tfile.Close()\n    371: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:356\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    355: \tif err != nil {\n  > 356: \t\tfile.Close()\n    357: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:349\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    348: \t\tif err := file.Truncate(initialSize); err != nil {\n  > 349: \t\t\tfile.Close()\n    350: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:342\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    341: \tif err != nil {\n  > 342: \t\tfile.Close()\n    343: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:62\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n  > 62: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n    63: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:61\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n  > 61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n    62: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:60\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n  > 60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:59\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    58: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n  > 59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:58\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    57: \tm := &Meta{}\n  > 58: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:43\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n  > 43: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n    44: \tdata := buf.Bytes()\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:42\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n  > 42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n    43: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:41\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    40: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n  > 41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:40\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    39: \tbuf := new(bytes.Buffer)\n  > 40: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n    41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 497\n  Nosec  : 0\n  Issues : \u001b[1;31m19\u001b[0m\n\n[gosec] 2025/12/01 13:59:41 Including rules: default\n[gosec] 2025/12/01 13:59:41 Excluding rules: default\n[gosec] 2025/12/01 13:59:41 Including analyzers: default\n[gosec] 2025/12/01 13:59:41 Excluding analyzers: default\n[gosec] 2025/12/01 13:59:41 Import directory: /tmp/go_synthesis_4wr5_e8z\n[gosec] 2025/12/01 13:59:41 Checking package: main\n[gosec] 2025/12/01 13:59:41 Checking file: /tmp/go_synthesis_4wr5_e8z/main.go"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF'\n-: missing return\n/tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize\n/tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta\n/tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected } /tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF' -: missing return /tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize /tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta /tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected }\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF'\n-: missing return\n/tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize\n/tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta\n/tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected } (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\nconst (\n\tpageSize      = 4096\n\tmetaPageSize  = 1024\n\tmaxMapSize    = 1073741824\n\tmetaPage0     = 0\n\tmetaPage1     = 1\n\tdataPageStart = 2\n)\n\nvar (\n\terrTxnInProgress = errors.New(\"transaction already in progress\")\n\terrNotTxn        = errors.New(\"not in a transaction\")\n\terrReadOnly      = errors.New(\"read-only transaction cannot write\")\n\terrFileClosed    = errors.New(\"database file is closed\")\n\terrInvalidMeta   = errors.New(\"invalid metadata\")\n)\n\ntype Meta struct {\n\tVersion   uint32\n\tPageSize  uint32\n\tFreeSpace uint64\n\tPageCount uint64\n\tChecksum  uint32\n}\n\nfunc (m *Meta) Encode() []byte {\n\tbuf := new(bytes.Buffer)\n\tbinary.Write(buf, binary.LittleEndian, m.Version)\n\tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\tdata := buf.Bytes()\n\tchecksum := calculateChecksum(data)\n\tbuf.Write(make([]byte, 4))\n\tfullData := buf.Bytes()\n\tbinary.LittleEndian.PutUint32(fullData[20:24], checksum)\n\treturn fullData[:24]\n}\n\nfunc DecodeMeta(data []byte) (*Meta, error) {\n\tif len(data) < 24 {\n\t\treturn nil, errInvalidMeta\n\t}\n\tbuf := bytes.NewReader(data[:24])\n\tm := &Meta{}\n\tbinary.Read(buf, binary.LittleEndian, &m.Version)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\n\texpectedChecksum := calculateChecksum(data[:20])\n\tif m.Checksum != expectedChecksum {\n\t\treturn nil, errInvalidMeta\n\t}\n\treturn m, nil\n}\n\nfunc calculateChecksum(data []byte) uint32 {\n\tvar checksum uint32\n\tfor _, b := range data {\n\t\tchecksum += uint32(b)\n\t}\n\treturn checksum\n}\n\ntype Transaction interface {\n\tReadPage(pageNum uint64) ([]byte, error)\n\tWritePage(pageNum uint64, data []byte) error\n\tGetMeta() *Meta\n\tCommit() error\n\tRollback() error\n\tIsReadOnly() bool\n\tID() uint64\n}\n\ntype ReadTransaction struct {\n\tid       uint64\n\tdb       *Database\n\tmeta     *Meta\n\tmapData  []byte\n\tmapSize  uint64\n\tclosed   bool\n\tmu       sync.Mutex\n}\n\nfunc (rt *ReadTransaction) ID() uint64 {\n\treturn rt.id\n}\n\nfunc (rt *ReadTransaction) IsReadOnly() bool {\n\treturn true\n}\n\nfunc (rt *ReadTransaction) GetMeta() *Meta {\n\treturn rt.meta\n}\n\nfunc (rt *ReadTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > rt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, rt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (rt *ReadTransaction) WritePage(pageNum uint64, data []byte) error {\n\treturn errReadOnly\n}\n\nfunc (rt *ReadTransaction) Commit() error {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn errNotTxn\n\t}\n\n\trt.closed = true\n\trt.db.removeTransaction(rt.id)\n\treturn nil\n}\n\nfunc (rt *ReadTransaction) Rollback() error {\n\treturn rt.Commit()\n}\n\ntype WriteTransaction struct {\n\tid           uint64\n\tdb           *Database\n\tmeta         *Meta\n\toriginalMeta *Meta\n\tmapData      []byte\n\tmapSize      uint64\n\twriteBuffer  map[uint64][]byte\n\tclosed       bool\n\tmu           sync.Mutex\n}\n\nfunc (wt *WriteTransaction) ID() uint64 {\n\treturn wt.id\n}\n\nfunc (wt *WriteTransaction) IsReadOnly() bool {\n\treturn false\n}\n\nfunc (wt *WriteTransaction) GetMeta() *Meta {\n\treturn wt.meta\n}\n\nfunc (wt *WriteTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\tif cached, ok := wt.writeBuffer[pageNum]; ok {\n\t\tpage := make([]byte, pageSize)\n\t\tcopy(page, cached)\n\t\treturn page, nil\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > wt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, wt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (wt *WriteTransaction) WritePage(pageNum uint64, data []byte) error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\tif len(data) > pageSize {\n\t\treturn fmt.Errorf(\"data exceeds page size\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, data)\n\twt.writeBuffer[pageNum] = page\n\n\tif pageNum >= wt.meta.PageCount {\n\t\twt.meta.PageCount = pageNum + 1\n\t}\n\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Commit() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.db.writeMu.Lock()\n\tdefer wt.db.writeMu.Unlock()\n\n\trequiredSize := wt.meta.PageCount * uint64(pageSize)\n\tif requiredSize > wt.mapSize {\n\t\tnewSize := ((requiredSize + maxMapSize - 1) / maxMapSize) * maxMapSize\n\t\tif newSize > maxMapSize {\n\t\t\tnewSize = maxMapSize\n\t\t}\n\t\tif err := wt.db.expandAndRemap(wt, newSize); err != nil {\n\t\t\twt.closed = true\n\t\t\twt.db.removeTransaction(wt.id)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor pageNum, data := range wt.writeBuffer {\n\t\toffset := pageNum * uint64(pageSize)\n\t\tcopy(wt.mapData[offset:offset+uint64(pageSize)], data)\n\t}\n\n\tif err := wt.db.syncMetaPage(wt.meta); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\tif err := wt.db.syncFile(); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Rollback() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.writeBuffer = make(map[uint64][]byte)\n\twt.meta = &Meta{\n\t\tVersion:   wt.originalMeta.Version,\n\t\tPageSize:  wt.originalMeta.PageSize,\n\t\tFreeSpace: wt.originalMeta.FreeSpace,\n\t\tPageCount: wt.originalMeta.PageCount,\n\t}\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\ntype Database struct {\n\tfile               *os.File\n\tfilename           string\n\tmapData            []byte\n\tmapSize            uint64\n\tpageSize           uint32\n\tclosed             bool\n\tactiveTransactions map[uint64]Transaction\n\ttxnMu              sync.RWMutex\n\tmapMu              sync.RWMutex\n\twriteMu            sync.Mutex\n\tnextTxnID          uint64\n\ttxnIDMu            sync.Mutex\n\tremapWaiters       int32\n\tremapWaitersCond   *sync.Cond\n}\n\nfunc (db *Database) nextTransactionID() uint64 {\n\tdb.txnIDMu.Lock()\n\tdefer db.txnIDMu.Unlock()\n\tdb.nextTxnID++\n\treturn db.nextTxnID\n}\n\nfunc (db *Database) addTransaction(txn Transaction) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdb.activeTransactions[txn.ID()] = txn\n}\n\nfunc (db *Database) removeTransaction(id uint64) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdelete(db.activeTransactions, id)\n\tdb.remapWaitersCond.Broadcast()\n}\n\nfunc (db *Database) getActiveTransactions() map[uint64]Transaction {\n\tdb.txnMu.RLock()\n\tdefer db.txnMu.RUnlock()\n\ttxns := make(map[uint64]Transaction)\n\tfor k, v := range db.activeTransactions {\n\t\ttxns[k] = v\n\t}\n\treturn txns\n}\n\nfunc OpenDatabase(filename string) (*Database, error) {\n\tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo, err := file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tvar initialSize int64 = pageSize * 100\n\tif info.Size() == 0 {\n\t\tif err := file.Truncate(initialSize); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tinfo, err = file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tdb := &Database{\n\t\tfile:               file,\n\t\tfilename:           filename,\n\t\tpageSize:           uint32(pageSize),\n\t\tmapSize:            uint64(info.Size()),\n\t\tactiveTransactions: make(map[uint64]Transaction),\n\t\tremapWaitersCond:   sync.NewCond(&sync.Mutex{}),\n\t}\n\n\tif err := db.mapFile(); err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tif info.Size() == initialSize {\n\t\tmeta := &Meta{\n\t\t\tVersion:   1,\n\t\t\tPageSize:  uint32(pageSize),\n\t\t\tFreeSpace: 0,\n\t\t\tPageCount: uint64(dataPageStart),\n\t\t}\n\t\tif err := db.initializeMeta(meta); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn db, nil\n}\n\nfunc (db *Database) mapFile() error {\n\tdb.mapMu.Lock()\n\tdefer db.mapMu.Unlock()\n\n\tif len(db.mapData) > 0 {\n\t\treturn nil\n\t}\n\n\tdata, err := os.ReadFile(db.filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapData = data\n\tdb.mapSize = uint64(len(data))\n\treturn nil\n}\n\nfunc (db *Database) unmapFile() error {\n\tif len(db.mapData) == 0 {\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (db *Database) initializeMeta(meta *Meta) error {\n\tdb.writeMu.Lock()\n\tdefer db.writeMu.Unlock()\n\n\tmetaData := meta.Encode()\n\tcopy(db.mapData[0:len(metaData)], metaData)\n\tcopy(db.mapData[pageSize:pageSize+len(metaData)], metaData)\n\n\treturn db.syncFile()\n}\n\nfunc (db *Database) syncMetaPage(meta *Meta) error {\n\tmetaData := meta.Encode()\n\tcopy(db.mapData[0:len(metaData)], metaData)\n\tcopy(db.mapData[pageSize:pageSize+len(metaData)], metaData)\n\treturn nil\n}\n\nfunc (db *Database) syncFile() error {\n\tif err := db.file.Sync(); err != nil {\n\t\treturn err\n\t}\n\treturn os.WriteFile(db.filename, db.mapData, 0644)\n}\n\nfunc (db *Database) expandAndRemap(wt *WriteTransaction, newSize uint64) error {\n\tatomic.AddInt32(&db.remapWaiters, 1)\n\tdefer atomic.AddInt32(&db.remapWaiters, -1)\n\n\tif err := db.file.Truncate(int64(newSize)); err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapMu.Lock()\n\tdb.mapData = make([]byte, newSize)\n\tdb.mapSize = newSize\n\tdb.mapMu.Unlock()\n\n\tdb.remapWaitersCond.L.Lock()\n\tfor {\n\t\tactiveTxns := db.getActiveTransactions()\n\t\tif len(activeTxns) <= 1 {\n\t\t\tbreak\n\t\t}\n\t\tdb.remapWaitersCond.Wait()\n\t}\n\tdb.remapWaitersCond.L.Unlock()\n\n\tif err := db.mapFile(); err != nil {\n\t\treturn err\n\t}\n\n\twt.mu.Lock()\n\tdb.mapMu.RLock()\n\twt.mapData = db.mapData\n\twt.mapSize = db.mapSize\n\tdb.mapMu.RUnlock()\n\twt.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (db *Database) BeginReadTransaction() (Transaction, error) {\n\tif db.closed {\n\t\treturn nil, errFileClosed\n\t}\n\n\tdb.mapMu.RLock()\n\tmapData := make([]byte, len(db.mapData))\n\tcopy(mapData, db.mapData)\n\tmapSize := db.mapSize\n\tdb.mapMu.RUnlock()\n\n\tmetaData := make([]byte, 24)\n\tcopy(metaData, mapData[0:24])\n\n\tmeta, err := DecodeMeta(metaData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trt := &ReadTransaction{\n\t\tid:      db.next",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:497:19: syntax error: unexpected EOF in composite literal; possibly missing comma or }"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:497:19: syntax error: unexpected EOF in composite literal; possibly missing comma or }\n\n\nGolang errors in file: [-]:\n\n  > [line 0 : column 0] - missing return\n\n\nGolang errors in file: [/tmp/go_synthesis_4wr5_e8z/main.go]:\n\n  > [line 485 : column 2] - declared and not used: mapSize\n\n  > [line 491 : column 2] - declared and not used: meta\n\n  > [line 496 : column 2] - declared and not used: rt\n\n  > [line 497 : column 15] - db.next undefined (type *Database has no field or method next)\n\n  > [line 497 : column 19] - missing ',' before newline in composite literal\n\n  > [line 497 : column 19] - expected '}', found 'EOF'\n\n  > [line 497 : column 19] - expected '}', found 'EOF'\n\n  > [line 497 : column 19] - expected ';', found 'EOF'\n\n  > [line 497 : column 19] - expected ';', found 'EOF'\n\n\n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:335\u001b[0m] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)\n    334: func OpenDatabase(filename string) (*Database, error) {\n  > 335: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    336: \tif err != nil {\n\nAutofix: Consider using os.Root to scope file access under a fixed root (Go >=1.24). Prefer root.Open/root.Stat over os.Open/os.Stat to prevent directory traversal.\n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:335\u001b[0m] - G302 (CWE-276): Expect file permissions to be 0600 or less (Confidence: HIGH, Severity: MEDIUM)\n    334: func OpenDatabase(filename string) (*Database, error) {\n  > 335: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    336: \tif err != nil {\n\nAutofix: \n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:437\u001b[0m] - G306 (CWE-276): Expect WriteFile permissions to be 0600 or less (Confidence: HIGH, Severity: MEDIUM)\n    436: \t}\n  > 437: \treturn os.WriteFile(db.filename, db.mapData, 0644)\n    438: }\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:382\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    381: \t\tif err := db.initializeMeta(meta); err != nil {\n  > 382: \t\t\tfile.Close()\n    383: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:370\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    369: \tif err := db.mapFile(); err != nil {\n  > 370: \t\tfile.Close()\n    371: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:356\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    355: \tif err != nil {\n  > 356: \t\tfile.Close()\n    357: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:349\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    348: \t\tif err := file.Truncate(initialSize); err != nil {\n  > 349: \t\t\tfile.Close()\n    350: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:342\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    341: \tif err != nil {\n  > 342: \t\tfile.Close()\n    343: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:62\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n  > 62: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n    63: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:61\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n  > 61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n    62: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:60\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n  > 60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:59\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    58: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n  > 59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:58\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    57: \tm := &Meta{}\n  > 58: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:43\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n  > 43: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n    44: \tdata := buf.Bytes()\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:42\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n  > 42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n    43: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:41\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    40: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n  > 41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:40\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    39: \tbuf := new(bytes.Buffer)\n  > 40: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n    41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 497\n  Nosec  : 0\n  Issues : \u001b[1;31m17\u001b[0m\n\n[gosec] 2025/12/01 14:00:04 Including rules: default\n[gosec] 2025/12/01 14:00:04 Excluding rules: default\n[gosec] 2025/12/01 14:00:04 Including analyzers: default\n[gosec] 2025/12/01 14:00:04 Excluding analyzers: default\n[gosec] 2025/12/01 14:00:04 Import directory: /tmp/go_synthesis_4wr5_e8z\n[gosec] 2025/12/01 14:00:04 Checking package: main\n[gosec] 2025/12/01 14:00:04 Checking file: /tmp/go_synthesis_4wr5_e8z/main.go\n[gosec] 2025/12/01 14:00:05 Panic when running SSA analyzer on package: main. Panic: runtime error: invalid memory address or nil pointer dereference\nStack trace:\ngoroutine 1 [running]:\nruntime/debug.Stack()\n\t/usr/local/go/src/runtime/debug/stack.go:26 +0x5e\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA.func1()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:501 +0x58\npanic({0xecea40?, 0x1998730?})\n\t/usr/local/go/src/runtime/panic.go:783 +0x132\ngolang.org/x/tools/go/ssa.(*Program).packageLevelMember(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/source.go:187\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000bdc210, 0xc000f26c00, {0x11e2648?, 0xc000d389c0}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:820 +0x1b2b\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000bdc210, 0xc000f26c00, {0x11e2648, 0xc000d389c0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000bdc210, 0xc000f26c00, {0x11e26d8?, 0xc000de9c20}, {0x0, {0x0, 0x0}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:842 +0x1031\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000bdc210, 0xc000f26c00, {0x11e26d8, 0xc000de9c20})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).assign(0x11de960?, 0xc000f26c00, {0x11e5e20, 0xc000f50330}, {0x11e26d8?, 0xc000de9c20?}, 0xf4?, 0xc000ac6a88)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:614 +0x3a5\ngolang.org/x/tools/go/ssa.(*builder).compLit(0xc000bdc210, 0xc000f26c00, {0x11ec2e0, 0xc000dd68a0}, 0xc000d3a3c0, 0x1, 0xc000ac6a88)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1312 +0x1217\ngolang.org/x/tools/go/ssa.(*builder).addr(0xc000bdc210, 0xc000f26c00, {0x11e2738?, 0xc000d3a3c0}, 0x1)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:461 +0xc11\ngolang.org/x/tools/go/ssa.(*builder).expr0(0xc000bdc210, 0xc000f26c00, {0x11e28e0?, 0xc000d389e0}, {0x7, {0x11de848, 0xc000e34d90}, {0x0, 0x0}})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:731 +0xce\ngolang.org/x/tools/go/ssa.(*builder).expr(0xc000bdc210, 0xc000f26c00, {0x11e28e0, 0xc000d389e0})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:641 +0x17b\ngolang.org/x/tools/go/ssa.(*builder).assign(0xc000bdc210?, 0xc000f26c00, {0x11e5e20, 0xc000f50300}, {0x11e28e0?, 0xc000d389e0?}, 0xbe?, 0xc000ac7078)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:614 +0x3a5\ngolang.org/x/tools/go/ssa.(*builder).assignStmt(0xc000bdc210, 0xc000f26c00, {0xc000df9040, 0x1, 0xc000f4ca50?}, {0xc000df9070, 0x1, 0x0?}, 0x1)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:1229 +0x468\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000bdc210, 0xc000f26c00, {0x11e2d90?, 0xc000d3a400?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2720 +0x5b5\ngolang.org/x/tools/go/ssa.(*builder).stmtList(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:972\ngolang.org/x/tools/go/ssa.(*builder).stmt(0xc000bdc210, 0xc000f26c00, {0x11e2eb0?, 0xc000dfcde0?})\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2753 +0x1109\ngolang.org/x/tools/go/ssa.(*builder).buildFromSyntax(0xc000bdc210, 0xc000f26c00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2962 +0x25a\ngolang.org/x/tools/go/ssa.(*builder).buildFunction(0xf73000?, 0xc000f26c00)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2912 +0x183\ngolang.org/x/tools/go/ssa.(*builder).iterate(0xc000bdc210)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:2897 +0x25\ngolang.org/x/tools/go/ssa.(*Package).build(0xc000207200)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3183 +0xce\nsync.(*Once).doSlow(0xc00018c240?, 0xc000ddd8c0?)\n\t/usr/local/go/src/sync/once.go:78 +0xac\nsync.(*Once).Do(...)\n\t/usr/local/go/src/sync/once.go:69\ngolang.org/x/tools/go/ssa.(*Package).Build(...)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/ssa/builder.go:3172\ngolang.org/x/tools/go/analysis/passes/buildssa.run(0xc000bc2000)\n\t/home/fanbao/go/pkg/mod/golang.org/x/tools@v0.38.0/go/analysis/passes/buildssa/buildssa.go:59 +0x21d\ngithub.com/securego/gosec/v2.(*Analyzer).buildSSA(0x71a07b?, 0xc0008ac9c0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:524 +0x1d3\ngithub.com/securego/gosec/v2.(*Analyzer).CheckAnalyzers(0xc0009f2980, 0xc0008ac9c0)\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:415 +0x32\ngithub.com/securego/gosec/v2.(*Analyzer).Process(0xc0009f2980, {0x0, 0x0, 0x0}, {0xc000053530, 0x1, 0x3d?})\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/analyzer.go:321 +0x487\nmain.main()\n\t/home/fanbao/go/pkg/mod/github.com/securego/gosec/v2@v2.22.10/cmd/gosec/main.go:474 +0xde7\n[gosec] 2025/12/01 14:00:05 Error building the SSA representation of the package main: no ssa result"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: missing ',' before newline in composite literal\n/tmp/go_synthesis_4wr5_e8z/main.go:497:15: db.next undefined (type *Database has no field or method next)\n-: missing return\n/tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize\n/tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta\n/tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:497:19: syntax error: unexpected EOF in composite literal; possibly missing comma or } /tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected ';', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected ';', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected '}', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected '}', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:19: missing ',' before newline in composite literal /tmp/go_synthesis_4wr5_e8z/main.go:497:15: db.next undefined (type *Database has no field or method next) -: missing return /tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize /tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta /tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:497:19: syntax error: unexpected EOF in composite literal; possibly missing comma or }\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:19: missing ',' before newline in composite literal\n/tmp/go_synthesis_4wr5_e8z/main.go:497:15: db.next undefined (type *Database has no field or method next)\n-: missing return\n/tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize\n/tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta\n/tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:497:19: syntax error: unexpected EOF in composite literal; possibly missing comma or } (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\nconst (\n\tpageSize      = 4096\n\tmetaPageSize  = 1024\n\tmaxMapSize    = 1073741824\n\tmetaPage0     = 0\n\tmetaPage1     = 1\n\tdataPageStart = 2\n)\n\nvar (\n\terrTxnInProgress = errors.New(\"transaction already in progress\")\n\terrNotTxn        = errors.New(\"not in a transaction\")\n\terrReadOnly      = errors.New(\"read-only transaction cannot write\")\n\terrFileClosed    = errors.New(\"database file is closed\")\n\terrInvalidMeta   = errors.New(\"invalid metadata\")\n)\n\ntype Meta struct {\n\tVersion   uint32\n\tPageSize  uint32\n\tFreeSpace uint64\n\tPageCount uint64\n\tChecksum  uint32\n}\n\nfunc (m *Meta) Encode() []byte {\n\tbuf := new(bytes.Buffer)\n\tbinary.Write(buf, binary.LittleEndian, m.Version)\n\tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\tdata := buf.Bytes()\n\tchecksum := calculateChecksum(data)\n\tbuf.Write(make([]byte, 4))\n\tfullData := buf.Bytes()\n\tbinary.LittleEndian.PutUint32(fullData[20:24], checksum)\n\treturn fullData[:24]\n}\n\nfunc DecodeMeta(data []byte) (*Meta, error) {\n\tif len(data) < 24 {\n\t\treturn nil, errInvalidMeta\n\t}\n\tbuf := bytes.NewReader(data[:24])\n\tm := &Meta{}\n\tbinary.Read(buf, binary.LittleEndian, &m.Version)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\n\texpectedChecksum := calculateChecksum(data[:20])\n\tif m.Checksum != expectedChecksum {\n\t\treturn nil, errInvalidMeta\n\t}\n\treturn m, nil\n}\n\nfunc calculateChecksum(data []byte) uint32 {\n\tvar checksum uint32\n\tfor _, b := range data {\n\t\tchecksum += uint32(b)\n\t}\n\treturn checksum\n}\n\ntype Transaction interface {\n\tReadPage(pageNum uint64) ([]byte, error)\n\tWritePage(pageNum uint64, data []byte) error\n\tGetMeta() *Meta\n\tCommit() error\n\tRollback() error\n\tIsReadOnly() bool\n\tID() uint64\n}\n\ntype ReadTransaction struct {\n\tid       uint64\n\tdb       *Database\n\tmeta     *Meta\n\tmapData  []byte\n\tmapSize  uint64\n\tclosed   bool\n\tmu       sync.Mutex\n}\n\nfunc (rt *ReadTransaction) ID() uint64 {\n\treturn rt.id\n}\n\nfunc (rt *ReadTransaction) IsReadOnly() bool {\n\treturn true\n}\n\nfunc (rt *ReadTransaction) GetMeta() *Meta {\n\treturn rt.meta\n}\n\nfunc (rt *ReadTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > rt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, rt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (rt *ReadTransaction) WritePage(pageNum uint64, data []byte) error {\n\treturn errReadOnly\n}\n\nfunc (rt *ReadTransaction) Commit() error {\n\trt.mu.Lock()\n\tdefer rt.mu.Unlock()\n\n\tif rt.closed {\n\t\treturn errNotTxn\n\t}\n\n\trt.closed = true\n\trt.db.removeTransaction(rt.id)\n\treturn nil\n}\n\nfunc (rt *ReadTransaction) Rollback() error {\n\treturn rt.Commit()\n}\n\ntype WriteTransaction struct {\n\tid           uint64\n\tdb           *Database\n\tmeta         *Meta\n\toriginalMeta *Meta\n\tmapData      []byte\n\tmapSize      uint64\n\twriteBuffer  map[uint64][]byte\n\tclosed       bool\n\tmu           sync.Mutex\n}\n\nfunc (wt *WriteTransaction) ID() uint64 {\n\treturn wt.id\n}\n\nfunc (wt *WriteTransaction) IsReadOnly() bool {\n\treturn false\n}\n\nfunc (wt *WriteTransaction) GetMeta() *Meta {\n\treturn wt.meta\n}\n\nfunc (wt *WriteTransaction) ReadPage(pageNum uint64) ([]byte, error) {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn nil, errNotTxn\n\t}\n\n\tif cached, ok := wt.writeBuffer[pageNum]; ok {\n\t\tpage := make([]byte, pageSize)\n\t\tcopy(page, cached)\n\t\treturn page, nil\n\t}\n\n\toffset := pageNum * uint64(pageSize)\n\tif offset+uint64(pageSize) > wt.mapSize {\n\t\treturn nil, fmt.Errorf(\"page out of range\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, wt.mapData[offset:offset+uint64(pageSize)])\n\treturn page, nil\n}\n\nfunc (wt *WriteTransaction) WritePage(pageNum uint64, data []byte) error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\tif len(data) > pageSize {\n\t\treturn fmt.Errorf(\"data exceeds page size\")\n\t}\n\n\tpage := make([]byte, pageSize)\n\tcopy(page, data)\n\twt.writeBuffer[pageNum] = page\n\n\tif pageNum >= wt.meta.PageCount {\n\t\twt.meta.PageCount = pageNum + 1\n\t}\n\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Commit() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.db.writeMu.Lock()\n\tdefer wt.db.writeMu.Unlock()\n\n\trequiredSize := wt.meta.PageCount * uint64(pageSize)\n\tif requiredSize > wt.mapSize {\n\t\tnewSize := ((requiredSize + maxMapSize - 1) / maxMapSize) * maxMapSize\n\t\tif newSize > maxMapSize {\n\t\t\tnewSize = maxMapSize\n\t\t}\n\t\tif err := wt.db.expandAndRemap(wt, newSize); err != nil {\n\t\t\twt.closed = true\n\t\t\twt.db.removeTransaction(wt.id)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor pageNum, data := range wt.writeBuffer {\n\t\toffset := pageNum * uint64(pageSize)\n\t\tcopy(wt.mapData[offset:offset+uint64(pageSize)], data)\n\t}\n\n\tif err := wt.db.syncMetaPage(wt.meta); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\tif err := wt.db.syncFile(); err != nil {\n\t\twt.closed = true\n\t\twt.db.removeTransaction(wt.id)\n\t\treturn err\n\t}\n\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\nfunc (wt *WriteTransaction) Rollback() error {\n\twt.mu.Lock()\n\tdefer wt.mu.Unlock()\n\n\tif wt.closed {\n\t\treturn errNotTxn\n\t}\n\n\twt.writeBuffer = make(map[uint64][]byte)\n\twt.meta = &Meta{\n\t\tVersion:   wt.originalMeta.Version,\n\t\tPageSize:  wt.originalMeta.PageSize,\n\t\tFreeSpace: wt.originalMeta.FreeSpace,\n\t\tPageCount: wt.originalMeta.PageCount,\n\t}\n\twt.closed = true\n\twt.db.removeTransaction(wt.id)\n\treturn nil\n}\n\ntype Database struct {\n\tfile               *os.File\n\tfilename           string\n\tmapData            []byte\n\tmapSize            uint64\n\tpageSize           uint32\n\tclosed             bool\n\tactiveTransactions map[uint64]Transaction\n\ttxnMu              sync.RWMutex\n\tmapMu              sync.RWMutex\n\twriteMu            sync.Mutex\n\tnextTxnID          uint64\n\ttxnIDMu            sync.Mutex\n\tremapWaiters       int32\n\tremapWaitersCond   *sync.Cond\n}\n\nfunc (db *Database) nextTransactionID() uint64 {\n\tdb.txnIDMu.Lock()\n\tdefer db.txnIDMu.Unlock()\n\tdb.nextTxnID++\n\treturn db.nextTxnID\n}\n\nfunc (db *Database) addTransaction(txn Transaction) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdb.activeTransactions[txn.ID()] = txn\n}\n\nfunc (db *Database) removeTransaction(id uint64) {\n\tdb.txnMu.Lock()\n\tdefer db.txnMu.Unlock()\n\tdelete(db.activeTransactions, id)\n\tdb.remapWaitersCond.Broadcast()\n}\n\nfunc (db *Database) getActiveTransactions() map[uint64]Transaction {\n\tdb.txnMu.RLock()\n\tdefer db.txnMu.RUnlock()\n\ttxns := make(map[uint64]Transaction)\n\tfor k, v := range db.activeTransactions {\n\t\ttxns[k] = v\n\t}\n\treturn txns\n}\n\nfunc OpenDatabase(filename string) (*Database, error) {\n\tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo, err := file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tvar initialSize int64 = pageSize * 100\n\tif info.Size() == 0 {\n\t\tif err := file.Truncate(initialSize); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tinfo, err = file.Stat()\n\tif err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tdb := &Database{\n\t\tfile:               file,\n\t\tfilename:           filename,\n\t\tpageSize:           uint32(pageSize),\n\t\tmapSize:            uint64(info.Size()),\n\t\tactiveTransactions: make(map[uint64]Transaction),\n\t\tremapWaitersCond:   sync.NewCond(&sync.Mutex{}),\n\t}\n\n\tif err := db.mapFile(); err != nil {\n\t\tfile.Close()\n\t\treturn nil, err\n\t}\n\n\tif info.Size() == initialSize {\n\t\tmeta := &Meta{\n\t\t\tVersion:   1,\n\t\t\tPageSize:  uint32(pageSize),\n\t\t\tFreeSpace: 0,\n\t\t\tPageCount: uint64(dataPageStart),\n\t\t}\n\t\tif err := db.initializeMeta(meta); err != nil {\n\t\t\tfile.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn db, nil\n}\n\nfunc (db *Database) mapFile() error {\n\tdb.mapMu.Lock()\n\tdefer db.mapMu.Unlock()\n\n\tif len(db.mapData) > 0 {\n\t\treturn nil\n\t}\n\n\tdata, err := os.ReadFile(db.filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapData = data\n\tdb.mapSize = uint64(len(data))\n\treturn nil\n}\n\nfunc (db *Database) unmapFile() error {\n\tif len(db.mapData) == 0 {\n\t\treturn nil\n\t}\n\treturn nil\n}\n\nfunc (db *Database) initializeMeta(meta *Meta) error {\n\tdb.writeMu.Lock()\n\tdefer db.writeMu.Unlock()\n\n\tmetaData := meta.Encode()\n\tcopy(db.mapData[0:len(metaData)], metaData)\n\tcopy(db.mapData[pageSize:pageSize+len(metaData)], metaData)\n\n\treturn db.syncFile()\n}\n\nfunc (db *Database) syncMetaPage(meta *Meta) error {\n\tmetaData := meta.Encode()\n\tcopy(db.mapData[0:len(metaData)], metaData)\n\tcopy(db.mapData[pageSize:pageSize+len(metaData)], metaData)\n\treturn nil\n}\n\nfunc (db *Database) syncFile() error {\n\tif err := db.file.Sync(); err != nil {\n\t\treturn err\n\t}\n\treturn os.WriteFile(db.filename, db.mapData, 0644)\n}\n\nfunc (db *Database) expandAndRemap(wt *WriteTransaction, newSize uint64) error {\n\tatomic.AddInt32(&db.remapWaiters, 1)\n\tdefer atomic.AddInt32(&db.remapWaiters, -1)\n\n\tif err := db.file.Truncate(int64(newSize)); err != nil {\n\t\treturn err\n\t}\n\n\tdb.mapMu.Lock()\n\tdb.mapData = make([]byte, newSize)\n\tdb.mapSize = newSize\n\tdb.mapMu.Unlock()\n\n\tdb.remapWaitersCond.L.Lock()\n\tfor {\n\t\tactiveTxns := db.getActiveTransactions()\n\t\tif len(activeTxns) <= 1 {\n\t\t\tbreak\n\t\t}\n\t\tdb.remapWaitersCond.Wait()\n\t}\n\tdb.remapWaitersCond.L.Unlock()\n\n\tif err := db.mapFile(); err != nil {\n\t\treturn err\n\t}\n\n\twt.mu.Lock()\n\tdb.mapMu.RLock()\n\twt.mapData = db.mapData\n\twt.mapSize = db.mapSize\n\tdb.mapMu.RUnlock()\n\twt.mu.Unlock()\n\n\treturn nil\n}\n\nfunc (db *Database) BeginReadTransaction() (Transaction, error) {\n\tif db.closed {\n\t\treturn nil, errFileClosed\n\t}\n\n\tdb.mapMu.RLock()\n\tmapData := make([]byte, len(db.mapData))\n\tcopy(mapData, db.mapData)\n\tmapSize := db.mapSize\n\tdb.mapMu.RUnlock()\n\n\tmetaData := make([]byte, 24)\n\tcopy(metaData, mapData[0:24])\n\n\tmeta, err := DecodeMeta(metaData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\trt := &ReadTransaction{\n\t\tid:      db.nextTransactionID(),",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected }"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected }\n\n\nGolang errors in file: [-]:\n\n  > [line 0 : column 0] - missing return\n\n\nGolang errors in file: [/tmp/go_synthesis_4wr5_e8z/main.go]:\n\n  > [line 485 : column 2] - declared and not used: mapSize\n\n  > [line 491 : column 2] - declared and not used: meta\n\n  > [line 496 : column 2] - declared and not used: rt\n\n  > [line 497 : column 35] - expected '}', found 'EOF'\n\n  > [line 497 : column 35] - expected '}', found 'EOF'\n\n  > [line 497 : column 35] - expected ';', found 'EOF'\n\n  > [line 497 : column 35] - expected ';', found 'EOF'\n\n\n\n[\u001b[97;41m/tmp/go_synthesis_4wr5_e8z/main.go:444\u001b[0m] - G115 (CWE-190): integer overflow conversion uint64 -> int64 (Confidence: MEDIUM, Severity: HIGH)\n    443: \n  > 444: \tif err := db.file.Truncate(int64(newSize)); err != nil {\n    445: \t\treturn err\n\nAutofix: \n\n[\u001b[97;41m/tmp/go_synthesis_4wr5_e8z/main.go:364\u001b[0m] - G115 (CWE-190): integer overflow conversion int64 -> uint64 (Confidence: MEDIUM, Severity: HIGH)\n    363: \t\tpageSize:           uint32(pageSize),\n  > 364: \t\tmapSize:            uint64(info.Size()),\n    365: \t\tactiveTransactions: make(map[uint64]Transaction),\n\nAutofix: \n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:335\u001b[0m] - G304 (CWE-22): Potential file inclusion via variable (Confidence: HIGH, Severity: MEDIUM)\n    334: func OpenDatabase(filename string) (*Database, error) {\n  > 335: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    336: \tif err != nil {\n\nAutofix: Consider using os.Root to scope file access under a fixed root (Go >=1.24). Prefer root.Open/root.Stat over os.Open/os.Stat to prevent directory traversal.\n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:335\u001b[0m] - G302 (CWE-276): Expect file permissions to be 0600 or less (Confidence: HIGH, Severity: MEDIUM)\n    334: func OpenDatabase(filename string) (*Database, error) {\n  > 335: \tfile, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0644)\n    336: \tif err != nil {\n\nAutofix: \n\n[\u001b[30;43m/tmp/go_synthesis_4wr5_e8z/main.go:437\u001b[0m] - G306 (CWE-276): Expect WriteFile permissions to be 0600 or less (Confidence: HIGH, Severity: MEDIUM)\n    436: \t}\n  > 437: \treturn os.WriteFile(db.filename, db.mapData, 0644)\n    438: }\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:382\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    381: \t\tif err := db.initializeMeta(meta); err != nil {\n  > 382: \t\t\tfile.Close()\n    383: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:370\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    369: \tif err := db.mapFile(); err != nil {\n  > 370: \t\tfile.Close()\n    371: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:356\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    355: \tif err != nil {\n  > 356: \t\tfile.Close()\n    357: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:349\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    348: \t\tif err := file.Truncate(initialSize); err != nil {\n  > 349: \t\t\tfile.Close()\n    350: \t\t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:342\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    341: \tif err != nil {\n  > 342: \t\tfile.Close()\n    343: \t\treturn nil, err\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:62\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n  > 62: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n    63: \n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:61\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n  > 61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n    62: \tbinary.Read(buf, binary.LittleEndian, &m.Checksum)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:60\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n  > 60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n    61: \tbinary.Read(buf, binary.LittleEndian, &m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:59\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    58: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n  > 59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n    60: \tbinary.Read(buf, binary.LittleEndian, &m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:58\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    57: \tm := &Meta{}\n  > 58: \tbinary.Read(buf, binary.LittleEndian, &m.Version)\n    59: \tbinary.Read(buf, binary.LittleEndian, &m.PageSize)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:43\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n  > 43: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n    44: \tdata := buf.Bytes()\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:42\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n  > 42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n    43: \tbinary.Write(buf, binary.LittleEndian, m.PageCount)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:41\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    40: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n  > 41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n    42: \tbinary.Write(buf, binary.LittleEndian, m.FreeSpace)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_4wr5_e8z/main.go:40\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    39: \tbuf := new(bytes.Buffer)\n  > 40: \tbinary.Write(buf, binary.LittleEndian, m.Version)\n    41: \tbinary.Write(buf, binary.LittleEndian, m.PageSize)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 497\n  Nosec  : 0\n  Issues : \u001b[1;31m19\u001b[0m\n\n[gosec] 2025/12/01 14:00:26 Including rules: default\n[gosec] 2025/12/01 14:00:26 Excluding rules: default\n[gosec] 2025/12/01 14:00:26 Including analyzers: default\n[gosec] 2025/12/01 14:00:26 Excluding analyzers: default\n[gosec] 2025/12/01 14:00:26 Import directory: /tmp/go_synthesis_4wr5_e8z\n[gosec] 2025/12/01 14:00:26 Checking package: main\n[gosec] 2025/12/01 14:00:26 Checking file: /tmp/go_synthesis_4wr5_e8z/main.go"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF'\n-: missing return\n/tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize\n/tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta\n/tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected } /tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF' /tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF' -: missing return /tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize /tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta /tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected }\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected ';', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF'\n/tmp/go_synthesis_4wr5_e8z/main.go:497:35: expected '}', found 'EOF'\n-: missing return\n/tmp/go_synthesis_4wr5_e8z/main.go:485:2: declared and not used: mapSize\n/tmp/go_synthesis_4wr5_e8z/main.go:491:2: declared and not used: meta\n/tmp/go_synthesis_4wr5_e8z/main.go:496:2: declared and not used: rt\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:497:35: syntax error: unexpected EOF, expected } (compile)"
                }
            ]
        }
    ],
    "passed": false
}