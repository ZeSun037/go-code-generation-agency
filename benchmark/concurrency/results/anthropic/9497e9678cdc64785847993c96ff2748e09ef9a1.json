{
    "task": "9497e9678cdc64785847993c96ff2748e09ef9a1.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype LockManager struct {\n\tmu              sync.RWMutex\n\tlocks           map[string]string\n\twaitQueues      map[string][]*waitEntry\n\tleaseCounter    int\n\tleaseCounterMu  sync.Mutex\n}\n\ntype waitEntry struct {\n\tleaseID string\n\tdone    chan struct{}\n}\n\nfunc NewLockManager() *LockManager {\n\treturn &LockManager{\n\t\tlocks:      make(map[string]string),\n\t\twaitQueues: make(map[string][]*waitEntry),\n\t}\n}\n\nfunc (lm *LockManager) generateLeaseID() string {\n\tlm.leaseCounterMu.Lock()\n\tdefer lm.leaseCounterMu.Unlock()\n\tlm.leaseCounter++\n\treturn fmt.Sprintf(\"lease_%d\", lm.leaseCounter)\n}\n\nfunc (lm *LockManager) canAcquireLock(prefix string, leaseID string) bool {\n\tlm.mu.RLock()\n\tdefer lm.mu.RUnlock()\n\n\tinternalKey := prefix + \":\" + leaseID\n\n\tfor key := range lm.locks {\n\t\tif key != internalKey {\n\t\t\tif lm.isConflicting(prefix, key) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (lm *LockManager) isConflicting(prefix string, existingKey string) bool {\n\tparts := split(existingKey, ':')\n\tif len(parts) < 2 {\n\t\treturn false\n\t}\n\texistingPrefix := parts[0]\n\n\tif prefix == existingPrefix {\n\t\treturn true\n\t}\n\n\tif len(prefix) < len(existingPrefix) && existingPrefix[:len(prefix)] == prefix {\n\t\treturn true\n\t}\n\n\tif len(existingPrefix) < len(prefix) && prefix[:len(existingPrefix)] == existingPrefix {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc split(s, sep string) []string {\n\tvar result []string\n\tcurrent := \"\"\n\tfor _, ch := range s {\n\t\tif string(ch) == sep {\n\t\t\tif current != \"\" {\n\t\t\t\tresult = append(result, current)\n\t\t\t\tcurrent = \"\"\n\t\t\t}\n\t\t} else {\n\t\t\tcurrent += string(ch)\n\t\t}\n\t}\n\tif current != \"\" {\n\t\tresult = append(result, current)\n\t}\n\treturn result\n}\n\nfunc (lm *LockManager) Lock(prefix string, timeout time.Duration) (string, error) {\n\tleaseID := lm.generateLeaseID()\n\tinternalKey := prefix + \":\" + leaseID\n\n\tstartTime := time.Now()\n\tfor {\n\t\tif time.Since(startTime) > timeout {\n\t\t\treturn \"\", fmt.Errorf(\"lock acquisition timeout for prefix %s\", prefix)\n\t\t}\n\n\t\tlm.mu.Lock()\n\t\tif lm.canAcquireLock(prefix, leaseID) {\n\t\t\tlm.locks[internalKey] = leaseID\n\t\t\tlm.mu.Unlock()\n\t\t\treturn leaseID, nil\n\t\t}\n\n\t\twaitEntry := &waitEntry{\n\t\t\tleaseID: leaseID,\n\t\t\tdone:    make(chan struct{}),\n\t\t}\n\t\tlm.waitQueues[prefix] = append(lm.waitQueues[prefix], waitEntry)\n\t\tlm.mu.Unlock()\n\n\t\tselect {\n\t\tcase <-waitEntry.done:\n\t\t\tcontinue\n\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\tlm.mu.Lock()\n\t\t\tlm.removeWaitEntry(prefix, leaseID)\n\t\t\tlm.mu.Unlock()\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc (lm *LockManager) removeWaitEntry(prefix string, leaseID string) {\n\tqueue, exists := lm.waitQueues[prefix]\n\tif !exists {\n\t\treturn\n\t}\n\n\tnewQueue := []*waitEntry{}\n\tfor _, entry := range queue {\n\t\tif entry.leaseID != leaseID {\n\t\t\tnewQueue = append(newQueue, entry)\n\t\t}\n\t}\n\n\tif len(newQueue) == 0 {\n\t\tdelete(lm.waitQueues, prefix)\n\t} else {\n\t\tlm.waitQueues[prefix] = newQueue\n\t}\n}\n\nfunc (lm *LockManager) Unlock(prefix string, leaseID string) error {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tinternalKey := prefix + \":\" + leaseID\n\n\tif _, exists := lm.locks[internalKey]; !exists {\n\t\treturn fmt.Errorf(\"lock not found for prefix %s with lease %s\", prefix, leaseID)\n\t}\n\n\tdelete(lm.locks, internalKey)\n\n\tif queue, exists := lm.waitQueues[prefix]; exists && len(queue) > 0 {\n\t\tentry := queue[0]\n\t\tnewQueue := queue[1:]\n\t\tif len(newQueue) == 0 {\n\t\t\tdelete(lm.waitQueues, prefix)\n\t\t} else {\n\t\t\tlm.waitQueues[prefix] = newQueue\n\t\t}\n\t\tclose(entry.done)\n\t}\n\n\treturn nil\n}\n\nfunc (lm *LockManager) GetLockedKeys() map[string]string {\n\tlm.mu.RLock()\n\tdefer lm.mu.RUnlock()\n\n\tresult := make(map[string]string)\n\tfor k, v := range lm.locks {\n\t\tresult[k] = v\n\t}\n\treturn result\n}\n\nfunc (lm *LockManager) AddKey(prefix string, leaseID string) {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\tinternalKey := prefix + \":\" + leaseID\n\tlm.locks[internalKey] = leaseID\n}\n\nfunc testScenario1(lm *LockManager) {\n\tfmt.Println(\"\\n=== Test Scenario 1: Simple Sequential Lock Acquisition ===\")\n\n\tlease1, err := lm.Lock(\"resource\", 5*time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to acquire lock on 'resource': %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Client 1 acquired lock on 'resource' with lease: %s\\n\", lease1)\n\n\terr = lm.Unlock(\"resource\", lease1)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to release lock: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Client 1 released lock on 'resource'\\n\")\n\n\tfmt.Printf(\"Locked keys: %v\\n\", lm.GetLockedKeys())\n}\n\nfunc testScenario2(lm *LockManager) {\n\tfmt.Println(\"\\n=== Test Scenario 2: Concurrent Lock Acquisition ===\")\n\n\tvar wg sync.WaitGroup\n\tresults := make(chan string, 3)\n\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo func(clientID int) {\n\t\t\tdefer wg.Done()\n\t\t\tlease, err := lm.Lock(\"database\", 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tresults <- fmt.Sprintf(\"Client %d: Failed to acquire lock: %v\", clientID, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- fmt.Sprintf(\"Client %d: Acquired lock with lease %s\", clientID, lease)\n\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\t\terr = lm.Unlock(\"database\", lease)\n\t\t\tif err != nil {\n\t\t\t\tresults <- fmt.Sprintf(\"Client %d: Failed to release lock: %v\", clientID, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- fmt.Sprintf(\"Client %d: Released lock\", clientID)\n\t\t}(i)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(results)\n\t}()\n\n\tfor msg := range results {\n\t\tfmt.Println(msg)\n\t}\n\n\tfmt.Printf(\"Locked keys after scenario 2: %v\\n\", lm.GetLockedKeys())\n}\n\nfunc testScenario3(lm *LockManager) {\n\tfmt.Println(\"\\n=== Test Scenario 3: Prefix Overlap with Existing Keys ===\")\n\n\tlm.AddKey(\"testa\", \"external_lease\")\n\tfmt.Println(\"Pre-populated 'testa' key in the system\")\n\tfmt.Printf(\"Locked keys before acquiring 'test' lock: %v\\n\", lm.GetLockedKeys())\n\n\tstartTime := time.Now()\n\tlease, err := lm.Lock(\"test\", 5*time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to acquire lock on 'test': %v\\n\", err)\n\t\treturn\n\t}\n\tduration := time.Since(startTime)\n\tfmt.Printf(\"Client acquired lock on 'test' with lease %s in %v\\n\", lease, duration)\n\n\tfmt.Printf(\"Locked keys after acquiring 'test' lock: %v\\n\", lm.GetLockedKeys())\n\n\terr = lm.Unlock(\"test\", lease)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to release lock: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Client released lock on 'test'\\n\")\n\tfmt.Printf(\"Locked keys after releasing 'test' lock: %v\\n\", lm.GetLockedKeys())\n}\n\nfunc testScenario4(lm *LockManager) {\n\tfmt.Println(\"\\n=== Test Scenario 4: Multiple Prefixes with Waiting Queue ===\")\n\n\tvar wg sync.WaitGroup\n\n\tfmt.Println(\"Starting scenario 4...\")\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlease, err := lm.Lock(\"cache\", 10*time.Second)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Client A: Failed to acquire lock on 'cache': %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Client A: Acquired lock on 'cache' with lease %s\\n\", lease)\n\t\ttime.Sleep(2 * time.Second)\n\n\t\terr = lm.Unlock(\"cache\", lease)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Client A: Failed to release lock: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Client A: Released lock on 'cache'\\n\")\n\t}()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Client B: Waiting to acquire lock on 'cache'...\")\n\t\tlease, err := lm.Lock(\"cache\", 10*time.Second)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Client B: Failed to acquire lock on 'cache': %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Client B: Acquired lock on 'cache' with lease %s\\n\", lease)\n\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\terr = lm.Unlock(\"cache\", lease)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Client B: Failed to release lock: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Client B: Released lock on 'cache'\\n\")\n\t}()\n\n\twg.Wait()\n\tfmt.Printf(\"Locked keys after scenario 4: %v\\n\", lm.GetLockedKeys())\n}\n\nfunc main() {\n\tfmt.Println(\"Distributed Lock Manager System\")\n\tfmt.Println(\"================================\")\n\n\tlm := NewLockManager()\n\n\ttestScenario1(lm)\n\n\tlm = NewLockManager()\n\ttestScenario2(lm)\n\n\tlm = NewLockManager()\n\ttestScenario3(lm)\n\n\tlm = NewLockManager()\n\ttestScenario4(lm)\n\n\tfmt.Println(\"\\n=== All Tests Completed ===\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:54:30: cannot use ':' (untyped rune constant 58) as string value in argument to split"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:54:30: cannot use ':' (untyped rune constant 58) as string value in argument to split\n\n\nGolang errors in file: [/tmp/go_synthesis_w7khv9xc/main.go]:\n\n  > [line 54 : column 30] - cannot use ':' (untyped rune constant 58) as string value in argument to split\n\n\n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 351\n  Nosec  : 0\n  Issues : \u001b[1;32m0\u001b[0m\n\n[gosec] 2025/12/01 13:56:07 Including rules: default\n[gosec] 2025/12/01 13:56:07 Excluding rules: default\n[gosec] 2025/12/01 13:56:07 Including analyzers: default\n[gosec] 2025/12/01 13:56:07 Excluding analyzers: default\n[gosec] 2025/12/01 13:56:07 Import directory: /tmp/go_synthesis_w7khv9xc\n[gosec] 2025/12/01 13:56:07 Checking package: main\n[gosec] 2025/12/01 13:56:07 Checking file: /tmp/go_synthesis_w7khv9xc/main.go"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_w7khv9xc/main.go:54:30: cannot use ':' (untyped rune constant 58) as string value in argument to split\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:54:30: cannot use ':' (untyped rune constant 58) as string value in argument to split /tmp/go_synthesis_w7khv9xc/main.go:54:30: cannot use ':' (untyped rune constant 58) as string value in argument to split]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:54:30: cannot use ':' (untyped rune constant 58) as string value in argument to split\n/tmp/go_synthesis_w7khv9xc/main.go:54:30: cannot use ':' (untyped rune constant 58) as string value in argument to split\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:54:30: cannot use ':' (untyped rune constant 58) as string value in argument to split (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype LockManager struct {\n\tmu             sync.RWMutex\n\tlocks          map[string]string\n\twaitQueues     map[string][]*waitEntry\n\tleaseCounter   int\n\tleaseCounterMu sync.Mutex\n}\n\ntype waitEntry struct {\n\tleaseID string\n\tdone    chan struct{}\n}\n\nfunc NewLockManager() *LockManager {\n\treturn &LockManager{\n\t\tlocks:      make(map[string]string),\n\t\twaitQueues: make(map[string][]*waitEntry),\n\t}\n}\n\nfunc (lm *LockManager) generateLeaseID() string {\n\tlm.leaseCounterMu.Lock()\n\tdefer lm.leaseCounterMu.Unlock()\n\tlm.leaseCounter++\n\treturn fmt.Sprintf(\"lease_%d\", lm.leaseCounter)\n}\n\nfunc (lm *LockManager) canAcquireLock(prefix string, leaseID string) bool {\n\tlm.mu.RLock()\n\tdefer lm.mu.RUnlock()\n\n\tinternalKey := prefix + \":\" + leaseID\n\n\tfor key := range lm.locks {\n\t\tif key != internalKey {\n\t\t\tif lm.isConflicting(prefix, key) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (lm *LockManager) isConflicting(prefix string, existingKey string) bool {\n\tparts := splitString(existingKey, \":\")\n\tif len(parts) < 2 {\n\t\treturn false\n\t}\n\texistingPrefix := parts[0]\n\n\tif prefix == existingPrefix {\n\t\treturn true\n\t}\n\n\tif len(prefix) < len(existingPrefix) && existingPrefix[:len(prefix)] == prefix {\n\t\treturn true\n\t}\n\n\tif len(existingPrefix) < len(prefix) && prefix[:len(existingPrefix)] == existingPrefix {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc splitString(s, sep string) []string {\n\tvar result []string\n\tcurrent := \"\"\n\tfor _, ch := range s {\n\t\tif string(ch) == sep {\n\t\t\tif current != \"\" {\n\t\t\t\tresult = append(result, current)\n\t\t\t\tcurrent = \"\"\n\t\t\t}\n\t\t} else {\n\t\t\tcurrent += string(ch)\n\t\t}\n\t}\n\tif current != \"\" {\n\t\tresult = append(result, current)\n\t}\n\treturn result\n}\n\nfunc (lm *LockManager) Lock(prefix string, timeout time.Duration) (string, error) {\n\tleaseID := lm.generateLeaseID()\n\tinternalKey := prefix + \":\" + leaseID\n\n\tstartTime := time.Now()\n\tfor {\n\t\tif time.Since(startTime) > timeout {\n\t\t\treturn \"\", fmt.Errorf(\"lock acquisition timeout for prefix %s\", prefix)\n\t\t}\n\n\t\tlm.mu.Lock()\n\t\tif lm.canAcquireLock(prefix, leaseID) {\n\t\t\tlm.locks[internalKey] = leaseID\n\t\t\tlm.mu.Unlock()\n\t\t\treturn leaseID, nil\n\t\t}\n\n\t\twaitEntry := &waitEntry{\n\t\t\tleaseID: leaseID,\n\t\t\tdone:    make(chan struct{}),\n\t\t}\n\t\tlm.waitQueues[prefix] = append(lm.waitQueues[prefix], waitEntry)\n\t\tlm.mu.Unlock()\n\n\t\tselect {\n\t\tcase <-waitEntry.done:\n\t\t\tcontinue\n\t\tcase <-time.After(100 * time.Millisecond):\n\t\t\tlm.mu.Lock()\n\t\t\tlm.removeWaitEntry(prefix, leaseID)\n\t\t\tlm.mu.Unlock()\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc (lm *LockManager) removeWaitEntry(prefix string, leaseID string) {\n\tqueue, exists := lm.waitQueues[prefix]\n\tif !exists {\n\t\treturn\n\t}\n\n\tnewQueue := []*waitEntry{}\n\tfor _, entry := range queue {\n\t\tif entry.leaseID != leaseID {\n\t\t\tnewQueue = append(newQueue, entry)\n\t\t}\n\t}\n\n\tif len(newQueue) == 0 {\n\t\tdelete(lm.waitQueues, prefix)\n\t} else {\n\t\tlm.waitQueues[prefix] = newQueue\n\t}\n}\n\nfunc (lm *LockManager) Unlock(prefix string, leaseID string) error {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\n\tinternalKey := prefix + \":\" + leaseID\n\n\tif _, exists := lm.locks[internalKey]; !exists {\n\t\treturn fmt.Errorf(\"lock not found for prefix %s with lease %s\", prefix, leaseID)\n\t}\n\n\tdelete(lm.locks, internalKey)\n\n\tif queue, exists := lm.waitQueues[prefix]; exists && len(queue) > 0 {\n\t\tentry := queue[0]\n\t\tnewQueue := queue[1:]\n\t\tif len(newQueue) == 0 {\n\t\t\tdelete(lm.waitQueues, prefix)\n\t\t} else {\n\t\t\tlm.waitQueues[prefix] = newQueue\n\t\t}\n\t\tclose(entry.done)\n\t}\n\n\treturn nil\n}\n\nfunc (lm *LockManager) GetLockedKeys() map[string]string {\n\tlm.mu.RLock()\n\tdefer lm.mu.RUnlock()\n\n\tresult := make(map[string]string)\n\tfor k, v := range lm.locks {\n\t\tresult[k] = v\n\t}\n\treturn result\n}\n\nfunc (lm *LockManager) AddKey(prefix string, leaseID string) {\n\tlm.mu.Lock()\n\tdefer lm.mu.Unlock()\n\tinternalKey := prefix + \":\" + leaseID\n\tlm.locks[internalKey] = leaseID\n}\n\nfunc testScenario1(lm *LockManager) {\n\tfmt.Println(\"\\n=== Test Scenario 1: Simple Sequential Lock Acquisition ===\")\n\n\tlease1, err := lm.Lock(\"resource\", 5*time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to acquire lock on 'resource': %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Client 1 acquired lock on 'resource' with lease: %s\\n\", lease1)\n\n\terr = lm.Unlock(\"resource\", lease1)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to release lock: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Client 1 released lock on 'resource'\\n\")\n\n\tfmt.Printf(\"Locked keys: %v\\n\", lm.GetLockedKeys())\n}\n\nfunc testScenario2(lm *LockManager) {\n\tfmt.Println(\"\\n=== Test Scenario 2: Concurrent Lock Acquisition ===\")\n\n\tvar wg sync.WaitGroup\n\tresults := make(chan string, 6)\n\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo func(clientID int) {\n\t\t\tdefer wg.Done()\n\t\t\tlease, err := lm.Lock(\"database\", 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tresults <- fmt.Sprintf(\"Client %d: Failed to acquire lock: %v\", clientID, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- fmt.Sprintf(\"Client %d: Acquired lock with lease %s\", clientID, lease)\n\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\t\terr = lm.Unlock(\"database\", lease)\n\t\t\tif err != nil {\n\t\t\t\tresults <- fmt.Sprintf(\"Client %d: Failed to release lock: %v\", clientID, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresults <- fmt.Sprintf(\"Client %d: Released lock\", clientID)\n\t\t}(i)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(results)\n\t}()\n\n\tfor msg := range results {\n\t\tfmt.Println(msg)\n\t}\n\n\tfmt.Printf(\"Locked keys after scenario 2: %v\\n\", lm.GetLockedKeys())\n}\n\nfunc testScenario3(lm *LockManager) {\n\tfmt.Println(\"\\n=== Test Scenario 3: Prefix Overlap with Existing Keys ===\")\n\n\tlm.AddKey(\"testa\", \"external_lease\")\n\tfmt.Println(\"Pre-populated 'testa' key in the system\")\n\tfmt.Printf(\"Locked keys before acquiring 'test' lock: %v\\n\", lm.GetLockedKeys())\n\n\tstartTime := time.Now()\n\tlease, err := lm.Lock(\"test\", 5*time.Second)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to acquire lock on 'test': %v\\n\", err)\n\t\treturn\n\t}\n\tduration := time.Since(startTime)\n\tfmt.Printf(\"Client acquired lock on 'test' with lease %s in %v\\n\", lease, duration)\n\n\tfmt.Printf(\"Locked keys after acquiring 'test' lock: %v\\n\", lm.GetLockedKeys())\n\n\terr = lm.Unlock(\"test\", lease)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to release lock: %v\\n\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Client released lock on 'test'\\n\")\n\tfmt.Printf(\"Locked keys after releasing 'test' lock: %v\\n\", lm.GetLockedKeys())\n}\n\nfunc testScenario4(lm *LockManager) {\n\tfmt.Println(\"\\n=== Test Scenario 4: Multiple Prefixes with Waiting Queue ===\")\n\n\tvar wg sync.WaitGroup\n\n\tfmt.Println(\"Starting scenario 4...\")\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tlease, err := lm.Lock(\"cache\", 10*time.Second)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Client A: Failed to acquire lock on 'cache': %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Client A: Acquired lock on 'cache' with lease %s\\n\", lease)\n\t\ttime.Sleep(2 * time.Second)\n\n\t\terr = lm.Unlock(\"cache\", lease)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Client A: Failed to release lock: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Client A: Released lock on 'cache'\\n\")\n\t}()\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfmt.Println(\"Client B: Waiting to acquire lock on 'cache'...\")\n\t\tlease, err := lm.Lock(\"cache\", 10*time.Second)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Client B: Failed to acquire lock on 'cache': %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Client B: Acquired lock on 'cache' with lease %s\\n\", lease)\n\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\terr = lm.Unlock(\"cache\", lease)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Client B: Failed to release lock: %v\\n\", err)\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"Client B: Released lock on 'cache'\\n\")\n\t}()\n\n\twg.Wait()\n\tfmt.Printf(\"Locked keys after scenario 4: %v\\n\", lm.GetLockedKeys())\n}\n\nfunc main() {\n\tfmt.Println(\"Distributed Lock Manager System\")\n\tfmt.Println(\"================================\")\n\n\tlm := NewLockManager()\n\n\ttestScenario1(lm)\n\n\tlm = NewLockManager()\n\ttestScenario2(lm)\n\n\tlm = NewLockManager()\n\ttestScenario3(lm)\n\n\tlm = NewLockManager()\n\ttestScenario4(lm)\n\n\tfmt.Println(\"\\n=== All Tests Completed ===\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}