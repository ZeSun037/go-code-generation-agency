{
    "task": "27b2052c9524abc45ae991d6a402ddb91f06ba03.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype RoundRobinBalancer struct {\n\tmu              sync.RWMutex\n\tservers         []string\n\tcurrentIndex    int64\n\tstopChan        chan struct{}\n\tctx             context.Context\n\tcancel          context.CancelFunc\n\twg              sync.WaitGroup\n\tresolver        func() []string\n\tupdateInterval  time.Duration\n}\n\nfunc NewRoundRobinBalancer(resolver func() []string, updateInterval time.Duration) *RoundRobinBalancer {\n\tctx, cancel := context.WithCancel(context.Background())\n\treturn &RoundRobinBalancer{\n\t\tservers:        []string{},\n\t\tcurrentIndex:   0,\n\t\tstopChan:       make(chan struct{}),\n\t\tctx:            ctx,\n\t\tcancel:         cancel,\n\t\tresolver:       resolver,\n\t\tupdateInterval: updateInterval,\n\t}\n}\n\nfunc (lb *RoundRobinBalancer) Start() error {\n\tlb.mu.Lock()\n\tinitialServers := lb.resolver()\n\tlb.servers = initialServers\n\tlb.mu.Unlock()\n\n\tfmt.Printf(\"[LB] Started with servers: %v\\n\", initialServers)\n\n\tlb.wg.Add(1)\n\tgo lb.watchAddresses()\n\n\treturn nil\n}\n\nfunc (lb *RoundRobinBalancer) watchAddresses() {\n\tdefer lb.wg.Done()\n\n\tticker := time.NewTicker(lb.updateInterval)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tnewServers := lb.resolver()\n\n\t\t\tlb.mu.RLock()\n\t\t\toldServers := lb.servers\n\t\t\tlb.mu.RUnlock()\n\n\t\t\tif !serversEqual(oldServers, newServers) {\n\t\t\t\tlb.mu.Lock()\n\t\t\t\tlb.servers = newServers\n\t\t\t\tlb.mu.Unlock()\n\t\t\t\tfmt.Printf(\"[LB] Address update: %v -> %v\\n\", oldServers, newServers)\n\t\t\t}\n\n\t\tcase <-lb.ctx.Done():\n\t\t\tfmt.Println(\"[LB] Address watcher stopping\")\n\t\t\treturn\n\t\tcase <-lb.stopChan:\n\t\t\tfmt.Println(\"[LB] Address watcher stopped\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (lb *RoundRobinBalancer) Next() (string, error) {\n\tlb.mu.RLock()\n\tdefer lb.mu.RUnlock()\n\n\tif len(lb.servers) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no available servers\")\n\t}\n\n\tindex := atomic.AddInt64(&lb.currentIndex, 1)\n\tselected := lb.servers[(index-1)%int64(len(lb.servers))]\n\n\treturn selected, nil\n}\n\nfunc (lb *RoundRobinBalancer) Close() error {\n\tclose(lb.stopChan)\n\tlb.cancel()\n\tlb.wg.Wait()\n\tfmt.Println(\"[LB] Load balancer closed gracefully\")\n\treturn nil\n}\n\nfunc serversEqual(a, b []string) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nvar (\n\tmu       sync.Mutex\n\tstate    int\n)\n\nfunc mockResolver() []string {\n\tmu.Lock()\n\tdefer mu.Unlock()\n\n\tswitch state {\n\tcase 0:\n\t\treturn []string{\"server1:8001\", \"server2:8002\", \"server3:8003\"}\n\tcase 1:\n\t\treturn []string{\"server1:8001\", \"server2:8002\", \"server3:8003\", \"server4:8004\"}\n\tdefault:\n\t\treturn []string{\"server2:8002\", \"server3:8003\", \"server4:8004\", \"server5:8005\"}\n\t}\n}\n\nfunc simulateAddressUpdate(balancer *RoundRobinBalancer) {\n\ttime.Sleep(1 * time.Second)\n\tmu.Lock()\n\tstate = 1\n\tmu.Unlock()\n\tfmt.Println(\"[SIMULATOR] Triggered address update #1\")\n\n\ttime.Sleep(2 * time.Second)\n\tmu.Lock()\n\tstate = 2\n\tmu.Unlock()\n\tfmt.Println(\"[SIMULATOR] Triggered address update #2\")\n}\n\nfunc main() {\n\tfmt.Println(\"=== Round-Robin Load Balancer Demo ===\")\n\n\tbalancer := NewRoundRobinBalancer(mockResolver, 500*time.Millisecond)\n\n\terr := balancer.Start()\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to start balancer: %v\\n\", err)\n\t\treturn\n\t}\n\n\tvar wg sync.WaitGroup\n\trequestCount := 15\n\t\n\tgo simulateAddressUpdate(balancer)\n\n\tfor i := 0; i < requestCount; i++ {\n\t\twg.Add(1)\n\t\tgo func(id int) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Duration(id*50) * time.Millisecond)\n\n\t\t\tserver, err := balancer.Next()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"[Request %d] Error: %v\\n\", id, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Printf(\"[Request %d] Routed to: %s\\n\", id, server)\n\n\t\t\tprocessingTime := time.Duration(50+id%30) * time.Millisecond\n\t\t\ttime.Sleep(processingTime)\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tfmt.Println(\"\\n[MAIN] Shutting down load balancer...\")\n\terr = balancer.Close()\n\tif err != nil {\n\t\tfmt.Printf(\"Error closing balancer: %v\\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"[MAIN] Demo completed successfully\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}