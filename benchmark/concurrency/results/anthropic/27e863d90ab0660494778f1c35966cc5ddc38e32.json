{
    "task": "27e863d90ab0660494778f1c35966cc5ddc38e32.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype ReplicaID int\ntype RangeID int\ntype NodeID int\n\ntype Heartbeat struct {\n\tFrom     ReplicaID\n\tTo       ReplicaID\n\tRangeID  RangeID\n\tTimestamp time.Time\n}\n\ntype Transport struct {\n\tmu              sync.RWMutex\n\tfailureRate     float64\n\tsuccessCount    int64\n\tfailureCount    int64\n}\n\nfunc NewTransport(failureRate float64) *Transport {\n\treturn &Transport{\n\t\tfailureRate: failureRate,\n\t}\n}\n\nfunc (t *Transport) Send(from, to ReplicaID, rangeID RangeID) bool {\n\tif rand.Float64() < t.failureRate {\n\t\tatomic.AddInt64(&t.failureCount, 1)\n\t\treturn false\n\t}\n\tatomic.AddInt64(&t.successCount, 1)\n\treturn true\n}\n\nfunc (t *Transport) Stats() (int64, int64) {\n\treturn atomic.LoadInt64(&t.successCount), atomic.LoadInt64(&t.failureCount)\n}\n\ntype Replica struct {\n\tid           ReplicaID\n\trangeID      RangeID\n\tnodeID       NodeID\n\tmu           sync.Mutex\n\tunreachable  map[ReplicaID]bool\n\ttransport    *Transport\n\ttickCount    int64\n}\n\nfunc NewReplica(id ReplicaID, rangeID RangeID, nodeID NodeID, transport *Transport) *Replica {\n\treturn &Replica{\n\t\tid:          id,\n\t\trangeID:     rangeID,\n\t\tnodeID:      nodeID,\n\t\tunreachable: make(map[ReplicaID]bool),\n\t\ttransport:   transport,\n\t}\n}\n\nfunc (r *Replica) MarkUnreachable(replicaID ReplicaID) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.unreachable[replicaID] = true\n}\n\nfunc (r *Replica) GetUnreachable() []ReplicaID {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tresult := make([]ReplicaID, 0, len(r.unreachable))\n\tfor id := range r.unreachable {\n\t\tresult = append(result, id)\n\t}\n\treturn result\n}\n\nfunc (r *Replica) ClearUnreachable() {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.unreachable = make(map[ReplicaID]bool)\n}\n\nfunc (r *Replica) Tick() {\n\tatomic.AddInt64(&r.tickCount, 1)\n}\n\nfunc (r *Replica) GetTickCount() int64 {\n\treturn atomic.LoadInt64(&r.tickCount)\n}\n\ntype HeartbeatCoalescer struct {\n\tmu              sync.Mutex\n\tqueue           map[ReplicaID][]*Heartbeat\n\treplicas        map[ReplicaID]*Replica\n\ttransport       *Transport\n\tticker          *time.Ticker\n\tdone            chan bool\n\theartbeatCount  int64\n\tsentCount       int64\n\tfailedCount     int64\n\tunreachableOps  int64\n}\n\nfunc NewHeartbeatCoalescer(transport *Transport) *HeartbeatCoalescer {\n\treturn &HeartbeatCoalescer{\n\t\tqueue:    make(map[ReplicaID][]*Heartbeat),\n\t\treplicas: make(map[ReplicaID]*Replica),\n\t\ttransport: transport,\n\t\tticker:   time.NewTicker(100 * time.Millisecond),\n\t\tdone:     make(chan bool),\n\t}\n}\n\nfunc (hc *HeartbeatCoalescer) RegisterReplica(replica *Replica) {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\thc.replicas[replica.id] = replica\n}\n\nfunc (hc *HeartbeatCoalescer) QueueHeartbeat(hb *Heartbeat) {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\thc.queue[hb.To] = append(hc.queue[hb.To], hb)\n\tatomic.AddInt64(&hc.heartbeatCount, 1)\n}\n\nfunc (hc *HeartbeatCoalescer) Flush() {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\n\tfor toID, heartbeats := range hc.queue {\n\t\tif len(heartbeats) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\ttoReplica, exists := hc.replicas[toID]\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, hb := range heartbeats {\n\t\t\tif hc.transport.Send(hb.From, hb.To, hb.RangeID) {\n\t\t\t\tatomic.AddInt64(&hc.sentCount, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddInt64(&hc.failedCount, 1)\n\t\t\t\ttoReplica.MarkUnreachable(hb.From)\n\t\t\t\tatomic.AddInt64(&hc.unreachableOps, 1)\n\t\t\t}\n\t\t}\n\n\t\thc.queue[toID] = hc.queue[toID][:0]\n\t}\n}\n\nfunc (hc *HeartbeatCoalescer) Start() {\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-hc.done:\n\t\t\t\thc.Flush()\n\t\t\t\treturn\n\t\t\tcase <-hc.ticker.C:\n\t\t\t\thc.Flush()\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (hc *HeartbeatCoalescer) Stop() {\n\thc.ticker.Stop()\n\thc.done <- true\n\ttime.Sleep(10 * time.Millisecond)\n}\n\nfunc (hc *HeartbeatCoalescer) Stats() (int64, int64, int64, int64) {\n\treturn atomic.LoadInt64(&hc.heartbeatCount),\n\t\tatomic.LoadInt64(&hc.sentCount),\n\t\tatomic.LoadInt64(&hc.failedCount),\n\t\tatomic.LoadInt64(&hc.unreachableOps)\n}\n\ntype System struct {\n\treplicas   []*Replica\n\tcoalescer  *HeartbeatCoalescer\n\ttransport  *Transport\n\tmu         sync.RWMutex\n\tdone       chan bool\n}\n\nfunc NewSystem() *System {\n\ttransport := NewTransport(0.1)\n\tcoalescer := NewHeartbeatCoalescer(transport)\n\treturn &System{\n\t\treplicas:  make([]*Replica, 0),\n\t\tcoalescer: coalescer,\n\t\ttransport: transport,\n\t\tdone:      make(chan bool),\n\t}\n}\n\nfunc (s *System) AddReplica(id ReplicaID, rangeID RangeID, nodeID NodeID) *Replica {\n\treplica := NewReplica(id, rangeID, nodeID, s.transport)\n\ts.mu.Lock()\n\ts.replicas = append(s.replicas, replica)\n\ts.mu.Unlock()\n\ts.coalescer.RegisterReplica(replica)\n\treturn replica\n}\n\nfunc (s *System) Start() {\n\ts.coalescer.Start()\n\n\ts.mu.RLock()\n\treplicasCopy := make([]*Replica, len(s.replicas))\n\tcopy(replicasCopy, s.replicas)\n\ts.mu.RUnlock()\n\n\tfor _, replica := range replicasCopy {\n\t\tgo s.runReplica(replica)\n\t}\n\n\tgo s.printStats()\n}\n\nfunc (s *System) runReplica(replica *Replica) {\n\tticker := time.NewTicker(50 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\ts.mu.RLock()\n\tallReplicas := make([]*Replica, len(s.replicas))\n\tcopy(allReplicas, s.replicas)\n\ts.mu.RUnlock()\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\treplica.Tick()\n\n\t\t\tfor _, target := range allReplicas {\n\t\t\t\tif target.id == replica.id {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif target.rangeID != replica.rangeID {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\thb := &Heartbeat{\n\t\t\t\t\tFrom:      replica.id,\n\t\t\t\t\tTo:        target.id,\n\t\t\t\t\tRangeID:   replica.rangeID,\n\t\t\t\t\tTimestamp: time.Now(),\n\t\t\t\t}\n\t\t\t\ts.coalescer.QueueHeartbeat(hb)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *System) printStats() {\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\thbCount, sentCount, failedCount, unreachableOps := s.coalescer.Stats()\n\t\t\tsuccessCount, transportFailed := s.transport.Stats()\n\n\t\t\tfmt.Printf(\"Heartbeats Generated: %d | Sent: %d | Failed: %d | Transport Failures: %d | Unreachable Ops: %d\\n\",\n\t\t\t\thbCount, sentCount, failedCount, transportFailed, unreachableOps)\n\n\t\t\tfor _, replica := range s.replicas {\n\t\t\t\tunreachable := replica.GetUnreachable()\n\t\t\t\tif len(unreachable) > 0 {\n\t\t\t\t\tfmt.Printf(\"  Replica %d unreachable: %v\\n\", replica.id, unreachable)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *System) Stop() {\n\ts.done <- true\n\ts.done <- true\n\ts.coalescer.Stop()\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\n\tsystem := NewSystem()\n\n\treplica1 := system.AddReplica(1, 1, 1)\n\treplica2 := system.AddReplica(2, 1, 2)\n\treplica3 := system.AddReplica(3, 1, 1)\n\treplica4 := system.AddReplica(4, 2, 2)\n\n\tsystem.Start()\n\n\ttime.Sleep(5 * time.Second)\n\n\tsystem.Stop()\n\n\tfmt.Println(\"\\n=== Final Statistics ===\")\n\thbCount, sentCount, failedCount, unreachableOps := system.coalescer.Stats()\n\tsuccessCount, transportFailed := system.transport.Stats()\n\n\tfmt.Printf(\"Total Heartbeats Generated: %d\\n\", hbCount)\n\tfmt.Printf(\"Total Heartbeats Sent Successfully: %d\\n\", sentCount)\n\tfmt.Printf(\"Total Heartbeats Failed: %d\\n\", failedCount)\n\tfmt.Printf(\"Transport Layer Failures: %d\\n\", transportFailed)\n\tfmt.Printf(\"Unreachable Replica Operations: %d\\n\", unreachableOps)\n\n\tfmt.Println(\"\\nFinal Unreachable Replicas:\")\n\tfor _, replica := range []*Replica{replica1, replica2, replica3, replica4} {\n\t\tunreachable := replica.GetUnreachable()\n\t\tif len(unreachable) > 0 {\n\t\t\tfmt.Printf(\"  Replica %d: %v\\n\", replica.id, unreachable)\n\t\t}\n\t}\n\n\tfmt.Printf(\"\\nReplica Tick Counts:\\n\")\n\tfor _, replica := range []*Replica{replica1, replica2, replica3, replica4} {\n\t\tfmt.Printf(\"  Replica %d: %d ticks\\n\", replica.id, replica.GetTickCount())\n\t}\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "go build -race",
                    "error": "# command-line-arguments\n./main.go:278:4: declared and not used: successCount\n./main.go:317:2: declared and not used: successCount"
                },
                {
                    "verifier": "gosec",
                    "error": "Results:\n\nGolang errors in file: []:\n\n  > [line 0 : column 0] - # command-line-arguments\n./main.go:278:4: declared and not used: successCount\n./main.go:317:2: declared and not used: successCount\n\n\nGolang errors in file: [/tmp/go_synthesis_tpb_ohbl/main.go]:\n\n  > [line 278 : column 4] - declared and not used: successCount\n\n  > [line 317 : column 2] - declared and not used: successCount\n\n\n\n[\u001b[97;41m/tmp/go_synthesis_tpb_ohbl/main.go:36\u001b[0m] - G404 (CWE-338): Use of weak random number generator (math/rand or math/rand/v2 instead of crypto/rand) (Confidence: MEDIUM, Severity: HIGH)\n    35: func (t *Transport) Send(from, to ReplicaID, rangeID RangeID) bool {\n  > 36: \tif rand.Float64() < t.failureRate {\n    37: \t\tatomic.AddInt64(&t.failureCount, 1)\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 337\n  Nosec  : 0\n  Issues : \u001b[1;31m1\u001b[0m\n\n[gosec] 2025/12/01 13:41:46 Including rules: default\n[gosec] 2025/12/01 13:41:46 Excluding rules: default\n[gosec] 2025/12/01 13:41:46 Including analyzers: default\n[gosec] 2025/12/01 13:41:46 Excluding analyzers: default\n[gosec] 2025/12/01 13:41:46 Import directory: /tmp/go_synthesis_tpb_ohbl\n[gosec] 2025/12/01 13:41:47 Checking package: main\n[gosec] 2025/12/01 13:41:47 Checking file: /tmp/go_synthesis_tpb_ohbl/main.go"
                },
                {
                    "verifier": "govulncheck",
                    "error": "govulncheck: loading packages: \nThere are errors with the provided package patterns:\n\n/tmp/go_synthesis_tpb_ohbl/main.go:278:4: declared and not used: successCount\n/tmp/go_synthesis_tpb_ohbl/main.go:317:2: declared and not used: successCount\n\nFor details on package patterns, see https://pkg.go.dev/cmd/go#hdr-Package_lists_and_patterns."
                },
                {
                    "verifier": "errcheck",
                    "error": "error: failed to check packages: errors while loading package command-line-arguments: [-: # command-line-arguments\n./main.go:278:4: declared and not used: successCount\n./main.go:317:2: declared and not used: successCount /tmp/go_synthesis_tpb_ohbl/main.go:278:4: declared and not used: successCount /tmp/go_synthesis_tpb_ohbl/main.go:317:2: declared and not used: successCount]"
                },
                {
                    "verifier": "go-errorlint",
                    "error": "-: # command-line-arguments\n./main.go:278:4: declared and not used: successCount\n./main.go:317:2: declared and not used: successCount\n/tmp/go_synthesis_tpb_ohbl/main.go:278:4: declared and not used: successCount\n/tmp/go_synthesis_tpb_ohbl/main.go:317:2: declared and not used: successCount\nerrorlint: analysis skipped due to errors in package"
                },
                {
                    "verifier": "staticcheck",
                    "error": "-: # command-line-arguments\n./main.go:278:4: declared and not used: successCount\n./main.go:317:2: declared and not used: successCount (compile)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype ReplicaID int\ntype RangeID int\ntype NodeID int\n\ntype Heartbeat struct {\n\tFrom      ReplicaID\n\tTo        ReplicaID\n\tRangeID   RangeID\n\tTimestamp time.Time\n}\n\ntype Transport struct {\n\tmu           sync.RWMutex\n\tfailureRate  float64\n\tsuccessCount int64\n\tfailureCount int64\n}\n\nfunc NewTransport(failureRate float64) *Transport {\n\treturn &Transport{\n\t\tfailureRate: failureRate,\n\t}\n}\n\nfunc (t *Transport) Send(from, to ReplicaID, rangeID RangeID) bool {\n\tb := make([]byte, 8)\n\tif _, err := io.ReadFull(rand.Reader, b); err != nil {\n\t\treturn false\n\t}\n\n\tvar randValue float64\n\tfor i := 0; i < 8; i++ {\n\t\trandValue = randValue*256 + float64(b[i])\n\t}\n\trandValue = randValue / (256 * 256 * 256 * 256 * 256 * 256 * 256 * 256)\n\n\tif randValue < t.failureRate {\n\t\tatomic.AddInt64(&t.failureCount, 1)\n\t\treturn false\n\t}\n\tatomic.AddInt64(&t.successCount, 1)\n\treturn true\n}\n\nfunc (t *Transport) Stats() (int64, int64) {\n\treturn atomic.LoadInt64(&t.successCount), atomic.LoadInt64(&t.failureCount)\n}\n\ntype Replica struct {\n\tid          ReplicaID\n\trangeID     RangeID\n\tnodeID      NodeID\n\tmu          sync.Mutex\n\tunreachable map[ReplicaID]bool\n\ttransport   *Transport\n\ttickCount   int64\n}\n\nfunc NewReplica(id ReplicaID, rangeID RangeID, nodeID NodeID, transport *Transport) *Replica {\n\treturn &Replica{\n\t\tid:          id,\n\t\trangeID:     rangeID,\n\t\tnodeID:      nodeID,\n\t\tunreachable: make(map[ReplicaID]bool),\n\t\ttransport:   transport,\n\t}\n}\n\nfunc (r *Replica) MarkUnreachable(replicaID ReplicaID) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.unreachable[replicaID] = true\n}\n\nfunc (r *Replica) GetUnreachable() []ReplicaID {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tresult := make([]ReplicaID, 0, len(r.unreachable))\n\tfor id := range r.unreachable {\n\t\tresult = append(result, id)\n\t}\n\treturn result\n}\n\nfunc (r *Replica) ClearUnreachable() {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.unreachable = make(map[ReplicaID]bool)\n}\n\nfunc (r *Replica) Tick() {\n\tatomic.AddInt64(&r.tickCount, 1)\n}\n\nfunc (r *Replica) GetTickCount() int64 {\n\treturn atomic.LoadInt64(&r.tickCount)\n}\n\ntype HeartbeatCoalescer struct {\n\tmu             sync.Mutex\n\tqueue          map[ReplicaID][]*Heartbeat\n\treplicas       map[ReplicaID]*Replica\n\ttransport      *Transport\n\tticker         *time.Ticker\n\tdone           chan bool\n\theartbeatCount int64\n\tsentCount      int64\n\tfailedCount    int64\n\tunreachableOps int64\n}\n\nfunc NewHeartbeatCoalescer(transport *Transport) *HeartbeatCoalescer {\n\treturn &HeartbeatCoalescer{\n\t\tqueue:     make(map[ReplicaID][]*Heartbeat),\n\t\treplicas:  make(map[ReplicaID]*Replica),\n\t\ttransport: transport,\n\t\tticker:    time.NewTicker(100 * time.Millisecond),\n\t\tdone:      make(chan bool),\n\t}\n}\n\nfunc (hc *HeartbeatCoalescer) RegisterReplica(replica *Replica) {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\thc.replicas[replica.id] = replica\n}\n\nfunc (hc *HeartbeatCoalescer) QueueHeartbeat(hb *Heartbeat) {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\thc.queue[hb.To] = append(hc.queue[hb.To], hb)\n\tatomic.AddInt64(&hc.heartbeatCount, 1)\n}\n\nfunc (hc *HeartbeatCoalescer) Flush() {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\n\tfor toID, heartbeats := range hc.queue {\n\t\tif len(heartbeats) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\ttoReplica, exists := hc.replicas[toID]\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, hb := range heartbeats {\n\t\t\tif hc.transport.Send(hb.From, hb.To, hb.RangeID) {\n\t\t\t\tatomic.AddInt64(&hc.sentCount, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddInt64(&hc.failedCount, 1)\n\t\t\t\ttoReplica.MarkUnreachable(hb.From)\n\t\t\t\tatomic.AddInt64(&hc.unreachableOps, 1)\n\t\t\t}\n\t\t}\n\n\t\thc.queue[toID] = hc.queue[toID][:0]\n\t}\n}\n\nfunc (hc *HeartbeatCoalescer) Start() {\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-hc.done:\n\t\t\t\thc.Flush()\n\t\t\t\treturn\n\t\t\tcase <-hc.ticker.C:\n\t\t\t\thc.Flush()\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (hc *HeartbeatCoalescer) Stop() {\n\thc.ticker.Stop()\n\thc.done <- true\n\ttime.Sleep(10 * time.Millisecond)\n}\n\nfunc (hc *HeartbeatCoalescer) Stats() (int64, int64, int64, int64) {\n\treturn atomic.LoadInt64(&hc.heartbeatCount),\n\t\tatomic.LoadInt64(&hc.sentCount),\n\t\tatomic.LoadInt64(&hc.failedCount),\n\t\tatomic.LoadInt64(&hc.unreachableOps)\n}\n\ntype System struct {\n\treplicas  []*Replica\n\tcoalescer *HeartbeatCoalescer\n\ttransport *Transport\n\tmu        sync.RWMutex\n\tdone      chan bool\n}\n\nfunc NewSystem() *System {\n\ttransport := NewTransport(0.1)\n\tcoalescer := NewHeartbeatCoalescer(transport)\n\treturn &System{\n\t\treplicas:  make([]*Replica, 0),\n\t\tcoalescer: coalescer,\n\t\ttransport: transport,\n\t\tdone:      make(chan bool),\n\t}\n}\n\nfunc (s *System) AddReplica(id ReplicaID, rangeID RangeID, nodeID NodeID) *Replica {\n\treplica := NewReplica(id, rangeID, nodeID, s.transport)\n\ts.mu.Lock()\n\ts.replicas = append(s.replicas, replica)\n\ts.mu.Unlock()\n\ts.coalescer.RegisterReplica(replica)\n\treturn replica\n}\n\nfunc (s *System) Start() {\n\ts.coalescer.Start()\n\n\ts.mu.RLock()\n\treplicasCopy := make([]*Replica, len(s.replicas))\n\tcopy(replicasCopy, s.replicas)\n\ts.mu.RUnlock()\n\n\tfor _, replica := range replicasCopy {\n\t\tgo s.runReplica(replica)\n\t}\n\n\tgo s.printStats()\n}\n\nfunc (s *System) runReplica(replica *Replica) {\n\tticker := time.NewTicker(50 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\ts.mu.RLock()\n\tallReplicas := make([]*Replica, len(s.replicas))\n\tcopy(allReplicas, s.replicas)\n\ts.mu.RUnlock()\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\treplica.Tick()\n\n\t\t\tfor _, target := range allReplicas {\n\t\t\t\tif target.id == replica.id {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif target.rangeID != replica.rangeID {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\thb := &Heartbeat{\n\t\t\t\t\tFrom:      replica.id,\n\t\t\t\t\tTo:        target.id,\n\t\t\t\t\tRangeID:   replica.rangeID,\n\t\t\t\t\tTimestamp: time.Now(),\n\t\t\t\t}\n\t\t\t\ts.coalescer.QueueHeartbeat(hb)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *System) printStats() {\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\thbCount, sentCount, failedCount, unreachableOps := s.coalescer.Stats()\n\t\t\t_, transportFailed := s.transport.Stats()\n\n\t\t\tfmt.Printf(\"Heartbeats Generated: %d | Sent: %d | Failed: %d | Transport Failures: %d | Unreachable Ops: %d\\n\",\n\t\t\t\thbCount, sentCount, failedCount, transportFailed, unreachableOps)\n\n\t\t\tfor _, replica := range s.replicas {\n\t\t\t\tunreachable := replica.GetUnreachable()\n\t\t\t\tif len(unreachable) > 0 {\n\t\t\t\t\tfmt.Printf(\"  Replica %d unreachable: %v\\n\", replica.id, unreachable)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *System) Stop() {\n\ts.done <- true\n\ts.done <- true\n\ts.coalescer.Stop()\n}\n\nfunc main() {\n\tsystem := NewSystem()\n\n\treplica1 := system.AddReplica(1, 1, 1)\n\treplica2 := system.AddReplica(2, 1, 2)\n\treplica3 := system.AddReplica(3, 1, 1)\n\treplica4 := system.AddReplica(4, 2, 2)\n\n\tsystem.Start()\n\n\ttime.Sleep(5 * time.Second)\n\n\tsystem.Stop()\n\n\tfmt.Println(\"\\n=== Final Statistics ===\")\n\thbCount, sentCount, failedCount, unreachableOps := system.coalescer.Stats()\n\t_, transportFailed := system.transport.Stats()\n\n\tfmt.Printf(\"Total Heartbeats Generated: %d\\n\", hbCount)\n\tfmt.Printf(\"Total Heartbeats Sent Successfully: %d\\n\", sentCount)\n\tfmt.Printf(\"Total Heartbeats Failed: %d\\n\", failedCount)\n\tfmt.Printf(\"Transport Layer Failures: %d\\n\", transportFailed)\n\tfmt.Printf(\"Unreachable Replica Operations: %d\\n\", unreachableOps)\n\n\tfmt.Println(\"\\nFinal Unreachable Replicas:\")\n\tfor _, replica := range []*Replica{replica1, replica2, replica3, replica4} {\n\t\tunreachable := replica.GetUnreachable()\n\t\tif len(unreachable) > 0 {\n\t\t\tfmt.Printf(\"  Replica %d: %v\\n\", replica.id, unreachable)\n\t\t}\n\t}\n\n\tfmt.Printf(\"\\nReplica Tick Counts:\\n\")\n\tfor _, replica := range []*Replica{replica1, replica2, replica3, replica4} {\n\t\tfmt.Printf(\"  Replica %d: %d ticks\\n\", replica.id, replica.GetTickCount())\n\t}\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "staticcheck",
                    "error": "main.go:24:2: field mu is unused (U1000)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype ReplicaID int\ntype RangeID int\ntype NodeID int\n\ntype Heartbeat struct {\n\tFrom      ReplicaID\n\tTo        ReplicaID\n\tRangeID   RangeID\n\tTimestamp time.Time\n}\n\ntype Transport struct {\n\tfailureRate  float64\n\tsuccessCount int64\n\tfailureCount int64\n}\n\nfunc NewTransport(failureRate float64) *Transport {\n\treturn &Transport{\n\t\tfailureRate: failureRate,\n\t}\n}\n\nfunc (t *Transport) Send(from, to ReplicaID, rangeID RangeID) bool {\n\tb := make([]byte, 8)\n\tif _, err := io.ReadFull(rand.Reader, b); err != nil {\n\t\treturn false\n\t}\n\n\tvar randValue float64\n\tfor i := 0; i < 8; i++ {\n\t\trandValue = randValue*256 + float64(b[i])\n\t}\n\trandValue = randValue / (256 * 256 * 256 * 256 * 256 * 256 * 256 * 256)\n\n\tif randValue < t.failureRate {\n\t\tatomic.AddInt64(&t.failureCount, 1)\n\t\treturn false\n\t}\n\tatomic.AddInt64(&t.successCount, 1)\n\treturn true\n}\n\nfunc (t *Transport) Stats() (int64, int64) {\n\treturn atomic.LoadInt64(&t.successCount), atomic.LoadInt64(&t.failureCount)\n}\n\ntype Replica struct {\n\tid          ReplicaID\n\trangeID     RangeID\n\tnodeID      NodeID\n\tmu          sync.Mutex\n\tunreachable map[ReplicaID]bool\n\ttransport   *Transport\n\ttickCount   int64\n}\n\nfunc NewReplica(id ReplicaID, rangeID RangeID, nodeID NodeID, transport *Transport) *Replica {\n\treturn &Replica{\n\t\tid:          id,\n\t\trangeID:     rangeID,\n\t\tnodeID:      nodeID,\n\t\tunreachable: make(map[ReplicaID]bool),\n\t\ttransport:   transport,\n\t}\n}\n\nfunc (r *Replica) MarkUnreachable(replicaID ReplicaID) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.unreachable[replicaID] = true\n}\n\nfunc (r *Replica) GetUnreachable() []ReplicaID {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tresult := make([]ReplicaID, 0, len(r.unreachable))\n\tfor id := range r.unreachable {\n\t\tresult = append(result, id)\n\t}\n\treturn result\n}\n\nfunc (r *Replica) ClearUnreachable() {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.unreachable = make(map[ReplicaID]bool)\n}\n\nfunc (r *Replica) Tick() {\n\tatomic.AddInt64(&r.tickCount, 1)\n}\n\nfunc (r *Replica) GetTickCount() int64 {\n\treturn atomic.LoadInt64(&r.tickCount)\n}\n\ntype HeartbeatCoalescer struct {\n\tmu             sync.Mutex\n\tqueue          map[ReplicaID][]*Heartbeat\n\treplicas       map[ReplicaID]*Replica\n\ttransport      *Transport\n\tticker         *time.Ticker\n\tdone           chan bool\n\theartbeatCount int64\n\tsentCount      int64\n\tfailedCount    int64\n\tunreachableOps int64\n}\n\nfunc NewHeartbeatCoalescer(transport *Transport) *HeartbeatCoalescer {\n\treturn &HeartbeatCoalescer{\n\t\tqueue:     make(map[ReplicaID][]*Heartbeat),\n\t\treplicas:  make(map[ReplicaID]*Replica),\n\t\ttransport: transport,\n\t\tticker:    time.NewTicker(100 * time.Millisecond),\n\t\tdone:      make(chan bool),\n\t}\n}\n\nfunc (hc *HeartbeatCoalescer) RegisterReplica(replica *Replica) {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\thc.replicas[replica.id] = replica\n}\n\nfunc (hc *HeartbeatCoalescer) QueueHeartbeat(hb *Heartbeat) {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\thc.queue[hb.To] = append(hc.queue[hb.To], hb)\n\tatomic.AddInt64(&hc.heartbeatCount, 1)\n}\n\nfunc (hc *HeartbeatCoalescer) Flush() {\n\thc.mu.Lock()\n\tdefer hc.mu.Unlock()\n\n\tfor toID, heartbeats := range hc.queue {\n\t\tif len(heartbeats) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\ttoReplica, exists := hc.replicas[toID]\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, hb := range heartbeats {\n\t\t\tif hc.transport.Send(hb.From, hb.To, hb.RangeID) {\n\t\t\t\tatomic.AddInt64(&hc.sentCount, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddInt64(&hc.failedCount, 1)\n\t\t\t\ttoReplica.MarkUnreachable(hb.From)\n\t\t\t\tatomic.AddInt64(&hc.unreachableOps, 1)\n\t\t\t}\n\t\t}\n\n\t\thc.queue[toID] = hc.queue[toID][:0]\n\t}\n}\n\nfunc (hc *HeartbeatCoalescer) Start() {\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-hc.done:\n\t\t\t\thc.Flush()\n\t\t\t\treturn\n\t\t\tcase <-hc.ticker.C:\n\t\t\t\thc.Flush()\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc (hc *HeartbeatCoalescer) Stop() {\n\thc.ticker.Stop()\n\thc.done <- true\n\ttime.Sleep(10 * time.Millisecond)\n}\n\nfunc (hc *HeartbeatCoalescer) Stats() (int64, int64, int64, int64) {\n\treturn atomic.LoadInt64(&hc.heartbeatCount),\n\t\tatomic.LoadInt64(&hc.sentCount),\n\t\tatomic.LoadInt64(&hc.failedCount),\n\t\tatomic.LoadInt64(&hc.unreachableOps)\n}\n\ntype System struct {\n\treplicas  []*Replica\n\tcoalescer *HeartbeatCoalescer\n\ttransport *Transport\n\tmu        sync.RWMutex\n\tdone      chan bool\n}\n\nfunc NewSystem() *System {\n\ttransport := NewTransport(0.1)\n\tcoalescer := NewHeartbeatCoalescer(transport)\n\treturn &System{\n\t\treplicas:  make([]*Replica, 0),\n\t\tcoalescer: coalescer,\n\t\ttransport: transport,\n\t\tdone:      make(chan bool),\n\t}\n}\n\nfunc (s *System) AddReplica(id ReplicaID, rangeID RangeID, nodeID NodeID) *Replica {\n\treplica := NewReplica(id, rangeID, nodeID, s.transport)\n\ts.mu.Lock()\n\ts.replicas = append(s.replicas, replica)\n\ts.mu.Unlock()\n\ts.coalescer.RegisterReplica(replica)\n\treturn replica\n}\n\nfunc (s *System) Start() {\n\ts.coalescer.Start()\n\n\ts.mu.RLock()\n\treplicasCopy := make([]*Replica, len(s.replicas))\n\tcopy(replicasCopy, s.replicas)\n\ts.mu.RUnlock()\n\n\tfor _, replica := range replicasCopy {\n\t\tgo s.runReplica(replica)\n\t}\n\n\tgo s.printStats()\n}\n\nfunc (s *System) runReplica(replica *Replica) {\n\tticker := time.NewTicker(50 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\ts.mu.RLock()\n\tallReplicas := make([]*Replica, len(s.replicas))\n\tcopy(allReplicas, s.replicas)\n\ts.mu.RUnlock()\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\treplica.Tick()\n\n\t\t\tfor _, target := range allReplicas {\n\t\t\t\tif target.id == replica.id {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif target.rangeID != replica.rangeID {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\thb := &Heartbeat{\n\t\t\t\t\tFrom:      replica.id,\n\t\t\t\t\tTo:        target.id,\n\t\t\t\t\tRangeID:   replica.rangeID,\n\t\t\t\t\tTimestamp: time.Now(),\n\t\t\t\t}\n\t\t\t\ts.coalescer.QueueHeartbeat(hb)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *System) printStats() {\n\tticker := time.NewTicker(1 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.done:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\thbCount, sentCount, failedCount, unreachableOps := s.coalescer.Stats()\n\t\t\t_, transportFailed := s.transport.Stats()\n\n\t\t\tfmt.Printf(\"Heartbeats Generated: %d | Sent: %d | Failed: %d | Transport Failures: %d | Unreachable Ops: %d\\n\",\n\t\t\t\thbCount, sentCount, failedCount, transportFailed, unreachableOps)\n\n\t\t\ts.mu.RLock()\n\t\t\tfor _, replica := range s.replicas {\n\t\t\t\tunreachable := replica.GetUnreachable()\n\t\t\t\tif len(unreachable) > 0 {\n\t\t\t\t\tfmt.Printf(\"  Replica %d unreachable: %v\\n\", replica.id, unreachable)\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.mu.RUnlock()\n\t\t}\n\t}\n}\n\nfunc (s *System) Stop() {\n\ts.done <- true\n\ts.done <- true\n\ts.coalescer.Stop()\n}\n\nfunc main() {\n\tsystem := NewSystem()\n\n\treplica1 := system.AddReplica(1, 1, 1)\n\treplica2 := system.AddReplica(2, 1, 2)\n\treplica3 := system.AddReplica(3, 1, 1)\n\treplica4 := system.AddReplica(4, 2, 2)\n\n\tsystem.Start()\n\n\ttime.Sleep(5 * time.Second)\n\n\tsystem.Stop()\n\n\tfmt.Println(\"\\n=== Final Statistics ===\")\n\thbCount, sentCount, failedCount, unreachableOps := system.coalescer.Stats()\n\t_, transportFailed := system.transport.Stats()\n\n\tfmt.Printf(\"Total Heartbeats Generated: %d\\n\", hbCount)\n\tfmt.Printf(\"Total Heartbeats Sent Successfully: %d\\n\", sentCount)\n\tfmt.Printf(\"Total Heartbeats Failed: %d\\n\", failedCount)\n\tfmt.Printf(\"Transport Layer Failures: %d\\n\", transportFailed)\n\tfmt.Printf(\"Unreachable Replica Operations: %d\\n\", unreachableOps)\n\n\tfmt.Println(\"\\nFinal Unreachable Replicas:\")\n\tfor _, replica := range []*Replica{replica1, replica2, replica3, replica4} {\n\t\tunreachable := replica.GetUnreachable()\n\t\tif len(unreachable) > 0 {\n\t\t\tfmt.Printf(\"  Replica %d: %v\\n\", replica.id, unreachable)\n\t\t}\n\t}\n\n\tfmt.Printf(\"\\nReplica Tick Counts:\\n\")\n\tfor _, replica := range []*Replica{replica1, replica2, replica3, replica4} {\n\t\tfmt.Printf(\"  Replica %d: %d ticks\\n\", replica.id, replica.GetTickCount())\n\t}\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}