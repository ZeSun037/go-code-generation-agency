{
    "task": "484b3ebb4ab56d3decc8240d599718bdbefcf7eb.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// QuotaPool manages a thread-safe quota system with acquire and release operations\ntype QuotaPool struct {\n\tmu       sync.Mutex\n\tquota    int64\n\tcapacity int64\n\tcond     *sync.Cond\n}\n\n// NewQuotaPool creates a new quota pool with initial capacity\nfunc NewQuotaPool(capacity int64) *QuotaPool {\n\tqp := &QuotaPool{\n\t\tquota:    capacity,\n\t\tcapacity: capacity,\n\t}\n\tqp.cond = sync.NewCond(&qp.mu)\n\treturn qp\n}\n\n// Acquire attempts to acquire the specified amount of quota, blocking if unavailable\nfunc (qp *QuotaPool) Acquire(amount int64) bool {\n\tqp.mu.Lock()\n\tdefer qp.mu.Unlock()\n\n\tfor qp.quota < amount {\n\t\tqp.cond.Wait()\n\t}\n\n\tqp.quota -= amount\n\treturn true\n}\n\n// AcquireNonBlocking attempts to acquire quota without blocking\nfunc (qp *QuotaPool) AcquireNonBlocking(amount int64) bool {\n\tqp.mu.Lock()\n\tdefer qp.mu.Unlock()\n\n\tif qp.quota < amount {\n\t\treturn false\n\t}\n\n\tqp.quota -= amount\n\treturn true\n}\n\n// Release adds quota back to the pool\nfunc (qp *QuotaPool) Release(amount int64) {\n\tqp.mu.Lock()\n\tdefer qp.mu.Unlock()\n\n\tqp.quota += amount\n\tif qp.quota > qp.capacity {\n\t\tqp.quota = qp.capacity\n\t}\n\tqp.cond.Signal()\n}\n\n// GetAvailable returns the current available quota\nfunc (qp *QuotaPool) GetAvailable() int64 {\n\tqp.mu.Lock()\n\tdefer qp.mu.Unlock()\n\treturn qp.quota\n}\n\n// MessageSender manages message sending with quota controls\ntype MessageSender struct {\n\ttransportQuota *QuotaPool\n\tstreamQuota    *QuotaPool\n\tmaxMessageSize int64\n\tmu             sync.Mutex\n\tsentCount      int64\n\tfailedCount    int64\n}\n\n// NewMessageSender creates a new message sender with specified quotas\nfunc NewMessageSender(transportQuota, streamQuota *QuotaPool, maxMessageSize int64) *MessageSender {\n\treturn &MessageSender{\n\t\ttransportQuota: transportQuota,\n\t\tstreamQuota:    streamQuota,\n\t\tmaxMessageSize: maxMessageSize,\n\t}\n}\n\n// SendMessage attempts to send a message with the specified size\nfunc (ms *MessageSender) SendMessage(messageSize int64) error {\n\t// Check if message exceeds size limit first\n\tif messageSize > ms.maxMessageSize {\n\t\treturn fmt.Errorf(\"message too large: %d > %d\", messageSize, ms.maxMessageSize)\n\t}\n\n\t// Acquire transport quota\n\tif !ms.transportQuota.Acquire(messageSize) {\n\t\treturn fmt.Errorf(\"failed to acquire transport quota\")\n\t}\n\n\t// Acquire stream quota\n\tif !ms.streamQuota.Acquire(messageSize) {\n\t\tms.transportQuota.Release(messageSize)\n\t\treturn fmt.Errorf(\"failed to acquire stream quota\")\n\t}\n\n\t// Simulate sending and then release quotas\n\ttime.Sleep(time.Microsecond)\n\n\tms.transportQuota.Release(messageSize)\n\tms.streamQuota.Release(messageSize)\n\n\tms.mu.Lock()\n\tms.sentCount++\n\tms.mu.Unlock()\n\n\treturn nil\n}\n\n// GetStats returns send statistics\nfunc (ms *MessageSender) GetStats() (sent, failed int64) {\n\tms.mu.Lock()\n\tdefer ms.mu.Unlock()\n\treturn ms.sentCount, ms.failedCount\n}\n\n// RecordFailure records a failed send attempt\nfunc (ms *MessageSender) RecordFailure() {\n\tms.mu.Lock()\n\tdefer ms.mu.Unlock()\n\tms.failedCount++\n}\n\nfunc main() {\n\tconst (\n\t\tquotaCapacity   = int64(65536)\n\t\tmaxMessageSize  = int64(1024)\n\t\tmessageSize     = int64(10240) // 10KB - exceeds limit\n\t\tnumGoroutines   = 10\n\t\tmessagesPerGo   = 100\n\t\ttotalMessages   = numGoroutines * messagesPerGo\n\t)\n\n\t// Create quota pools\n\ttransportQuota := NewQuotaPool(quotaCapacity)\n\tstreamQuota := NewQuotaPool(quotaCapacity)\n\n\t// Create message sender\n\tsender := NewMessageSender(transportQuota, streamQuota, maxMessageSize)\n\n\t// WaitGroup to synchronize all goroutines\n\tvar wg sync.WaitGroup\n\twg.Add(numGoroutines)\n\n\t// Launch concurrent goroutines\n\tfor i := 0; i < numGoroutines; i++ {\n\t\tgo func(goroutineID int) {\n\t\t\tdefer wg.Done()\n\n\t\t\tfor j := 0; j < messagesPerGo; j++ {\n\t\t\t\terr := sender.SendMessage(messageSize)\n\t\t\t\tif err != nil {\n\t\t\t\t\tsender.RecordFailure()\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\t// Wait for all goroutines to complete with timeout\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(done)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\t// All goroutines completed successfully\n\tcase <-time.After(30 * time.Second):\n\t\tfmt.Println(\"Timeout waiting for goroutines to complete\")\n\t\treturn\n\t}\n\n\tsent, failed := sender.GetStats()\n\n\tfmt.Printf(\"All sends completed successfully\\n\")\n\tfmt.Printf(\"Total messages attempted: %d\\n\", totalMessages)\n\tfmt.Printf(\"Successfully sent: %d\\n\", sent)\n\tfmt.Printf(\"Failed to send: %d\\n\", failed)\n\tfmt.Printf(\"Transport quota available: %d / %d bytes\\n\", transportQuota.GetAvailable(), quotaCapacity)\n\tfmt.Printf(\"Stream quota available: %d / %d bytes\\n\", streamQuota.GetAvailable(), quotaCapacity)\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}