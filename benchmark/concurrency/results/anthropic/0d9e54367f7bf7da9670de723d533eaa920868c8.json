{
    "task": "0d9e54367f7bf7da9670de723d533eaa920868c8.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Container represents a managed container with lifecycle methods\ntype Container struct {\n\tid       string\n\trunning  bool\n\tstuck    bool\n\tmu       sync.Mutex\n\tstopCh   chan struct{}\n\tdoneCh   chan struct{}\n\twg       sync.WaitGroup\n}\n\n// NewContainer creates a new container with the given id\nfunc NewContainer(id string, stuck bool) *Container {\n\treturn &Container{\n\t\tid:     id,\n\t\tstuck:  stuck,\n\t\tstopCh: make(chan struct{}),\n\t\tdoneCh: make(chan struct{}),\n\t}\n}\n\n// Start begins the container process\nfunc (c *Container) Start() error {\n\tc.mu.Lock()\n\tif c.running {\n\t\tc.mu.Unlock()\n\t\treturn fmt.Errorf(\"container %s is already running\", c.id)\n\t}\n\tc.running = true\n\tc.mu.Unlock()\n\n\tc.wg.Add(1)\n\tgo c.process()\n\treturn nil\n}\n\n// process simulates the container's long-running process\nfunc (c *Container) process() {\n\tdefer c.wg.Done()\n\tdefer close(c.doneCh)\n\n\tif c.stuck {\n\t\t// Stuck process: ignore stop signals and run indefinitely\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-c.stopCh:\n\t\t\t\t// Intentionally ignore the stop signal\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Well-behaved process: exit gracefully when stopped\n\tfor {\n\t\tselect {\n\t\tcase <-c.stopCh:\n\t\t\tc.mu.Lock()\n\t\t\tc.running = false\n\t\t\tc.mu.Unlock()\n\t\t\treturn\n\t\tdefault:\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t}\n\t}\n}\n\n// Stop gracefully stops the container with a timeout mechanism\nfunc (c *Container) Stop() error {\n\tc.mu.Lock()\n\tif !c.running {\n\t\tc.mu.Unlock()\n\t\treturn fmt.Errorf(\"container %s is not running\", c.id)\n\t}\n\tc.mu.Unlock()\n\n\t// Send termination signal\n\tselect {\n\tcase c.stopCh <- struct{}{}:\n\tdefault:\n\t}\n\n\t// Wait up to 10 seconds for graceful shutdown\n\ttimer := time.NewTimer(10 * time.Second)\n\tdefer timer.Stop()\n\n\tselect {\n\tcase <-c.doneCh:\n\t\tc.mu.Lock()\n\t\tc.running = false\n\t\tc.mu.Unlock()\n\t\treturn nil\n\tcase <-timer.C:\n\t\t// Graceful shutdown failed, force kill\n\t\treturn c.Kill()\n\t}\n}\n\n// Kill forcefully terminates the container immediately\nfunc (c *Container) Kill() error {\n\tc.mu.Lock()\n\tif !c.running {\n\t\tc.mu.Unlock()\n\t\treturn fmt.Errorf(\"container %s is not running\", c.id)\n\t}\n\tc.running = false\n\tc.mu.Unlock()\n\n\t// Close stopCh to signal all goroutines\n\tselect {\n\tcase <-c.doneCh:\n\t\t// Already done\n\tdefault:\n\t\tclose(c.stopCh)\n\t}\n\n\treturn nil\n}\n\n// WaitTimeout waits for the container to finish with a timeout\nfunc (c *Container) WaitTimeout(timeout time.Duration) error {\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\tselect {\n\tcase <-c.doneCh:\n\t\treturn nil\n\tcase <-ctx.Done():\n\t\treturn fmt.Errorf(\"container %s: wait timeout exceeded\", c.id)\n\t}\n}\n\n// IsRunning returns whether the container is currently running\nfunc (c *Container) IsRunning() bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.running\n}\n\n// GetID returns the container's unique identifier\nfunc (c *Container) GetID() string {\n\treturn c.id\n}\n\n// ContainerManager manages multiple containers\ntype ContainerManager struct {\n\tcontainers map[string]*Container\n\tmu         sync.RWMutex\n}\n\n// NewContainerManager creates a new container manager\nfunc NewContainerManager() *ContainerManager {\n\treturn &ContainerManager{\n\t\tcontainers: make(map[string]*Container),\n\t}\n}\n\n// AddContainer adds a container to the manager\nfunc (cm *ContainerManager) AddContainer(c *Container) error {\n\tcm.mu.Lock()\n\tdefer cm.mu.Unlock()\n\n\tif _, exists := cm.containers[c.GetID()]; exists {\n\t\treturn fmt.Errorf(\"container %s already exists\", c.GetID())\n\t}\n\tcm.containers[c.GetID()] = c\n\treturn nil\n}\n\n// StartAll starts all containers\nfunc (cm *ContainerManager) StartAll() error {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tvar errs []error\n\tfor _, c := range cm.containers {\n\t\tif err := c.Start(); err != nil {\n\t\t\terrs = append(errs, err)\n\t\t}\n\t}\n\n\tif len(errs) > 0 {\n\t\treturn fmt.Errorf(\"errors starting containers: %v\", errs)\n\t}\n\treturn nil\n}\n\n// StopAll gracefully stops all containers\nfunc (cm *ContainerManager) StopAll() map[string]error {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tresults := make(map[string]error)\n\tfor id, c := range cm.containers {\n\t\tresults[id] = c.Stop()\n\t}\n\treturn results\n}\n\n// GetStatus returns the status of all containers\nfunc (cm *ContainerManager) GetStatus() map[string]bool {\n\tcm.mu.RLock()\n\tdefer cm.mu.RUnlock()\n\n\tstatus := make(map[string]bool)\n\tfor id, c := range cm.containers {\n\t\tstatus[id] = c.IsRunning()\n\t}\n\treturn status\n}\n\nfunc main() {\n\tfmt.Println(\"=== Container Process Manager ===\\n\")\n\n\tmanager := NewContainerManager()\n\n\t// Create well-behaved containers\n\tfor i := 1; i <= 2; i++ {\n\t\tid := fmt.Sprintf(\"container-well-%d\", i)\n\t\tcontainer := NewContainer(id, false)\n\t\tif err := manager.AddContainer(container); err != nil {\n\t\t\tfmt.Printf(\"Error adding container: %v\\n\", err)\n\t\t}\n\t}\n\n\t// Create stuck containers that ignore stop signals\n\tfor i := 1; i <= 2; i++ {\n\t\tid := fmt.Sprintf(\"container-stuck-%d\", i)\n\t\tcontainer := NewContainer(id, true)\n\t\tif err := manager.AddContainer(container); err != nil {\n\t\t\tfmt.Printf(\"Error adding container: %v\\n\", err)\n\t\t}\n\t}\n\n\t// Start all containers\n\tfmt.Println(\"Starting all containers...\")\n\tif err := manager.StartAll(); err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n\n\t// Display initial status\n\tfmt.Println(\"\\nInitial status:\")\n\tfor id, running := range manager.GetStatus() {\n\t\tstatus := \"running\"\n\t\tif !running {\n\t\t\tstatus = \"stopped\"\n\t\t}\n\t\tfmt.Printf(\"  %s: %s\\n\", id, status)\n\t}\n\n\t// Let containers run for a bit\n\ttime.Sleep(2 * time.Second)\n\n\t// Stop all containers\n\tfmt.Println(\"\\nStopping all containers...\")\n\tstopResults := manager.StopAll()\n\n\t// Display stop results\n\tfmt.Println(\"\\nStop results:\")\n\tfor id, err := range stopResults {\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"  %s: ERROR - %v\\n\", id, err)\n\t\t} else {\n\t\t\tfmt.Printf(\"  %s: SUCCESS\\n\", id)\n\t\t}\n\t}\n\n\t// Final status check\n\ttime.Sleep(500 * time.Millisecond)\n\tfmt.Println(\"\\nFinal status:\")\n\tfor id, running := range manager.GetStatus() {\n\t\tstatus := \"running\"\n\t\tif !running {\n\t\t\tstatus = \"stopped\"\n\t\t}\n\t\tfmt.Printf(\"  %s: %s\\n\", id, status)\n\t}\n\n\tfmt.Println(\"\\n=== All containers have been stopped ===\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}