{
    "task": "37addf0a50ccba51630368c6ed09eb08166d6f48.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Container represents a container with network connections\ntype Container struct {\n\tID       string\n\tNetworks map[string]bool\n\tmu       sync.RWMutex\n}\n\n// NewContainer creates a new container\nfunc NewContainer(id string) *Container {\n\treturn &Container{\n\t\tID:       id,\n\t\tNetworks: make(map[string]bool),\n\t}\n}\n\n// IsConnectedTo checks if container is connected to a network\nfunc (c *Container) IsConnectedTo(network string) bool {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.Networks[network]\n}\n\n// GetNetworks returns a copy of connected networks\nfunc (c *Container) GetNetworks() []string {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tnetworks := make([]string, 0, len(c.Networks))\n\tfor net := range c.Networks {\n\t\tnetworks = append(networks, net)\n\t}\n\treturn networks\n}\n\n// CheckpointTo persists container state\nfunc (c *Container) CheckpointTo(storage map[string]interface{}) error {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\t// Simulate persistence delay\n\ttime.Sleep(10 * time.Millisecond)\n\n\tnetworks := make([]string, 0, len(c.Networks))\n\tfor net := range c.Networks {\n\t\tnetworks = append(networks, net)\n\t}\n\n\tstorage[c.ID] = map[string]interface{}{\n\t\t\"id\":       c.ID,\n\t\t\"networks\": networks,\n\t\t\"timestamp\": time.Now(),\n\t}\n\n\treturn nil\n}\n\n// Daemon manages containers and networks\ntype Daemon struct {\n\tcontainers map[string]*Container\n\tstorage    map[string]interface{}\n\tmu         sync.RWMutex\n}\n\n// NewDaemon creates a new daemon\nfunc NewDaemon() *Daemon {\n\treturn &Daemon{\n\t\tcontainers: make(map[string]*Container),\n\t\tstorage:    make(map[string]interface{}),\n\t}\n}\n\n// CreateContainer creates a new container in the daemon\nfunc (d *Daemon) CreateContainer(id string) *Container {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tcontainer := NewContainer(id)\n\td.containers[id] = container\n\treturn container\n}\n\n// getContainer retrieves a container safely\nfunc (d *Daemon) getContainer(id string) (*Container, error) {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\tcontainer, exists := d.containers[id]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"container not found: %s\", id)\n\t}\n\treturn container, nil\n}\n\n// ConnectToNetwork connects a container to a network\nfunc (d *Daemon) ConnectToNetwork(containerID, networkName string) error {\n\tcontainer, err := d.getContainer(containerID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcontainer.mu.Lock()\n\tcontainer.Networks[networkName] = true\n\tcontainer.mu.Unlock()\n\n\treturn container.CheckpointTo(d.storage)\n}\n\n// DisconnectFromNetwork disconnects a container from a network\nfunc (d *Daemon) DisconnectFromNetwork(containerID, networkName string) error {\n\tcontainer, err := d.getContainer(containerID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcontainer.mu.Lock()\n\tdelete(container.Networks, networkName)\n\tcontainer.mu.Unlock()\n\n\treturn container.CheckpointTo(d.storage)\n}\n\n// GetContainerNetworks returns networks for a container\nfunc (d *Daemon) GetContainerNetworks(containerID string) ([]string, error) {\n\tcontainer, err := d.getContainer(containerID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn container.GetNetworks(), nil\n}\n\n// GetAllContainers returns all container IDs\nfunc (d *Daemon) GetAllContainers() []string {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\tids := make([]string, 0, len(d.containers))\n\tfor id := range d.containers {\n\t\tids = append(ids, id)\n\t}\n\treturn ids\n}\n\n// PrintState prints current state\nfunc (d *Daemon) PrintState() {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\tfmt.Println(\"\\n=== Container Network State ===\")\n\tfor _, container := range d.containers {\n\t\tnetworks := container.GetNetworks()\n\t\tfmt.Printf(\"Container %s: Connected to %v\\n\", container.ID, networks)\n\t}\n\tfmt.Println(\"================================\\n\")\n}\n\nfunc main() {\n\tfmt.Println(\"Starting Container Network Manager...\")\n\n\tdaemon := NewDaemon()\n\n\t// Create containers\n\tcontainerIDs := []string{\"container1\", \"container2\", \"container3\", \"container4\"}\n\tnetworks := []string{\"network1\", \"network2\", \"network3\", \"network4\", \"network5\"}\n\n\tfor _, id := range containerIDs {\n\t\tdaemon.CreateContainer(id)\n\t}\n\n\tfmt.Printf(\"Created %d containers\\n\", len(containerIDs))\n\tfmt.Printf(\"Available networks: %v\\n\", networks)\n\n\t// WaitGroup to synchronize goroutines\n\tvar wg sync.WaitGroup\n\n\t// Perform concurrent operations\n\toperationCount := 0\n\n\t// Connect operations\n\tfor i := 0; i < 15; i++ {\n\t\twg.Add(1)\n\t\tgo func(idx int) {\n\t\t\tdefer wg.Done()\n\t\t\tcontainerID := containerIDs[idx%len(containerIDs)]\n\t\t\tnetworkName := networks[idx%len(networks)]\n\t\t\terr := daemon.ConnectToNetwork(containerID, networkName)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error connecting %s to %s: %v\\n\", containerID, networkName, err)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"\u2713 Connected %s to %s\\n\", containerID, networkName)\n\t\t\t}\n\t\t}(i)\n\t\toperationCount++\n\t}\n\n\t// Disconnect operations\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(idx int) {\n\t\t\tdefer wg.Done()\n\t\t\tcontainerID := containerIDs[idx%len(containerIDs)]\n\t\t\tnetworkName := networks[idx%len(networks)]\n\t\t\terr := daemon.DisconnectFromNetwork(containerID, networkName)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error disconnecting %s from %s: %v\\n\", containerID, networkName, err)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"\u2713 Disconnected %s from %s\\n\", containerID, networkName)\n\t\t\t}\n\t\t}(i)\n\t\toperationCount++\n\t}\n\n\t// Mixed operations on same containers\n\tfor i := 0; i < 8; i++ {\n\t\twg.Add(1)\n\t\tgo func(idx int) {\n\t\t\tdefer wg.Done()\n\t\t\tcontainerID := containerIDs[0] // Same container\n\t\t\tnetworkName := networks[(idx*7)%len(networks)]\n\t\t\tif idx%2 == 0 {\n\t\t\t\terr := daemon.ConnectToNetwork(containerID, networkName)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"Error connecting %s to %s: %v\\n\", containerID, networkName, err)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"\u2713 Connected %s to %s (mixed ops)\\n\", containerID, networkName)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr := daemon.DisconnectFromNetwork(containerID, networkName)\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Printf(\"Error disconnecting %s from %s: %v\\n\", containerID, networkName, err)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\"\u2713 Disconnected %s from %s (mixed ops)\\n\", containerID, networkName)\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t\toperationCount++\n\t}\n\n\tfmt.Printf(\"\\nWaiting for %d concurrent operations to complete...\\n\", operationCount)\n\n\t// Wait for all goroutines to complete\n\tdone := make(chan bool)\n\tgo func() {\n\t\twg.Wait()\n\t\tdone <- true\n\t}()\n\n\t// Timeout protection\n\tselect {\n\tcase <-done:\n\t\tfmt.Println(\"\u2713 All operations completed successfully!\")\n\tcase <-time.After(30 * time.Second):\n\t\tfmt.Println(\"\u2717 Timeout: Operations did not complete within 30 seconds\")\n\t\treturn\n\t}\n\n\t// Print final state\n\tdaemon.PrintState()\n\n\t// Verify persistence\n\tfmt.Println(\"=== Persistence Verification ===\")\n\tfor _, containerID := range daemon.GetAllContainers() {\n\t\tnetworks, _ := daemon.GetContainerNetworks(containerID)\n\t\tfmt.Printf(\"Container %s has %d network connections\\n\", containerID, len(networks))\n\t}\n\n\tfmt.Println(\"\\n\u2713 Container Network Manager completed successfully!\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}