{
    "task": "214d0189113347a5475c227feff23330196613f5.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype State struct {\n\tmu       sync.RWMutex\n\tSent     map[string]bool\n\tReceived map[string]bool\n}\n\nfunc NewState() *State {\n\treturn &State{\n\t\tSent:     make(map[string]bool),\n\t\tReceived: make(map[string]bool),\n\t}\n}\n\nfunc (s *State) Logf(format string, args ...interface{}) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\ttimestamp := time.Now().Format(\"2006-01-02 15:04:05.000\")\n\tmessage := fmt.Sprintf(format, args...)\n\tfmt.Printf(\"[%s] Status check: sent=%d, received=%d, %s\\n\", timestamp, len(s.Sent), len(s.Received), message)\n}\n\nfunc (s *State) RecordSent(id string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.Sent[id] = true\n}\n\nfunc (s *State) RecordReceived(id string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.Received[id] = true\n}\n\nfunc (s *State) GetStatus(expected int) string {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\treceived := len(s.Received)\n\tif received == expected {\n\t\treturn \"running\"\n\t}\n\treturn \"fail\"\n}\n\nfunc (s *State) GetCounts() (int, int) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\treturn len(s.Sent), len(s.Received)\n}\n\nfunc handleSend(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tid := r.URL.Query().Get(\"id\")\n\t\tif id == \"\" {\n\t\t\thttp.Error(w, \"Missing id parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstate.RecordSent(id)\n\t\tw.WriteHeader(http.StatusOK)\n\t\tio.WriteString(w, \"Message sent recorded\\n\")\n\t}\n}\n\nfunc handleReceive(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tid := r.URL.Query().Get(\"id\")\n\t\tif id == \"\" {\n\t\t\thttp.Error(w, \"Missing id parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstate.RecordReceived(id)\n\t\tw.WriteHeader(http.StatusOK)\n\t\tio.WriteString(w, \"Message received recorded\\n\")\n\t}\n}\n\nfunc handleStatus(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\texpectedStr := r.URL.Query().Get(\"expected\")\n\t\tif expectedStr == \"\" {\n\t\t\thttp.Error(w, \"Missing expected parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tvar expected int\n\t\t_, err := fmt.Sscanf(expectedStr, \"%d\", &expected)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Invalid expected parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstatus := state.GetStatus(expected)\n\t\tsent, received := state.GetCounts()\n\n\t\tif status == \"fail\" {\n\t\t\tstate.Logf(\"expected=%d but got received=%d\", expected, received)\n\t\t} else {\n\t\t\tstate.Logf(\"all messages received as expected\")\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\tfmt.Fprintf(w, \"Status: %s\\nSent: %d\\nReceived: %d\\nExpected: %d\\n\", status, sent, received, expected)\n\t}\n}\n\nfunc main() {\n\tstate := NewState()\n\n\thttp.HandleFunc(\"/send\", handleSend(state))\n\thttp.HandleFunc(\"/receive\", handleReceive(state))\n\thttp.HandleFunc(\"/status\", handleStatus(state))\n\n\tgo func() {\n\t\tfmt.Println(\"Server starting on :8080\")\n\t\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\t\tfmt.Printf(\"Server error: %v\\n\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(500 * time.Millisecond)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 1; i <= 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(nodeID int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < 5; j++ {\n\t\t\t\tmessageID := fmt.Sprintf(\"msg-%d-%d\", nodeID, j)\n\n\t\t\t\tresp, err := http.Post(\n\t\t\t\t\tfmt.Sprintf(\"http://localhost:8080/send?id=%s\", messageID),\n\t\t\t\t\t\"application/json\",\n\t\t\t\t\tnil,\n\t\t\t\t)\n\t\t\t\tif err == nil {\n\t\t\t\t\tresp.Body.Close()\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\n\t\t\t\tresp, err = http.Post(\n\t\t\t\t\tfmt.Sprintf(\"http://localhost:8080/receive?id=%s\", messageID),\n\t\t\t\t\t\"application/json\",\n\t\t\t\t\tnil,\n\t\t\t\t)\n\t\t\t\tif err == nil {\n\t\t\t\t\tresp.Body.Close()\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 6; i++ {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\t\tresp, err := http.Get(\"http://localhost:8080/status?expected=50\")\n\t\t\tif err == nil {\n\t\t\t\tresp.Body.Close()\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Wait()\n\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"All operations completed\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[30;43m/tmp/go_synthesis_1101r6zm/main.go:144\u001b[0m] - G114 (CWE-676): Use of net/http serve function that has no support for setting timeouts (Confidence: HIGH, Severity: MEDIUM)\n    143: \t\tfmt.Println(\"Server starting on :8080\")\n  > 144: \t\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n    145: \t\t\tfmt.Printf(\"Server error: %v\\n\", err)\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_1101r6zm/main.go:193\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    192: \t\t\tif err == nil {\n  > 193: \t\t\t\tresp.Body.Close()\n    194: \t\t\t}\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_1101r6zm/main.go:177\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    176: \t\t\t\tif err == nil {\n  > 177: \t\t\t\t\tresp.Body.Close()\n    178: \t\t\t\t}\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_1101r6zm/main.go:166\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    165: \t\t\t\tif err == nil {\n  > 166: \t\t\t\t\tresp.Body.Close()\n    167: \t\t\t\t}\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_1101r6zm/main.go:96\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    95: \t\tw.WriteHeader(http.StatusOK)\n  > 96: \t\tio.WriteString(w, \"Message received recorded\\n\")\n    97: \t}\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_1101r6zm/main.go:77\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    76: \t\tw.WriteHeader(http.StatusOK)\n  > 77: \t\tio.WriteString(w, \"Message sent recorded\\n\")\n    78: \t}\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 202\n  Nosec  : 0\n  Issues : \u001b[1;31m6\u001b[0m\n\n[gosec] 2025/12/01 13:40:26 Including rules: default\n[gosec] 2025/12/01 13:40:26 Excluding rules: default\n[gosec] 2025/12/01 13:40:26 Including analyzers: default\n[gosec] 2025/12/01 13:40:26 Excluding analyzers: default\n[gosec] 2025/12/01 13:40:26 Import directory: /tmp/go_synthesis_1101r6zm\n[gosec] 2025/12/01 13:40:26 Checking package: main\n[gosec] 2025/12/01 13:40:26 Checking file: /tmp/go_synthesis_1101r6zm/main.go"
                },
                {
                    "verifier": "errcheck",
                    "error": "main.go:77:17:\tio.WriteString(w, \"Message sent recorded\\n\")\nmain.go:96:17:\tio.WriteString(w, \"Message received recorded\\n\")\nmain.go:131:14:\tfmt.Fprintf(w, \"Status: %s\\nSent: %d\\nReceived: %d\\nExpected: %d\\n\", status, sent, received, expected)\nmain.go:166:21:\tresp.Body.Close()\nmain.go:177:21:\tresp.Body.Close()\nmain.go:193:20:\tresp.Body.Close()"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype State struct {\n\tmu       sync.RWMutex\n\tSent     map[string]bool\n\tReceived map[string]bool\n}\n\nfunc NewState() *State {\n\treturn &State{\n\t\tSent:     make(map[string]bool),\n\t\tReceived: make(map[string]bool),\n\t}\n}\n\nfunc (s *State) Logf(format string, args ...interface{}) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\ttimestamp := time.Now().Format(\"2006-01-02 15:04:05.000\")\n\tmessage := fmt.Sprintf(format, args...)\n\tfmt.Printf(\"[%s] Status check: sent=%d, received=%d, %s\\n\", timestamp, len(s.Sent), len(s.Received), message)\n}\n\nfunc (s *State) RecordSent(id string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.Sent[id] = true\n}\n\nfunc (s *State) RecordReceived(id string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.Received[id] = true\n}\n\nfunc (s *State) GetStatus(expected int) string {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\treceived := len(s.Received)\n\tif received == expected {\n\t\treturn \"running\"\n\t}\n\treturn \"fail\"\n}\n\nfunc (s *State) GetCounts() (int, int) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\treturn len(s.Sent), len(s.Received)\n}\n\nfunc handleSend(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tid := r.URL.Query().Get(\"id\")\n\t\tif id == \"\" {\n\t\t\thttp.Error(w, \"Missing id parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstate.RecordSent(id)\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = io.WriteString(w, \"Message sent recorded\\n\")\n\t}\n}\n\nfunc handleReceive(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tid := r.URL.Query().Get(\"id\")\n\t\tif id == \"\" {\n\t\t\thttp.Error(w, \"Missing id parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstate.RecordReceived(id)\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = io.WriteString(w, \"Message received recorded\\n\")\n\t}\n}\n\nfunc handleStatus(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\texpectedStr := r.URL.Query().Get(\"expected\")\n\t\tif expectedStr == \"\" {\n\t\t\thttp.Error(w, \"Missing expected parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tvar expected int\n\t\t_, err := fmt.Sscanf(expectedStr, \"%d\", &expected)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Invalid expected parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstatus := state.GetStatus(expected)\n\t\tsent, received := state.GetCounts()\n\n\t\tif status == \"fail\" {\n\t\t\tstate.Logf(\"expected=%d but got received=%d\", expected, received)\n\t\t} else {\n\t\t\tstate.Logf(\"all messages received as expected\")\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = fmt.Fprintf(w, \"Status: %s\\nSent: %d\\nReceived: %d\\nExpected: %d\\n\", status, sent, received, expected)\n\t}\n}\n\nfunc main() {\n\tstate := NewState()\n\n\thttp.HandleFunc(\"/send\", handleSend(state))\n\thttp.HandleFunc(\"/receive\", handleReceive(state))\n\thttp.HandleFunc(\"/status\", handleStatus(state))\n\n\tserver := &http.Server{\n\t\tAddr:         \":8080\",\n\t\tHandler:      nil,\n\t\tReadTimeout:  15 * time.Second,\n\t\tWriteTimeout: 15 * time.Second,\n\t\tIdleTimeout:  60 * time.Second,\n\t}\n\n\tgo func() {\n\t\tfmt.Println(\"Server starting on :8080\")\n\t\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tfmt.Printf(\"Server error: %v\\n\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(500 * time.Millisecond)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 1; i <= 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(nodeID int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < 5; j++ {\n\t\t\t\tmessageID := fmt.Sprintf(\"msg-%d-%d\", nodeID, j)\n\n\t\t\t\tresp, err := http.Post(\n\t\t\t\t\tfmt.Sprintf(\"http://localhost:8080/send?id=%s\", messageID),\n\t\t\t\t\t\"application/json\",\n\t\t\t\t\tnil,\n\t\t\t\t)\n\t\t\t\tif err == nil {\n\t\t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n\t\t\t\t\tresp.Body.Close()\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\n\t\t\t\tresp, err = http.Post(\n\t\t\t\t\tfmt.Sprintf(\"http://localhost:8080/receive?id=%s\", messageID),\n\t\t\t\t\t\"application/json\",\n\t\t\t\t\tnil,\n\t\t\t\t)\n\t\t\t\tif err == nil {\n\t\t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n\t\t\t\t\tresp.Body.Close()\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 6; i++ {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\t\tresp, err := http.Get(\"http://localhost:8080/status?expected=50\")\n\t\t\tif err == nil {\n\t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n\t\t\t\tresp.Body.Close()\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Wait()\n\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"All operations completed\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "gosec",
                    "error": "Results:\n\n\n[\u001b[37;40m/tmp/go_synthesis_1101r6zm/main.go:204\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    203: \t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n  > 204: \t\t\t\tresp.Body.Close()\n    205: \t\t\t}\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_1101r6zm/main.go:187\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    186: \t\t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n  > 187: \t\t\t\t\tresp.Body.Close()\n    188: \t\t\t\t}\n\nAutofix: \n\n[\u001b[37;40m/tmp/go_synthesis_1101r6zm/main.go:175\u001b[0m] - G104 (CWE-703): Errors unhandled (Confidence: HIGH, Severity: LOW)\n    174: \t\t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n  > 175: \t\t\t\t\tresp.Body.Close()\n    176: \t\t\t\t}\n\nAutofix: \n\n\u001b[1;36mSummary:\u001b[0m\n  Gosec  : dev\n  Files  : 1\n  Lines  : 213\n  Nosec  : 0\n  Issues : \u001b[1;31m3\u001b[0m\n\n[gosec] 2025/12/01 13:40:37 Including rules: default\n[gosec] 2025/12/01 13:40:37 Excluding rules: default\n[gosec] 2025/12/01 13:40:37 Including analyzers: default\n[gosec] 2025/12/01 13:40:37 Excluding analyzers: default\n[gosec] 2025/12/01 13:40:37 Import directory: /tmp/go_synthesis_1101r6zm\n[gosec] 2025/12/01 13:40:37 Checking package: main\n[gosec] 2025/12/01 13:40:37 Checking file: /tmp/go_synthesis_1101r6zm/main.go"
                },
                {
                    "verifier": "errcheck",
                    "error": "main.go:175:21:\tresp.Body.Close()\nmain.go:187:21:\tresp.Body.Close()\nmain.go:204:20:\tresp.Body.Close()"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype State struct {\n\tmu       sync.RWMutex\n\tSent     map[string]bool\n\tReceived map[string]bool\n}\n\nfunc NewState() *State {\n\treturn &State{\n\t\tSent:     make(map[string]bool),\n\t\tReceived: make(map[string]bool),\n\t}\n}\n\nfunc (s *State) Logf(format string, args ...interface{}) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\ttimestamp := time.Now().Format(\"2006-01-02 15:04:05.000\")\n\tmessage := fmt.Sprintf(format, args...)\n\tfmt.Printf(\"[%s] Status check: sent=%d, received=%d, %s\\n\", timestamp, len(s.Sent), len(s.Received), message)\n}\n\nfunc (s *State) RecordSent(id string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.Sent[id] = true\n}\n\nfunc (s *State) RecordReceived(id string) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.Received[id] = true\n}\n\nfunc (s *State) GetStatus(expected int) string {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\treceived := len(s.Received)\n\tif received == expected {\n\t\treturn \"running\"\n\t}\n\treturn \"fail\"\n}\n\nfunc (s *State) GetCounts() (int, int) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\treturn len(s.Sent), len(s.Received)\n}\n\nfunc handleSend(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tid := r.URL.Query().Get(\"id\")\n\t\tif id == \"\" {\n\t\t\thttp.Error(w, \"Missing id parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstate.RecordSent(id)\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = io.WriteString(w, \"Message sent recorded\\n\")\n\t}\n}\n\nfunc handleReceive(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\tid := r.URL.Query().Get(\"id\")\n\t\tif id == \"\" {\n\t\t\thttp.Error(w, \"Missing id parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstate.RecordReceived(id)\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = io.WriteString(w, \"Message received recorded\\n\")\n\t}\n}\n\nfunc handleStatus(state *State) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodGet {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t\treturn\n\t\t}\n\n\t\texpectedStr := r.URL.Query().Get(\"expected\")\n\t\tif expectedStr == \"\" {\n\t\t\thttp.Error(w, \"Missing expected parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tvar expected int\n\t\t_, err := fmt.Sscanf(expectedStr, \"%d\", &expected)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Invalid expected parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tstatus := state.GetStatus(expected)\n\t\tsent, received := state.GetCounts()\n\n\t\tif status == \"fail\" {\n\t\t\tstate.Logf(\"expected=%d but got received=%d\", expected, received)\n\t\t} else {\n\t\t\tstate.Logf(\"all messages received as expected\")\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = fmt.Fprintf(w, \"Status: %s\\nSent: %d\\nReceived: %d\\nExpected: %d\\n\", status, sent, received, expected)\n\t}\n}\n\nfunc main() {\n\tstate := NewState()\n\n\thttp.HandleFunc(\"/send\", handleSend(state))\n\thttp.HandleFunc(\"/receive\", handleReceive(state))\n\thttp.HandleFunc(\"/status\", handleStatus(state))\n\n\tserver := &http.Server{\n\t\tAddr:         \":8080\",\n\t\tHandler:      nil,\n\t\tReadTimeout:  15 * time.Second,\n\t\tWriteTimeout: 15 * time.Second,\n\t\tIdleTimeout:  60 * time.Second,\n\t}\n\n\tgo func() {\n\t\tfmt.Println(\"Server starting on :8080\")\n\t\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tfmt.Printf(\"Server error: %v\\n\", err)\n\t\t}\n\t}()\n\n\ttime.Sleep(500 * time.Millisecond)\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 1; i <= 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(nodeID int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < 5; j++ {\n\t\t\t\tmessageID := fmt.Sprintf(\"msg-%d-%d\", nodeID, j)\n\n\t\t\t\tresp, err := http.Post(\n\t\t\t\t\tfmt.Sprintf(\"http://localhost:8080/send?id=%s\", messageID),\n\t\t\t\t\t\"application/json\",\n\t\t\t\t\tnil,\n\t\t\t\t)\n\t\t\t\tif err == nil {\n\t\t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n\t\t\t\t\tif closeErr := resp.Body.Close(); closeErr != nil {\n\t\t\t\t\t\tfmt.Printf(\"Error closing response body: %v\\n\", closeErr)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\n\t\t\t\tresp, err = http.Post(\n\t\t\t\t\tfmt.Sprintf(\"http://localhost:8080/receive?id=%s\", messageID),\n\t\t\t\t\t\"application/json\",\n\t\t\t\t\tnil,\n\t\t\t\t)\n\t\t\t\tif err == nil {\n\t\t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n\t\t\t\t\tif closeErr := resp.Body.Close(); closeErr != nil {\n\t\t\t\t\t\tfmt.Printf(\"Error closing response body: %v\\n\", closeErr)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor i := 0; i < 6; i++ {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\n\t\t\tresp, err := http.Get(\"http://localhost:8080/status?expected=50\")\n\t\t\tif err == nil {\n\t\t\t\t_, _ = io.Copy(io.Discard, resp.Body)\n\t\t\t\tif closeErr := resp.Body.Close(); closeErr != nil {\n\t\t\t\t\tfmt.Printf(\"Error closing response body: %v\\n\", closeErr)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\twg.Wait()\n\n\ttime.Sleep(1 * time.Second)\n\tfmt.Println(\"All operations completed\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}