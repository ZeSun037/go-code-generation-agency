{
    "task": "435e0b73bb99862f9dedf56a50260ff3dfef14ff.txt",
    "provider": "anthropic",
    "model": "claude-haiku-4-5",
    "rounds": [
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Event struct {\n\tType string\n\tData interface{}\n}\n\ntype Watcher interface {\n\tResultChan() <-chan Event\n\tStop()\n}\n\ntype watcher struct {\n\tid       int\n\tresultCh chan Event\n\tstopCh   chan struct{}\n\tstopped  bool\n\tmu       sync.Mutex\n}\n\nfunc (w *watcher) ResultChan() <-chan Event {\n\treturn w.resultCh\n}\n\nfunc (w *watcher) Stop() {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tif !w.stopped {\n\t\tw.stopped = true\n\t\tclose(w.stopCh)\n\t}\n}\n\ntype Mux struct {\n\twatchers map[int]Watcher\n\twatcherID int\n\teventCh  chan Event\n\tstopCh   chan struct{}\n\taddWatcherCh chan Watcher\n\tremoveWatcherCh chan int\n\tmu       sync.RWMutex\n\twg       sync.WaitGroup\n}\n\nfunc NewMux() *Mux {\n\tm := &Mux{\n\t\twatchers: make(map[int]Watcher),\n\t\teventCh: make(chan Event, 100),\n\t\tstopCh: make(chan struct{}),\n\t\taddWatcherCh: make(chan Watcher),\n\t\tremoveWatcherCh: make(chan int),\n\t}\n\tm.wg.Add(1)\n\tgo m.run()\n\treturn m\n}\n\nfunc (m *Mux) Watch() Watcher {\n\tw := &watcher{\n\t\tid:       m.watcherID,\n\t\tresultCh: make(chan Event, 10),\n\t\tstopCh:   make(chan struct{}),\n\t\tstopped:  false,\n\t}\n\tm.watcherID++\n\tm.addWatcherCh <- w\n\treturn w\n}\n\nfunc (m *Mux) Broadcast(event Event) {\n\tselect {\n\tcase m.eventCh <- event:\n\tcase <-m.stopCh:\n\t}\n}\n\nfunc (m *Mux) Stop() {\n\tclose(m.stopCh)\n\tm.wg.Wait()\n}\n\nfunc (m *Mux) run() {\n\tdefer m.wg.Done()\n\tactiveWatchers := make(map[int]*watcher)\n\n\tfor {\n\t\tselect {\n\t\tcase <-m.stopCh:\n\t\t\tfor _, w := range activeWatchers {\n\t\t\t\tclose(w.resultCh)\n\t\t\t}\n\t\t\treturn\n\t\tcase w := <-m.addWatcherCh:\n\t\t\twatcher := w.(*watcher)\n\t\t\tactiveWatchers[watcher.id] = watcher\n\t\t\tgo m.watcherMonitor(watcher, activeWatchers)\n\t\tcase watcherID := <-m.removeWatcherCh:\n\t\t\tif w, exists := activeWatchers[watcherID]; exists {\n\t\t\t\tclose(w.resultCh)\n\t\t\t\tdelete(activeWatchers, watcherID)\n\t\t\t}\n\t\tcase event := <-m.eventCh:\n\t\t\tfor id, w := range activeWatchers {\n\t\t\t\tselect {\n\t\t\t\tcase w.resultCh <- event:\n\t\t\t\tdefault:\n\t\t\t\t\tm.removeWatcherCh <- id\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (m *Mux) watcherMonitor(w *watcher, activeWatchers map[int]*watcher) {\n\t<-w.stopCh\n\tm.removeWatcherCh <- w.id\n}\n\nfunc main() {\n\tmux := NewMux()\n\tdefer mux.Stop()\n\n\twatcherCount := 3\n\tvar watchers []Watcher\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < watcherCount; i++ {\n\t\tw := mux.Watch()\n\t\twatchers = append(watchers, w)\n\t\twg.Add(1)\n\t\tgo func(wid int, watcher Watcher) {\n\t\t\tdefer wg.Done()\n\t\t\tfor event := range watcher.ResultChan() {\n\t\t\t\tfmt.Printf(\"Watcher %d received: Type=%s, Data=%v\\n\", wid, event.Type, event.Data)\n\t\t\t}\n\t\t}(i+1, w)\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 1 ---\")\n\tmux.Broadcast(Event{Type: \"login\", Data: \"user123\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 2 ---\")\n\tmux.Broadcast(Event{Type: \"action\", Data: \"clicked button\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Stopping Watcher 2 ---\")\n\twatchers[1].Stop()\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 3 ---\")\n\tmux.Broadcast(Event{Type: \"logout\", Data: \"user123\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 4 ---\")\n\tmux.Broadcast(Event{Type: \"session_end\", Data: \"timeout\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Stopping Watcher 1 ---\")\n\twatchers[0].Stop()\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 5 ---\")\n\tmux.Broadcast(Event{Type: \"cleanup\", Data: \"final event\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Stopping all remaining watchers ---\")\n\twatchers[2].Stop()\n\twatchers[1].Stop()\n\twatchers[0].Stop()\n\n\ttime.Sleep(100 * time.Millisecond)\n\tmux.Stop()\n\n\twg.Wait()\n\tfmt.Println(\"\\n--- All watchers stopped ---\")\n}",
            "passed": false,
            "errors": [
                {
                    "verifier": "staticcheck",
                    "error": "main.go:48:2: field mu is unused (U1000)"
                }
            ]
        },
        {
            "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype Event struct {\n\tType string\n\tData interface{}\n}\n\ntype Watcher interface {\n\tResultChan() <-chan Event\n\tStop()\n}\n\ntype watcher struct {\n\tid       int\n\tresultCh chan Event\n\tstopCh   chan struct{}\n\tstopped  bool\n\tmu       sync.Mutex\n}\n\nfunc (w *watcher) ResultChan() <-chan Event {\n\treturn w.resultCh\n}\n\nfunc (w *watcher) Stop() {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tif !w.stopped {\n\t\tw.stopped = true\n\t\tclose(w.stopCh)\n\t}\n}\n\ntype Mux struct {\n\twatchers        map[int]*watcher\n\twatcherID       int\n\teventCh         chan Event\n\tstopCh          chan struct{}\n\taddWatcherCh    chan *watcher\n\tremoveWatcherCh chan int\n\tmu              sync.Mutex\n\twg              sync.WaitGroup\n}\n\nfunc NewMux() *Mux {\n\tm := &Mux{\n\t\twatchers:        make(map[int]*watcher),\n\t\teventCh:         make(chan Event, 100),\n\t\tstopCh:          make(chan struct{}),\n\t\taddWatcherCh:    make(chan *watcher),\n\t\tremoveWatcherCh: make(chan int),\n\t}\n\tm.wg.Add(1)\n\tgo m.run()\n\treturn m\n}\n\nfunc (m *Mux) Watch() Watcher {\n\tm.mu.Lock()\n\tid := m.watcherID\n\tm.watcherID++\n\tm.mu.Unlock()\n\n\tw := &watcher{\n\t\tid:       id,\n\t\tresultCh: make(chan Event, 10),\n\t\tstopCh:   make(chan struct{}),\n\t\tstopped:  false,\n\t}\n\tm.addWatcherCh <- w\n\treturn w\n}\n\nfunc (m *Mux) Broadcast(event Event) {\n\tselect {\n\tcase m.eventCh <- event:\n\tcase <-m.stopCh:\n\t}\n}\n\nfunc (m *Mux) Stop() {\n\tclose(m.stopCh)\n\tm.wg.Wait()\n}\n\nfunc (m *Mux) run() {\n\tdefer m.wg.Done()\n\tactiveWatchers := make(map[int]*watcher)\n\n\tfor {\n\t\tselect {\n\t\tcase <-m.stopCh:\n\t\t\tfor _, w := range activeWatchers {\n\t\t\t\tclose(w.resultCh)\n\t\t\t}\n\t\t\treturn\n\t\tcase w := <-m.addWatcherCh:\n\t\t\tactiveWatchers[w.id] = w\n\t\t\tgo m.watcherMonitor(w)\n\t\tcase watcherID := <-m.removeWatcherCh:\n\t\t\tif w, exists := activeWatchers[watcherID]; exists {\n\t\t\t\tclose(w.resultCh)\n\t\t\t\tdelete(activeWatchers, watcherID)\n\t\t\t}\n\t\tcase event := <-m.eventCh:\n\t\t\tfor id, w := range activeWatchers {\n\t\t\t\tselect {\n\t\t\t\tcase w.resultCh <- event:\n\t\t\t\tdefault:\n\t\t\t\t\tm.removeWatcherCh <- id\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (m *Mux) watcherMonitor(w *watcher) {\n\t<-w.stopCh\n\tm.removeWatcherCh <- w.id\n}\n\nfunc main() {\n\tmux := NewMux()\n\tdefer mux.Stop()\n\n\twatcherCount := 3\n\tvar watchers []Watcher\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < watcherCount; i++ {\n\t\tw := mux.Watch()\n\t\twatchers = append(watchers, w)\n\t\twg.Add(1)\n\t\tgo func(wid int, watcher Watcher) {\n\t\t\tdefer wg.Done()\n\t\t\tfor event := range watcher.ResultChan() {\n\t\t\t\tfmt.Printf(\"Watcher %d received: Type=%s, Data=%v\\n\", wid, event.Type, event.Data)\n\t\t\t}\n\t\t}(i+1, w)\n\t}\n\n\ttime.Sleep(100 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 1 ---\")\n\tmux.Broadcast(Event{Type: \"login\", Data: \"user123\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 2 ---\")\n\tmux.Broadcast(Event{Type: \"action\", Data: \"clicked button\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Stopping Watcher 2 ---\")\n\twatchers[1].Stop()\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 3 ---\")\n\tmux.Broadcast(Event{Type: \"logout\", Data: \"user123\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 4 ---\")\n\tmux.Broadcast(Event{Type: \"session_end\", Data: \"timeout\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Stopping Watcher 1 ---\")\n\twatchers[0].Stop()\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Broadcasting Event 5 ---\")\n\tmux.Broadcast(Event{Type: \"cleanup\", Data: \"final event\"})\n\ttime.Sleep(50 * time.Millisecond)\n\n\tfmt.Println(\"\\n--- Stopping all remaining watchers ---\")\n\twatchers[2].Stop()\n\twatchers[1].Stop()\n\twatchers[0].Stop()\n\n\ttime.Sleep(100 * time.Millisecond)\n\tmux.Stop()\n\n\twg.Wait()\n\tfmt.Println(\"\\n--- All watchers stopped ---\")\n}",
            "passed": true,
            "errors": []
        }
    ],
    "passed": true
}