package main

import (
	"fmt"
)

func wordBreak(s string, wordDict []string) []string {
	wordSet := make(map[string]bool)
	for _, word := range wordDict {
		wordSet[word] = true
	}

	memo := make(map[int][]string)
	return backtrack(s, 0, wordSet, memo)
}

func backtrack(s string, start int, wordSet map[string]bool, memo map[int][]string) []string {
	if cached, found := memo[start]; found {
		return cached
	}

	var result []string

	if start == len(s) {
		return []string{""}
	}

	for end := start + 1; end <= len(s); end++ {
		word := s[start:end]
		if wordSet[word] {
			subResults := backtrack(s, end, wordSet, memo)
			for _, subResult := range subResults {
				if subResult == "" {
					result = append(result, word)
				} else {
					result = append(result, word+" "+subResult)
				}
			}
		}
	}

	memo[start] = result
	return result
}

func main() {
	testCases := []struct {
		s        string
		wordDict []string
		expected []string
	}{
		{
			s:        "catsanddog",
			wordDict: []string{"cat", "cats", "and", "sand", "dog"},
			expected: []string{"cats and dog", "cat sand dog"},
		},
		{
			s:        "pineapplepenapple",
			wordDict: []string{"apple", "pen", "applepen", "pine", "pineapple"},
			expected: []string{"pine apple pen apple", "pineapple pen apple", "pine applepen apple"},
		},
		{
			s:        "catsandog",
			wordDict: []string{"cats", "dog", "sand", "and", "cat"},
			expected: []string{},
		},
		{
			s:        "a",
			wordDict: []string{"a"},
			expected: []string{"a"},
		},
		{
			s:        "ab",
			wordDict: []string{"a", "b"},
			expected: []string{"a b"},
		},
	}

	for i, tc := range testCases {
		result := wordBreak(tc.s, tc.wordDict)
		fmt.Printf("Test case %d:\n", i+1)
		fmt.Printf("Input: s = %q, wordDict = %v\n", tc.s, tc.wordDict)
		fmt.Printf("Output: %v\n", result)
		fmt.Printf("Expected: %v\n", tc.expected)

		if len(result) != len(tc.expected) {
			fmt.Printf("FAILED: Length mismatch\n")
		} else {
			resultMap := make(map[string]bool)
			expectedMap := make(map[string]bool)
			for _, r := range result {
				resultMap[r] = true
			}
			for _, e := range tc.expected {
				expectedMap[e] = true
			}

			allMatch := true
			for key := range expectedMap {
				if !resultMap[key] {
					allMatch = false
					break
				}
			}
			for key := range resultMap {
				if !expectedMap[key] {
					allMatch = false
					break
				}
			}

			if allMatch {
				fmt.Printf("PASSED\n")
			} else {
				fmt.Printf("FAILED: Results don't match\n")
			}
		}
		fmt.Println()
	}
}