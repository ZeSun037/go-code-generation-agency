package main

import (
	"fmt"
)

func strongPasswordChecker(password string) int {
	n := len(password)
	
	// Check missing character types
	hasLower := false
	hasUpper := false
	hasDigit := false
	
	for _, ch := range password {
		if ch >= 'a' && ch <= 'z' {
			hasLower = true
		} else if ch >= 'A' && ch <= 'Z' {
			hasUpper = true
		} else if ch >= '0' && ch <= '9' {
			hasDigit = true
		}
	}
	
	missingTypes := 0
	if !hasLower {
		missingTypes++
	}
	if !hasUpper {
		missingTypes++
	}
	if !hasDigit {
		missingTypes++
	}
	
	// Find repeating characters
	replace := 0
	i := 0
	for i < n {
		j := i
		for j < n && password[j] == password[i] {
			j++
		}
		repeatLen := j - i
		if repeatLen >= 3 {
			replace += repeatLen / 3
		}
		i = j
	}
	
	// If length is less than 6
	if n < 6 {
		return max(missingTypes, 6-n)
	}
	
	// If length is between 6 and 20
	if n <= 20 {
		return max(missingTypes, replace)
	}
	
	// If length is greater than 20
	delete := n - 20
	
	// Recalculate replace after deleting characters
	replace = 0
	i = 0
	tempDelete := delete
	
	// Strategy: delete from repeating sequences to reduce replace count
	for i < n {
		j := i
		for j < n && password[j] == password[i] {
			j++
		}
		repeatLen := j - i
		if repeatLen >= 3 {
			// Reduce replacements needed by deleting from this sequence
			toDelete := min(tempDelete, repeatLen%3)
			if toDelete > 0 {
				tempDelete -= toDelete
				repeatLen -= toDelete
			}
			if repeatLen >= 3 {
				replace += repeatLen / 3
			}
		}
		i = j
	}
	
	// If we still have deletes left, they come from sequences of 3
	replace = 0
	i = 0
	tempDelete = delete
	
	for i < n {
		j := i
		for j < n && password[j] == password[i] {
			j++
		}
		repeatLen := j - i
		if repeatLen >= 3 {
			replaceNeeded := repeatLen / 3
			toDelete := min(tempDelete, replaceNeeded)
			replaceNeeded -= toDelete
			tempDelete -= toDelete
			replace += replaceNeeded
		}
		i = j
	}
	
	return delete + max(missingTypes, replace)
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	testCases := []struct {
		password string
		expected int
	}{
		{"a", 5},
		{"aA1", 3},
		{"1337C0d3", 0},
		{"Baaabb0", 2},
		{"Baaba0", 0},
		{"abcdefghijklmnopqrst", 2},
		{"AAAAAAAAAAAAAAAAAAAAB", 3},
	}
	
	for _, tc := range testCases {
		result := strongPasswordChecker(tc.password)
		status := "✓"
		if result != tc.expected {
			status = "✗"
		}
		fmt.Printf("%s Password: %q, Expected: %d, Got: %d\n", status, tc.password, tc.expected, result)
	}
}