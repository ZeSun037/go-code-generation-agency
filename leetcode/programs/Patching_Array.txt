package main

import "fmt"

func minPatches(nums []int, n int) int {
	patches := 0
	i := 0
	reach := int64(0) // reach represents the maximum number we can form so far
	
	for reach < int64(n) {
		if i < len(nums) && int64(nums[i]) <= reach+1 {
			// We can use nums[i] to extend our reach
			reach += int64(nums[i])
			i++
		} else {
			// We need to patch a number (reach + 1)
			reach += reach + 1
			patches++
		}
	}
	
	return patches
}

func main() {
	testCases := []struct {
		nums     []int
		n        int
		expected int
	}{
		{
			nums:     []int{1, 3},
			n:        6,
			expected: 1,
		},
		{
			nums:     []int{1, 5, 10},
			n:        20,
			expected: 2,
		},
		{
			nums:     []int{1, 2, 2},
			n:        5,
			expected: 0,
		},
		{
			nums:     []int{1},
			n:        1,
			expected: 0,
		},
		{
			nums:     []int{1},
			n:        2,
			expected: 1,
		},
		{
			nums:     []int{2, 5, 10},
			n:        5,
			expected: 1,
		},
	}
	
	for idx, tc := range testCases {
		result := minPatches(tc.nums, tc.n)
		status := "PASS"
		if result != tc.expected {
			status = "FAIL"
		}
		fmt.Printf("Test %d: %s\n", idx+1, status)
		fmt.Printf("  Input: nums=%v, n=%d\n", tc.nums, tc.n)
		fmt.Printf("  Expected: %d, Got: %d\n", tc.expected, result)
		fmt.Println()
	}
}