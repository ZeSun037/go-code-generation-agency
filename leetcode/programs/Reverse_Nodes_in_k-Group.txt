package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func reverseKGroup(head *ListNode, k int) *ListNode {
	if head == nil || k == 1 {
		return head
	}

	dummy := &ListNode{Val: 0, Next: head}
	prevGroup := dummy
	current := head

	for {
		kthNode := getKthNode(current, k)
		if kthNode == nil {
			break
		}

		nextGroupHead := kthNode.Next

		reverseBetween(current, nextGroupHead)

		temp := current
		current = nextGroupHead
		prevGroup.Next = kthNode
		prevGroup = temp
	}

	return dummy.Next
}

func getKthNode(head *ListNode, k int) *ListNode {
	current := head
	for i := 0; i < k-1 && current != nil; i++ {
		current = current.Next
	}
	return current
}

func reverseBetween(head, tail *ListNode) {
	prev := tail
	current := head

	for current != tail {
		nextTemp := current.Next
		current.Next = prev
		prev = current
		current = nextTemp
	}
}

func createLinkedList(values []int) *ListNode {
	if len(values) == 0 {
		return nil
	}
	head := &ListNode{Val: values[0]}
	current := head
	for i := 1; i < len(values); i++ {
		current.Next = &ListNode{Val: values[i]}
		current = current.Next
	}
	return head
}

func linkedListToSlice(head *ListNode) []int {
	var result []int
	current := head
	for current != nil {
		result = append(result, current.Val)
		current = current.Next
	}
	return result
}

func main() {
	testCases := []struct {
		values   []int
		k        int
		expected []int
	}{
		{[]int{1, 2, 3, 4, 5}, 2, []int{2, 1, 4, 3, 5}},
		{[]int{1, 2, 3, 4, 5}, 3, []int{3, 2, 1, 4, 5}},
		{[]int{1}, 1, []int{1}},
		{[]int{1, 2}, 2, []int{2, 1}},
		{[]int{1, 2, 3}, 2, []int{2, 1, 3}},
		{[]int{1, 2, 3, 4, 5, 6, 7, 8}, 3, []int{3, 2, 1, 6, 5, 4, 7, 8}},
	}

	for i, tc := range testCases {
		head := createLinkedList(tc.values)
		result := reverseKGroup(head, tc.k)
		resultSlice := linkedListToSlice(result)

		passed := true
		if len(resultSlice) != len(tc.expected) {
			passed = false
		} else {
			for j := range resultSlice {
				if resultSlice[j] != tc.expected[j] {
					passed = false
					break
				}
			}
		}

		status := "PASS"
		if !passed {
			status = "FAIL"
		}
		fmt.Printf("Test %d: %s\n", i+1, status)
		fmt.Printf("  Input: %v, k=%d\n", tc.values, tc.k)
		fmt.Printf("  Expected: %v\n", tc.expected)
		fmt.Printf("  Got: %v\n", resultSlice)
	}
}