package main

import (
	"fmt"
)

func maxProfit(k int, prices []int) int {
	if len(prices) <= 1 || k == 0 {
		return 0
	}

	// If k >= len(prices)/2, we can make as many transactions as we want
	if k >= len(prices)/2 {
		return maxProfitUnlimited(prices)
	}

	n := len(prices)
	// buy[i][j] = max profit after at most i transactions with stock in hand
	// sell[i][j] = max profit after at most i transactions with no stock in hand
	buy := make([][]int, k+1)
	sell := make([][]int, k+1)

	for i := 0; i <= k; i++ {
		buy[i] = make([]int, n)
		sell[i] = make([]int, n)
	}

	// Initialize: buying on first day
	for i := 1; i <= k; i++ {
		buy[i][0] = -prices[0]
	}

	for i := 1; i <= k; i++ {
		for j := 1; j < n; j++ {
			// Either we already had stock from before, or we buy today
			buy[i][j] = max(buy[i][j-1], sell[i-1][j-1]-prices[j])
			// Either we already sold before, or we sell today
			sell[i][j] = max(sell[i][j-1], buy[i][j-1]+prices[j])
		}
	}

	return sell[k][n-1]
}

// When k is large enough, we can make unlimited transactions
func maxProfitUnlimited(prices []int) int {
	profit := 0
	for i := 1; i < len(prices); i++ {
		if prices[i] > prices[i-1] {
			profit += prices[i] - prices[i-1]
		}
	}
	return profit
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	testCases := []struct {
		k      int
		prices []int
		want   int
	}{
		{
			k:      2,
			prices: []int{2, 4, 1},
			want:   2,
		},
		{
			k:      2,
			prices: []int{3, 2, 6, 5, 0, 3},
			want:   7,
		},
		{
			k:      1,
			prices: []int{2, 4, 1},
			want:   2,
		},
		{
			k:      0,
			prices: []int{2, 4, 1},
			want:   0,
		},
		{
			k:      3,
			prices: []int{1, 2, 3, 4, 5},
			want:   4,
		},
		{
			k:      2,
			prices: []int{3, 3, 5, 0, 0, 3, 1, 4},
			want:   8,
		},
	}

	for i, tc := range testCases {
		result := maxProfit(tc.k, tc.prices)
		status := "✓"
		if result != tc.want {
			status = "✗"
		}
		fmt.Printf("Test %d %s: k=%d, prices=%v, got=%d, want=%d\n",
			i+1, status, tc.k, tc.prices, result, tc.want)
	}
}