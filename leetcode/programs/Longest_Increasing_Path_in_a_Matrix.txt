package main

import (
	"fmt"
)

func longestIncreasingPath(matrix [][]int) int {
	if len(matrix) == 0 || len(matrix[0]) == 0 {
		return 0
	}

	rows := len(matrix)
	cols := len(matrix[0])
	memo := make([][]int, rows)
	for i := range memo {
		memo[i] = make([]int, cols)
	}

	maxLength := 0
	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			length := dfs(matrix, memo, i, j, rows, cols)
			if length > maxLength {
				maxLength = length
			}
		}
	}

	return maxLength
}

func dfs(matrix [][]int, memo [][]int, row, col, rows, cols int) int {
	if memo[row][col] != 0 {
		return memo[row][col]
	}

	maxLength := 1
	directions := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}

	for _, dir := range directions {
		newRow := row + dir[0]
		newCol := col + dir[1]

		if newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols &&
			matrix[newRow][newCol] > matrix[row][col] {
			length := 1 + dfs(matrix, memo, newRow, newCol, rows, cols)
			if length > maxLength {
				maxLength = length
			}
		}
	}

	memo[row][col] = maxLength
	return maxLength
}

func main() {
	testCases := []struct {
		matrix   [][]int
		expected int
	}{
		{
			matrix:   [][]int{{9, 9, 4}, {6, 6, 8}, {2, 1, 1}},
			expected: 4,
		},
		{
			matrix:   [][]int{{3, 4, 5}, {3, 2, 6}, {2, 2, 1}},
			expected: 4,
		},
		{
			matrix:   [][]int{{1}},
			expected: 1,
		},
		{
			matrix:   [][]int{{1, 2}, {3, 4}},
			expected: 4,
		},
		{
			matrix:   [][]int{{0}},
			expected: 1,
		},
		{
			matrix:   [][]int{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}},
			expected: 1,
		},
	}

	for i, tc := range testCases {
		result := longestIncreasingPath(tc.matrix)
		status := "PASS"
		if result != tc.expected {
			status = "FAIL"
		}
		fmt.Printf("Test %d: %s (Expected: %d, Got: %d)\n", i+1, status, tc.expected, result)
	}
}