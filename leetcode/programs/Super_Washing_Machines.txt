package main

import (
	"fmt"
)

func findMinMoves(machines []int) int {
	n := len(machines)
	
	// Calculate total dresses
	total := 0
	for _, m := range machines {
		total += m
	}
	
	// Check if equal distribution is possible
	if total%n != 0 {
		return -1
	}
	
	target := total / n
	
	// Check if any machine already has more than target
	for _, m := range machines {
		if m > target {
			return -1
		}
	}
	
	// Calculate minimum moves using left and right flow
	maxMoves := 0
	leftFlow := 0
	
	for i := 0; i < n; i++ {
		// Calculate how many dresses need to flow from left to right at position i
		// leftFlow represents net flow from left to this machine
		leftFlow += machines[i] - target
		
		// rightFlow represents net flow from right to this machine
		rightFlow := -leftFlow
		
		// The moves needed at position i is the maximum of:
		// 1. |leftFlow| - dresses flowing left (if leftFlow < 0, dresses come from right)
		// 2. rightFlow - dresses flowing right (if rightFlow > 0, dresses go to right)
		// But we need to think about it differently:
		// - If leftFlow > 0: dresses flow right, takes leftFlow moves
		// - If rightFlow > 0: dresses flow left, takes rightFlow moves
		// - Maximum of absolute values gives us the bottleneck
		
		movesAtI := maxInt(absInt(leftFlow), absInt(rightFlow))
		maxMoves = maxInt(maxMoves, movesAtI)
	}
	
	return maxMoves
}

func absInt(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func maxInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	testCases := []struct {
		machines []int
		expected int
	}{
		{[]int{1, 0, 5}, 3},
		{[]int{0, 3, 0}, 2},
		{[]int{0, 2, 0}, -1},
		{[]int{1, 1, 1}, 0},
		{[]int{5, 0, 0, 0}, -1},
		{[]int{0, 0, 11, 5}, 3},
	}
	
	for i, tc := range testCases {
		result := findMinMoves(tc.machines)
		status := "✓"
		if result != tc.expected {
			status = "✗"
		}
		fmt.Printf("Test %d: %s\nInput: %v\nExpected: %d, Got: %d\n\n", 
			i+1, status, tc.machines, tc.expected, result)
	}
}